{"task_id": "truthtable1", "gptgen_RTL": ["module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\nassign f = (~x3 & x2) | (x3 & x1) | (x2 & x1);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n    // Implementing the logic based on the given truth table\n    assign f = (~x3 & x2) | (x1 & x3);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1) | (x1 & x2);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1) | (x2 & x1);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\nassign f = (~x3 & x2) | (x3 & x1) | (x1 & x2);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1) | (x1 & x2);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x1 & ~x3) | (x3 & x1);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x3 & x1);\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (~x3 & x2) | (x1 & (x3 | x2));\n\nendmodule\n", "module top_module (\n    input x3,\n    input x2,\n    input x1,\n    output f\n);\n\n    assign f = (x3 & x1) | (~x3 & x2);\n\nendmodule\n"]}
{"task_id": "gates100", "gptgen_RTL": ["module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in; // AND reduction operator\n    assign out_or = |in;  // OR reduction operator\n    assign out_xor = ^in; // XOR reduction operator\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Output of a 100-input AND gate\n    assign out_and = &in;\n\n    // Output of a 100-input OR gate\n    assign out_or = |in;\n\n    // Output of a 100-input XOR gate\n    genvar i;\n    wire [99:0] intermediate_xor;\n\n    assign intermediate_xor[0] = in[0];\n\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : xor_loop\n            assign intermediate_xor[i] = intermediate_xor[i-1] ^ in[i];\n        end\n    endgenerate\n\n    assign out_xor = intermediate_xor[99];\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in; // AND reduction operation on all 100 bits\n    assign out_or = |in;  // OR reduction operation on all 100 bits\n    assign out_xor = ^in; // XOR reduction operation on all 100 bits\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Generating the AND operation for all 100 inputs\n    assign out_and = &in;\n\n    // Generating the OR operation for all 100 inputs\n    assign out_or = |in;\n\n    // Generating the XOR operation for all 100 inputs\n    assign out_xor = ^in;\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Compute the AND of all 100 inputs\n    assign out_and = &in;\n\n    // Compute the OR of all 100 inputs\n    assign out_or = |in;\n\n    // Compute the XOR of all 100 inputs\n    assign out_xor = ^in;\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Using the & operator for bitwise AND across all 100 inputs\n    assign out_and = &in;\n\n    // Using the | operator for bitwise OR across all 100 inputs\n    assign out_or = |in;\n\n    // Using the ^ operator for bitwise XOR across all 100 inputs\n    // Since XOR of all bits is not directly supported in Verilog, using a loop to calculate\n    wire [99:0] temp_xor;\n    assign temp_xor[0] = in[0];\n    genvar i;\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : xor_loop\n            assign temp_xor[i] = temp_xor[i-1] ^ in[i];\n        end\n    endgenerate\n\n    assign out_xor = temp_xor[99];\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in; // AND reduction operator\n    assign out_or = |in;  // OR reduction operator\n    assign out_xor = ^in; // XOR reduction operator\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;\n    assign out_or = |in;\n    assign out_xor = ^in;\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = &in;   // AND reduction of all 100 inputs\n    assign out_or = |in;    // OR reduction of all 100 inputs\n    assign out_xor = ^in;   // XOR reduction of all 100 inputs\n\nendmodule\n"]}
{"task_id": "hadd", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// XOR gate to produce the sum\nassign sum = a ^ b;\n\n// AND gate to produce the carry-out\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n    // XOR gate for sum\n    assign sum = a ^ b;\n\n    // AND gate for carry out\n    assign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// XOR gate for sum\nassign sum = a ^ b;\n\n// AND gate for carry out\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// Sum is the XOR of a and b\nassign sum = a ^ b;\n\n// Carry out is the AND of a and b\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\nassign sum = a ^ b;  // XOR gate for sum\nassign cout = a & b; // AND gate for carry out\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// XOR gate for sum\nassign sum = a ^ b;\n\n// AND gate for carry out\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// Half Adder Logic\n// Sum = A XOR B\nassign sum = a ^ b;\n\n// Carry Out = A AND B\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// Sum is the XOR of inputs a and b\nassign sum = a ^ b;\n\n// Carry out is the AND of inputs a and b\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// XOR gate for sum\nassign sum = a ^ b;\n\n// AND gate for carry out\nassign cout = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output sum,\n    output cout\n);\n\n// XOR gate for sum\nassign sum = a ^ b;\n\n// AND gate for carry out\nassign cout = a & b;\n\nendmodule\n"]}
{"task_id": "always_if2", "gptgen_RTL": ["module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;  // Define behavior when cpu is not overheated\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;  // Define behavior when arrived\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated) \n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    output reg shut_off_computer,\n    input arrived,\n    input gas_tank_empty,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1;\n        else\n            shut_off_computer = 0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input cpu_overheated,\n    input arrived,\n    input gas_tank_empty,\n    output reg shut_off_computer,\n    output reg keep_driving\n);\n\n    always @(*) begin\n        if (cpu_overheated)\n            shut_off_computer = 1'b1;\n        else\n            shut_off_computer = 1'b0;\n    end\n\n    always @(*) begin\n        if (~arrived)\n            keep_driving = ~gas_tank_empty;\n        else\n            keep_driving = 1'b0;\n    end\n\nendmodule\n"]}
{"task_id": "fsm2s", "gptgen_RTL": ["module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // Define state encoding\n    parameter OFF = 0, ON = 1;\n\n    // State variable\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;  // Synchronous reset to OFF\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF;  // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case(state)\n            OFF: out = 0;\n            ON: out = 1;\n            default: out = 0;  // Ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State declaration using parameters\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            state <= OFF;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case(state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    reg state, next_state;\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: next_state = (j == 1'b1) ? ON : OFF;\n            ON:  next_state = (k == 1'b1) ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State declaration using parameters for better readability\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF; // Synchronous reset to OFF state\n        else\n            state <= next_state; // Transition to next state\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF;  // Default case to handle any unexpected states\n        endcase\n    end\n\n    // Output logic: output depends only on the state\n    always @(state) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n\n    // State declaration\n    typedef enum {OFF, ON} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= OFF; // Synchronous reset\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            OFF: out = 0;\n            ON:  out = 1;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // Define the state encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            state <= OFF;  // Synchronous reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j == 1'b1)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k == 1'b1)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF; // Default case to avoid latches\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            out <= 1'b0;\n        else begin\n            case (state)\n                OFF: out <= 1'b0;\n                ON: out <= 1'b1;\n                default: out <= 1'b0;\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State Declaration\n    typedef enum {OFF, ON} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= OFF;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            OFF: begin\n                if (j) next_state = ON;\n                else next_state = OFF;\n            end\n            ON: begin\n                if (k) next_state = OFF;\n                else next_state = ON;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            OFF: out = 0;\n            ON: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input reset,\n    output reg out\n);\n    // State Encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case(state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "vector3", "gptgen_RTL": ["module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n// Concatenate the input vectors and append two 1's at the LSB positions\nwire [31:0] concatenated;\n\nassign concatenated = {a, b, c, d, e, f, 2'b11};\n\n// Split concatenated inputs to form the outputs\nassign w = concatenated[31:24];\nassign x = concatenated[23:16];\nassign y = concatenated[15:8];\nassign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate all inputs and add two '1' bits at the end\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign slices of the concatenated vector to the outputs\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:8] y,\n    output [7:0] z\n);\n\n    // Concatenate all inputs and two 1-bits\n    wire [31:0] concatenated;\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign outputs\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:8] z\n);\n    // Temporary vector to hold concatenated inputs and the two 1 bits.\n    wire [31:0] temp;\n\n    // Concatenating inputs and appending two bits '11' at the end\n    assign temp = {a, b, c, d, e, f, 2'b11};\n\n    // Assigning each 8 bits of the temp to the outputs\n    assign w = temp[31:24];\n    assign x = temp[23:16];\n    assign y = temp[15:8];\n    assign z = temp[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Concatenate all inputs and add two 1-bits at the least significant bits\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Split the concatenated bits into four 8-bit output vectors\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:8] w,\n    output [7:8] x,\n    output [7:8] y,\n    output [7:8] z\n);\n\n    // Concatenate all the inputs and append two '1' bits at the least significant end\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign appropriate bits to each output\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Temp variable to hold the concatenated value\n    wire [31:0] concatenated_val;\n\n    // Concatenate inputs and add two '1' bits at the end\n    assign concatenated_val = {a, b, c, d, e, f, 2'b11};\n\n    // Split the concatenated signal into four 8-bit outputs\n    assign w = concatenated_val[31:24];\n    assign x = concatenated_val[23:16];\n    assign y = concatenated_val[15:8];\n    assign z = concatenated_val[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Declare a wire to hold the concatenated input vectors and the two appended 1 bits.\n    wire [31:0] concatenated;\n\n    // Concatenate all inputs together and append two 1 bits in the LSB positions.\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign outputs to corresponding bits of the concatenated wire.\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n    // Concatenate all inputs and add two '1' bits at the LSB\n    wire [31:0] concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign the concatenated inputs to the outputs\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n", "module top_module (\n    input [4:0] a,\n    input [4:0] b,\n    input [4:0] c,\n    input [4:0] d,\n    input [4:0] e,\n    input [4:0] f,\n    output [7:0] w,\n    output [7:0] x,\n    output [7:0] y,\n    output [7:0] z\n);\n\n    // Intermediate wire to hold the concatenated inputs and the two appended '1' bits\n    wire [31:0] concatenated;\n\n    // Concatenate all inputs and append two '1' bits at the LSB\n    assign concatenated = {a, b, c, d, e, f, 2'b11};\n\n    // Assign the outputs to the appropriate segments of the concatenated wire\n    assign w = concatenated[31:24];\n    assign x = concatenated[23:16];\n    assign y = concatenated[15:8];\n    assign z = concatenated[7:0];\n\nendmodule\n"]}
{"task_id": "circuit2", "gptgen_RTL": ["module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & ~c & ~d) | (~a & ~b & c & d) | (a & ~b & c & ~d) | (~a & b & ~c & d) | (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    // Assign output q based on the input conditions provided in the waveform table\n    assign q = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & d) | \n               (~a & b & c & ~d) | (a & ~b & ~c & d) | (a & b & ~c & ~d) |\n               (a & ~b & c & ~d) | (a & b & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b & ~c & ~d) | (a & ~b & c & ~d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (~a & ~b & ~c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\nassign q = (a & ~b & ~c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & b & ~c & ~d) | (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n// From the simulation waveforms, the output q seems to depend on the combination of inputs a, b, c, and d\n// Define the functionality of the circuit based on the given truth table\nassign q = (a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & ~d) | (~a & ~b & c & d) | (a & b & ~d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    assign q = (a & ~b & ~c & d) | (~a & b & ~c & d) | (~a & ~b & c & d) | (a & b & ~d) | (a & ~b & c);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & ~b & c & ~d) | (~a & ~b & c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | \n               (a & ~b & ~c & d) | (a & b & ~c & ~d) | (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q\n);\n\n    assign q = (a & b & ~c & d) |     // 80ns case\n               (~a & b & c & ~d) |   // 45ns case\n               (~a & ~b & c & d) |   // 30ns case\n               (a & ~b & c & d) |    // 60ns case\n               (a & b & ~d) |        // 75ns case\n               (~a & b & d) |        // 40ns case\n               (~a & ~b & ~c & ~d);  // 0ns to 15ns case\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & ~b & ~c & d) | (~a & b & ~c & d) | (a & b & ~c & ~d) | (~a & ~b & c & d) | (a & ~b & c & ~d) | (~a & b & c & ~d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n    // Logic derived from the waveform simulation\n    assign q = (a & ~b & ~c & d) | (~a & b & ~c & d) | (~a & b & c & ~d) | (a & ~b & c & ~d) |\n               (a & b & ~c & ~d) | (~a & ~b & c & d) | (a & b & c & c);\nendmodule\n"]}
{"task_id": "andgate", "gptgen_RTL": ["module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = a & b;\n\nendmodule\n"]}
{"task_id": "fsm1s", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    localparam STATE_A = 1'b0;\n    localparam STATE_B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_B;  // Synchronous reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            default: next_state = STATE_B;  // Default to state B (safe state)\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            STATE_B: out = 1'b1;\n            STATE_A: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    parameter STATE_A = 1'b0, STATE_B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_B;  // Reset to state B\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            STATE_B: begin\n                if (in == 1'b1) begin\n                    next_state = STATE_B;  // Stay in state B if input is 1\n                end else begin\n                    next_state = STATE_A;  // Move to state A if input is 0\n                end\n            end\n            STATE_A: begin\n                if (in == 1'b1) begin\n                    next_state = STATE_A;  // Stay in state A if input is 1\n                end else begin\n                    next_state = STATE_B;  // Move to state B if input is 0\n                end\n            end\n            default: begin\n                next_state = STATE_B;  // Default case to handle unknown states\n            end\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (state)\n            STATE_B: out = 1'b1;  // State B outputs 1\n            STATE_A: out = 1'b0;  // State A outputs 0\n            default: out = 1'b1;  // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum {STATE_A, STATE_B} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B; // Reset to state B\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: next_state = (in == 1) ? STATE_B : STATE_A;\n            STATE_A: next_state = (in == 1) ? STATE_A : STATE_B;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State Declaration\n    typedef enum {STATE_A, STATE_B} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= STATE_B; // Synchronous reset to state B\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_B: begin\n                if (in == 1)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_A: begin\n                if (in == 1)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State declaration\n    typedef enum reg {A, B} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= B; // Synchronous reset to state B\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            B: next_state = (in == 1'b1) ? B : A;\n            A: next_state = (in == 1'b1) ? A : B;\n            default: next_state = B; // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            B: out = 1'b1;\n            A: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State encoding\n    typedef enum {STATE_A, STATE_B} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_B;  // Synchronous reset to state B\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_B: begin\n                if (in == 0)\n                    next_state = STATE_A;\n                else\n                    next_state = STATE_B;\n            end\n            STATE_A: begin\n                if (in == 0)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            default: next_state = STATE_B;  // Default to state B\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            STATE_B: out = 1;\n            STATE_A: out = 0;\n            default: out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State declaration using parameters for readability\n    parameter A = 1'b0, B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= B; // Reset state is B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            B: next_state = in ? B : A;\n            A: next_state = in ? A : B;\n            default: next_state = B; // Default to state B for any undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            B: out = 1'b1;\n            A: out = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State Encoding\n    parameter A = 1'b0, B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;  // Reset state is B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B: next_state = (in == 1'b1) ? B : A;\n            A: next_state = (in == 1'b1) ? A : B;\n            default: next_state = B; // Default state should never be reached\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            B: out = 1'b1;\n            A: out = 1'b0;\n            default: out = 1'b1; // Default output if some unforeseen state occurs\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State Encoding\n    parameter A = 1'b0, B = 1'b1;\n\n    // Current state and next state variables\n    reg state, next_state;\n\n    // State register logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= B; // On reset, set to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            B: begin\n                if (in == 1'b0)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            A: begin\n                if (in == 1'b0)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            default: next_state = B; // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            B: out = 1'b1;\n            A: out = 1'b0;\n            default: out = 1'b1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State declaration using parameters for better readability\n    parameter A = 1'b0, B = 1'b1;\n\n    // Register to hold the current state\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= B;  // Synchronous reset to state B\n        else\n            state <= next_state;  // Move to the next state\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case(state)\n            B: next_state = in ? B : A;  // State B transitions\n            A: next_state = in ? A : B;  // State A transitions\n            default: next_state = B;  // Default state is B\n        endcase\n    end\n\n    // Output logic for the Moore machine\n    always @(*) begin\n        case(state)\n            B: out = 1'b1;  // Output is 1 in state B\n            A: out = 1'b0;  // Output is 0 in state A\n            default: out = 1'b1;  // Default output is 1\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q4g", "gptgen_RTL": ["module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal for XNOR output\n    wire xnor_out;\n\n    // XNOR gate operation\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR gate with XNOR output and in3\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal for the output of XNOR gate\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = ~(in1 ^ in2);\n\n    // XOR gate\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal for the output of the XNOR gate\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR gate with the output of XNOR gate and in3\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_out;\n\n    // XNOR operation between in1 and in2\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR operation between xnor_out and in3\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    // Intermediate signal for the output of the XNOR gate\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR gate\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    wire xnor_result;\n\n    // Two-input XNOR gate\n    assign xnor_result = ~(in1 ^ in2);\n\n    // Two-input XOR gate with the output of the XNOR and in3\n    assign out = xnor_result ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n    // Intermediate signal for the XNOR output\n    logic xnor_out;\n\n    // Two-input XNOR gate\n    assign xnor_out = ~(in1 ^ in2);\n\n    // Two-input XOR gate\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal declaration for the output of the XNOR gate\n    logic xnor_out;\n\n    // XNOR gate operation\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR gate operation, taking the result of the XNOR and in3 as inputs\n    assign out = xnor_out ^ in3;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal declaration\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = in1 ~^ in2;  // XNOR operation\n\n    // XOR gate combining the result of XNOR with in3\n    assign out = xnor_out ^ in3;   // XOR operation\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    input in3,\n    output logic out\n);\n\n    // Intermediate signal for XNOR output\n    logic xnor_out;\n\n    // XNOR gate\n    assign xnor_out = in1 ~^ in2;\n\n    // XOR gate with XNOR output and in3\n    assign out = xnor_out ^ in3;\n\nendmodule\n"]}
{"task_id": "ece241_2014_q3", "gptgen_RTL": ["module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Assignments for mux inputs based on the Karnaugh map\n    assign mux_in[0] = c & d;     // For ab=00, cd=11 (1)\n    assign mux_in[1] = c & ~d;    // For ab=01, cd=10 (1)\n    assign mux_in[2] = ~c & d;    // For ab=11, cd=01 (1)\n    assign mux_in[3] = c;         // For ab=10, cd=11, 10, 00 (1)\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implementing the logic for mux_in based on the Karnaugh map\n    assign mux_in[0] = (~c & d);   // for ab = 00 -> cd = 00\n    assign mux_in[1] = 0;          // for ab = 01 -> cd = 01\n    assign mux_in[2] = (c & d);    // for ab = 11 -> cd = 11\n    assign mux_in[3] = (c | d);    // for ab = 10 -> cd = 10\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implement the logic based on the Karnaugh map using 2-to-1 MUXes\n    // K-map output for each combination of c and d\n    // mux_in[0] = f(c,d) when ab = 00 -> K-map result: 0\n    // mux_in[1] = f(c,d) when ab = 01 -> K-map result: 0\n    // mux_in[2] = f(c,d) when ab = 11 -> K-map result: 1\n    // mux_in[3] = f(c,d) when ab = 10 -> K-map result: 1\n\n    // Assign direct results based on the K-map:\n    assign mux_in[0] = 0;\n    assign mux_in[1] = 0;\n    \n    // For mux_in[2] and mux_in[3], we need to consider c and d:\n    // From the K-map:\n    // mux_in[2] = 1 only when (c,d) = (11)\n    // mux_in[3] = 1 when (c,d) = (00), (10), (11)\n    // Using 2-to-1 MUXes for simplifying expressions:\n    // mux_in[2] = c & d\n    // mux_in[3] = !c & !d | c & !d | c & d = !c & !d | c\n\n    wire not_c = ~c;\n    wire not_d = ~d;\n\n    // Using 2-to-1 multiplexers:\n    // MUX for mux_in[2]: direct AND of c and d\n    assign mux_in[2] = c & d;\n\n    // MUX for mux_in[3]:\n    // First level MUXes to create necessary intermediate signals\n    wire mux3_intermediate1, mux3_intermediate2;\n    assign mux3_intermediate1 = not_c & not_d;  // For !c & !d\n    assign mux3_intermediate2 = c & not_d;      // For c & !d\n\n    // Final output MUX for mux_in[3] combining the intermediate results and c & d\n    assign mux_in[3] = mux3_intermediate1 | mux3_intermediate2 | (c & d);\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Using c and d to determine the inputs for each selection line of the 4-to-1 multiplexer\n    // First, map the values of mux_in[0], mux_in[1], mux_in[2], and mux_in[3] based on the K-map:\n    // mux_in[0] = ab=00, cd=00 -> 0, ab=00, cd=01 -> 1, ab=00, cd=11 -> 1, ab=00, cd=10 -> 1\n    // mux_in[1] = ab=01, cd=00 -> 0, ab=01, cd=01 -> 0, ab=01, cd=11 -> 0, ab=01, cd=10 -> 0\n    // mux_in[2] = ab=11, cd=00 -> 0, ab=11, cd=01 -> 0, ab=11, cd=11 -> 1, ab=11, cd=10 -> 0\n    // mux_in[3] = ab=10, cd=00 -> 1, ab=10, cd=01 -> 0, ab=10, cd=11 -> 1, ab=10, cd=10 -> 1\n\n    // Define each mux_in based on c and d inputs\n    // Using the Karnaugh map simplification:\n    // Mux_in[0] = c and (not d or d)\n    assign mux_in[0] = c;\n\n    // Mux_in[1] always 0 as per K-map\n    assign mux_in[1] = 0;\n\n    // Mux_in[2] = c and d\n    assign mux_in[2] = c & d;\n\n    // Mux_in[3] = not d or (c and d)\n    assign mux_in[3] = ~d | (c & d);\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implementing the logic for each mux_in output based on the Karnaugh map:\n    // c and d are inputs, and each output mux_in[i] represents a unique combination of {c,d}\n    \n    // For mux_in[0] with {c,d} = 00\n    assign mux_in[0] = d & (~c);  // cd = 00, value is 1 when d=1, c=0\n\n    // For mux_in[1] with {c,d} = 01\n    assign mux_in[1] = 0;         // cd = 01, value is consistently 0\n\n    // For mux_in[2] with {c,d} = 11\n    assign mux_in[2] = c;         // cd = 11, value follows c (1 for c=1, 0 for c=0)\n\n    // For mux_in[3] with {c,d} = 10\n    assign mux_in[3] = (~c) | d;  // cd = 10, value is 1 if either c=0 or d=1\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Assign values to mux_in[3:0] based on the Karnaugh map provided.\n    assign mux_in[0] = (~c & ~d);  // ab=00, cd=00\n    assign mux_in[1] = (~c & d);   // ab=01, cd=01\n    assign mux_in[2] = (c & ~d);   // ab=11, cd=10\n    assign mux_in[3] = (c & d) | (~c & d) | (c & ~d); // ab=10, cd=11, 01, 10\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implementing the mux_in outputs based on the Karnaugh map values\n    // mux_in[0] = ab=00 -> f(c,d) = c'd + cd'\n    assign mux_in[0] = (~c & d) | (c & ~d);\n\n    // mux_in[1] = ab=01 -> f(c,d) = 0\n    assign mux_in[1] = 0;\n\n    // mux_in[2] = ab=11 -> f(c,d) = c\n    assign mux_in[2] = c;\n\n    // mux_in[3] = ab=10 -> f(c,d) = c + d'\n    assign mux_in[3] = c | ~d;\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implementing the outputs based on the given Karnaugh map\n    // We map the inputs c and d to outputs mux_in[3:0] as per the K-map\n    // ab\n    // cd   00 01 11 10\n    //  00 | 0 | 0 | 0 | 1 |\n    //  01 | 1 | 0 | 0 | 0 |\n    //  11 | 1 | 0 | 1 | 1 |\n    //  10 | 1 | 0 | 0 | 1 |\n\n    assign mux_in[0] = (c & ~d); // Corresponds to cd = 10\n    assign mux_in[1] = 0;        // No states for ab=01 yield a 1 except for 11 which requires more than c and d.\n    assign mux_in[2] = (c & d);  // Corresponds to cd = 11\n    assign mux_in[3] = (~c & ~d) | (c & ~d) | (c & d); // Corresponds to cd = 00, 10, 11 where output is 1\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Implementing the Karnaugh map values using multiplexer inputs\n    // mux_in[0] = 00, mux_in[1] = 01, mux_in[2] = 11, mux_in[3] = 10\n    assign mux_in[0] = (c & ~d);  // 01 -> c=0, d=0\n    assign mux_in[1] = 0;         // 01 -> c=0, d=1\n    assign mux_in[2] = (c & d);   // 11 -> c=1, d=1\n    assign mux_in[3] = (c | ~d);  // 10 -> c=1, d=0\n\nendmodule\n", "module top_module (\n    input c,\n    input d,\n    output [3:0] mux_in\n);\n\n    // Define the outputs based on the Karnaugh map provided\n    // ab = 00, 01, 11, 10\n    // cd = 00, 01, 11, 10\n    //      0    0    0    1\n    //      1    0    0    0\n    //      1    0    1    1\n    //      1    0    0    1\n\n    assign mux_in[0] = (c & d);            // cd = 10\n    assign mux_in[1] = 0;                  // No combination leads to a 1 for ab=01\n    assign mux_in[2] = c;                  // Simplified from (c & ~d) | (c & d)\n    assign mux_in[3] = (c & ~d) | (~c & d); // Simplified from XOR operation for cd = 00\n\nendmodule\n"]}
{"task_id": "ece241_2014_q5b", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State Encoding\n    parameter A = 2'b01, B = 2'b10;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b1) ? B : A;\n            B: next_state = (x == 1'b0) ? B : B;\n            default: next_state = A; // default case for safety\n        endcase\n    end\n\n    // Output logic based on the current state and input\n    always @(*) begin\n        case (state)\n            A: z = (x == 1'b1) ? 1'b1 : 1'b0;\n            B: z = (x == 1'b0) ? 1'b1 : 1'b0;\n            default: z = 1'b0; // default to 0 if state is undefined\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding using one-hot method\n    reg [1:0] state;\n    reg [1:0] next_state;\n\n    // State declaration\n    localparam A = 2'b01,\n               B = 2'b10;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;  // Asynchronous reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 0) begin\n                    next_state = A;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            B: begin\n                if (x == 0) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = B;\n                    z = 0;\n                end\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State Encoding\n    parameter A = 2'b01, B = 2'b10;\n\n    // State Register\n    reg [1:0] state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic using one-hot encoding\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b0) ? A : B;\n            B: next_state = B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (state)\n            A: z = x;  // When in state A, output equals the input\n            B: z = ~x; // When in state B, output is the complement of the input\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State encoding\n    localparam A = 2'b01;\n    localparam B = 2'b10;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b0) ? A : B;\n            B: next_state = B;\n            default: next_state = A;  // Default to state A on any undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = (x == 1'b1) ? 1'b1 : 1'b0;\n            B: z = (x == 1'b0) ? 1'b1 : 1'b0;\n            default: z = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State Definition using one-hot encoding\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;  // Asynchronous reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 1) begin\n                    next_state = B;\n                    z = 1;  // Output when transitioning from A to B\n                end else begin\n                    next_state = A;\n                    z = 0;  // Output stays 0 in state A with x=0\n                end\n            end\n            B: begin\n                if (x == 1) begin\n                    next_state = B;\n                    z = 0;  // Output when staying in B with x=1\n                end else begin\n                    next_state = B;\n                    z = 1;  // Output when staying in B with x=0\n                end\n            end\n            default: begin\n                next_state = A;  // Default case to handle unknown states\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding using one-hot encoding\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Asynchronous reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 0) begin\n                    next_state = A;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            B: begin\n                if (x == 0) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = B;\n                    z = 0;\n                end\n            end\n            default: next_state = A; // Default case to handle any undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding using one-hot method\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Asynchronous reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 0) begin\n                    next_state = A;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            B: begin\n                if (x == 0) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = B;\n                    z = 0;\n                end\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    parameter A = 2'b01;\n    parameter B = 2'b10;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 1) begin\n                    next_state = B;\n                    z = 1;\n                end else begin\n                    next_state = A;\n                    z = 0;\n                end\n            end\n            B: begin\n                if (x == 1) begin\n                    next_state = B;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            default: begin\n                next_state = A; // Default case to handle unknown states\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // Define state encoding using one-hot encoding\n    reg [1:0] state, next_state;\n    localparam A = 2'b01, B = 2'b10;\n    \n    // State transition logic (next state logic)\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= A;  // Asynchronous reset to state A\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Next state and output logic (combinational logic)\n    always @(*) begin\n        case (state)\n            A: begin\n                if (x == 0) begin\n                    next_state = A;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            B: begin\n                if (x == 1) begin\n                    next_state = B;\n                    z = 0;\n                end else begin\n                    next_state = B;\n                    z = 1;\n                end\n            end\n            default: begin\n                next_state = A;  // Default state is A\n                z = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    localparam A = 2'b01,\n               B = 2'b10;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (x == 1'b0) ? A : B;\n            B: next_state = (x == 1'b1) ? B : B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = (x == 1'b1) ? 1'b1 : 1'b0;\n            B: z = (x == 1'b1) ? 1'b0 : 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\nendmodule\n"]}
{"task_id": "circuit10", "gptgen_RTL": ["module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a & b) begin\n            state <= ~state;\n        end else begin\n            state <= state;\n        end\n    end\n\n    always @(*) begin\n        q = state;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\nalways @(posedge clk) begin\n    if (a && b) begin\n        state <= !state;\n    end\n    else if (a || b) begin\n        state <= 1;\n    end\n    else begin\n        state <= 0;\n    end\n\n    q <= state;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            state <= ~state;\n        end else if (a || b) begin\n            state <= 1;\n        end else begin\n            state <= 0;\n        end\n        \n        q <= state;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n    always @(posedge clk) begin\n        if (a & b) begin\n            state <= ~state;\n        end else if (a | b) begin\n            state <= state;\n        end else begin\n            state <= 0;\n        end\n\n        q <= state;\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\nalways @(posedge clk) begin\n    if ((a & b) | (state & ~a & ~b)) begin\n        state <= 1;\n    end else if (~a & ~b) begin\n        state <= 0;\n    end\n\n    q <= state;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            state <= ~state;\n        end else if (a) begin\n            state <= state;\n        end else begin\n            state <= 0;\n        end\n\n        q <= state;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            state <= ~state;\n        end else if (!a && !b) begin\n            state <= state;\n        end else if (a && !b) begin\n            state <= 1;\n        end else if (!a && b) begin\n            state <= 0;\n        end\n\n        q <= state;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\n    always @(posedge clk) begin\n        if (a && b) begin\n            state <= !state;\n        end else if (!a && !b) begin\n            state <= 0;\n        end\n\n        q <= state;\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\nalways @(posedge clk) begin\n    if (a && b)\n        state <= ~state;\n    else if (a || b)\n        state <= 1'b1;\n    else\n        state <= 1'b0;\n\n    q <= state;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    input b,\n    output reg q,\n    output reg state\n);\n\nalways @(posedge clk) begin\n    if (a & b) begin\n        state <= ~state;\n    end else begin\n        state <= state;\n    end\n\n    // Update q based on state\n    if (state) begin\n        q <= ~q;\n    end else begin\n        q <= q;\n    end\nend\n\nendmodule\n"]}
{"task_id": "2012_q1g", "gptgen_RTL": ["module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0010, 4'b1100, 4'b1101, 4'b1110, 4'b1000, 4'b1001, 4'b1010: f = 1;\n            default: f = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implement the function f using the Karnaugh map provided\n    assign f = (x == 4'b0000) || (x == 4'b0010) || (x == 4'b1100) || \n               (x == 4'b1101) || (x == 4'b1110) || (x == 4'b1000) || \n               (x == 4'b1001) || (x == 4'b1010);\n    \nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the function using the provided Karnaugh map\n    assign f = (x[4:3] == 2'b00 && (x[2:1] == 2'b00 || x[2:1] == 2'b10)) ||\n               (x[4:3] == 2'b11 && (x[2:1] != 2'b11)) ||\n               (x[4:3] == 2'b10 && (x[2:1] == 2'b00 || x[2:1] == 2'b01 || x[2:1] == 2'b10));\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0000, 4'b0010, 4'b1100, 4'b1101, 4'b1110, 4'b1000, 4'b1001, 4'b1011: f = 1'b1;\n            default: f = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Decode the input x\n    wire x1, x2, x3, x4;\n    assign x1 = x[1];\n    assign x2 = x[2];\n    assign x3 = x[3];\n    assign x4 = x[4];\n\n    // Implement the function using the Karnaugh map results\n    assign f = (x3 & x4 & x2 & ~x1) |        // 1110\n               (x3 & x4 & ~x2 & x1) |        // 1101\n               (x3 & ~x4 & ~x2 & ~x1) |      // 1000\n               (~x3 & ~x4 & x2 & ~x1) |      // 0010\n               (~x3 & ~x4 & ~x2 & ~x1);      // 0000\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Evaluate the function f based on the provided Karnaugh map\n    always @(*) begin\n        case (x)\n            4'b0000: f = 1;\n            4'b0001: f = 0;\n            4'b0011: f = 0;\n            4'b0010: f = 1;\n            4'b0100: f = 0;\n            4'b0101: f = 0;\n            4'b0111: f = 0;\n            4'b0110: f = 0;\n            4'b1100: f = 1;\n            4'b1101: f = 1;\n            4'b1111: f = 1;\n            4'b1110: f = 0;\n            4'b1000: f = 1;\n            4'b1001: f = 1;\n            4'b1011: f = 0;\n            4'b1010: f = 1;\n            default: f = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implement the function based on the Karnaugh Map\n    assign f = (x[4:3] == 2'b00 && (x[2:1] == 2'b00 || x[2:1] == 2'b10)) ||\n               (x[4:3] == 2'b11 && (x[2:1] != 2'b10)) ||\n               (x[4:3] == 2'b10 && (x[2:1] != 2'b10));\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0000 : f = 1; // x4 x3 x2 x1 = 0000\n            4'b0010 : f = 1; // x4 x3 x2 x1 = 0010\n            4'b1100 : f = 1; // x4 x3 x2 x1 = 1100\n            4'b1101 : f = 1; // x4 x3 x2 x1 = 1101\n            4'b1111 : f = 1; // x4 x3 x2 x1 = 1111\n            4'b1000 : f = 1; // x4 x3 x2 x1 = 1000\n            4'b1001 : f = 1; // x4 x3 x2 x1 = 1001\n            4'b1010 : f = 1; // x4 x3 x2 x1 = 1010\n            default : f = 0; // Default case for all other input combinations\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0010, 4'b1100, 4'b1101, 4'b1110, 4'b1000, 4'b1001: f = 1;\n            default: f = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Using the Karnaugh map, we simplify the Boolean function.\n    // The minimized function is obtained from the map.\n    // f = x1'x2'x3'x4 + x1'x2'x3x4' + x1'x2x3x4' + x1x2'x3'x4 + x1x2'x3x4' + x1x2x3'x4'\n    \n    assign f = (~x[1] & ~x[2] & ~x[3] & x[4]) | \n               (~x[1] & ~x[2] & x[3] & ~x[4]) | \n               (~x[1] & x[2] & x[3] & ~x[4]) | \n               (x[1] & ~x[2] & ~x[3] & x[4]) | \n               (x[1] & ~x[2] & x[3] & ~x[4]) | \n               (x[1] & x[2] & ~x[3] & ~x[4]);\n\nendmodule\n"]}
{"task_id": "fsm_hdlc", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    parameter S0 = 3'b000, // Start state, looking for first '0'\n             S1 = 3'b001, // Found first '0'\n             S2 = 3'b010, // Found 0, then 1\n             S3 = 3'b011, // Found 0, then two 1s\n             S4 = 3'b100, // Found 0, then three 1s\n             S5 = 3'b101, // Found 0, then four 1s\n             S6 = 3'b110, // Found 0, then five 1s\n             S7 = 3'b111; // Found 0, then six 1s, potentially error state\n\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S2 : S1; // Looking for 1 after initial 0\n            S1: next_state = in ? S2 : S1;\n            S2: next_state = in ? S3 : S1; // Accumulating 1s\n            S3: next_state = in ? S4 : S1;\n            S4: next_state = in ? S5 : S1;\n            S5: next_state = in ? S6 : S1;\n            S6: next_state = in ? S7 : S1; // Transition to state to check for flag or disc\n            S7: next_state = in ? S7 : S1; // Stay in error state if consecutive 1s continue\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        disc <= 0;\n        flag <= 0;\n        err <= 0;\n        if (state == S6 && !in) begin\n            flag <= 1; // On transition from S6 to S1 when input is '0'\n        end else if (state == S6 && in) begin\n            disc <= 1; // On transition from S6 to S7 when input is '1'\n        end else if (state == S7 && in) begin\n            err <= 1; // Stay in error state\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    localparam S0 = 3'b000, // No consecutive 1s found yet (initial state)\n               S1 = 3'b001, // 1 consecutive 1 found\n               S2 = 3'b010, // 2 consecutive 1s found\n               S3 = 3'b011, // 3 consecutive 1s found\n               S4 = 3'b100, // 4 consecutive 1s found\n               S5 = 3'b101, // 5 consecutive 1s found\n               S6 = 3'b110, // 6 consecutive 1s found (flag point)\n               S7 = 3'b111; // 7 or more consecutive 1s found (error)\n\n    // State register\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Defaults for outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n\n        case (current_state)\n            S0: begin\n                if (in)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (in)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            end\n            S2: begin\n                if (in)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            S3: begin\n                if (in)\n                    next_state = S4;\n                else\n                    next_state = S0;\n            end\n            S4: begin\n                if (in)\n                    next_state = S5;\n                else\n                    next_state = S0;\n            end\n            S5: begin\n                if (in)\n                    next_state = S6;\n                else\n                    next_state = S0;\n            end\n            S6: begin\n                if (in)\n                    next_state = S7;\n                else {\n                    next_state = S0;\n                    flag = 1; // Flag detected\n                }\n            end\n            S7: begin\n                if (in)\n                    next_state = S7; // Stay in error state if still receiving 1s\n                else\n                    next_state = S0;\n                err = 1; // Error detected\n            end\n            default: next_state = S0;\n        endcase\n\n        // Discard signal: when in state S5 and next input is 1, leading to S6\n        if (current_state == S5 && in)\n            disc = 1;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S0, // Initial state\n        S1, // Seen 1\n        S2, // Seen 11\n        S3, // Seen 111\n        S4, // Seen 1111\n        S5, // Seen 11111\n        S6, // Seen 111110\n        S7, // Seen 111111\n        ERROR // Seen 7 or more consecutive 1s\n    } state_type;\n\n    // Current and next states\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? ERROR : S0;\n            ERROR: next_state = in ? ERROR : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n            case (current_state)\n                S6: if (in == 0) disc <= 1; // Discard bit after fifth consecutive 1\n                S7: if (in == 0) flag <= 1; // Flag the frame boundary\n                ERROR: err <= 1; // Error if 7 or more consecutive 1s\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n    // State declaration\n    typedef enum reg [2:0] {\n        S0, // Initial state\n        S1, // Seen 0\n        S2, // Seen 01\n        S3, // Seen 011\n        S4, // Seen 0111\n        S5, // Seen 01111\n        S6, // Seen 011111\n        S7, // Seen 0111111 (error or discard)\n        ERROR // Error state\n    } state_t;\n\n    // State register\n    reg [2:0] state, next_state;\n    \n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? ERROR : S0;\n            ERROR: next_state = in ? ERROR : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Defaults\n        disc = 0;\n        flag = 0;\n        err = 0;\n\n        case (state)\n            S7: begin\n                if (!in) begin\n                    flag = 1; // 01111110\n                end else begin\n                    disc = 1; // 0111110\n                end\n            end\n            ERROR: begin\n                err = 1; // 01111111... more than seven 1's\n            end\n            default: begin\n                disc = 0;\n                flag = 0;\n                err = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State Declarations\n    typedef enum reg [3:0] {\n        S0, S1, S2, S3, S4, S5, S6, S7, S_ERROR\n    } state_type;\n\n    // State variable\n    reg [3:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= S0;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S_ERROR : S0;\n            S_ERROR: next_state = in ? S_ERROR : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        // Default output\n        disc <= 0;\n        flag <= 0;\n        err <= 0;\n        \n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            case (current_state)\n                S6: if (!in) disc <= 1;  // 0111110\n                S7: if (in) err <= 1;   // 01111111...\n                    else flag <= 1;     // 01111110\n                S_ERROR: err <= 1;      // 7 or more consecutive 1s\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // Define state identifiers\n    parameter IDLE = 0, S1 = 1, S2 = 2, S3 = 3, S4 = 4, S5 = 5, S5A = 6, S6 = 7, ERROR = 8;\n\n    reg [3:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            IDLE: next_state = in ? S1 : IDLE;\n            S1: next_state = in ? S2 : IDLE;\n            S2: next_state = in ? S3 : IDLE;\n            S3: next_state = in ? S4 : IDLE;\n            S4: next_state = in ? S5 : IDLE;\n            S5: next_state = in ? S5A : IDLE;\n            S5A: next_state = in ? S6 : IDLE;\n            S6: next_state = in ? ERROR : IDLE;\n            ERROR: next_state = in ? ERROR : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end\n        else begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n\n            case (state)\n                S5A: begin\n                    if (in == 0)\n                        disc <= 1; // Discard the bit\n                end\n                S6: begin\n                    if (in == 0)\n                        flag <= 1; // Flag found\n                    else\n                        err <= 1; // Error\n                end\n                ERROR: begin\n                    err <= 1; // Continuous 1's, error\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n    // State declaration using parameters\n    parameter S0 = 3'b000, // No 1s detected, or just 0s received\n              S1 = 3'b001, // 1st 1 detected\n              S2 = 3'b010, // 2nd consecutive 1\n              S3 = 3'b011, // 3rd consecutive 1\n              S4 = 3'b100, // 4th consecutive 1\n              S5 = 3'b101, // 5th consecutive 1, after this a 0 should be discarded\n              S6 = 3'b110, // 6th consecutive 1, frame flag\n              S7 = 3'b111; // 7 or more consecutive 1s (error)\n\n    // Current and next state variables\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= S0;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic (Moore machine)\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? S7 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end\n        else begin\n            // By default, outputs are low\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n\n            case (current_state)\n                S5: begin\n                    if (in == 0)\n                        disc <= 1; // Discard the bit\n                end\n                S6: begin\n                    if (in == 0)\n                        flag <= 1; // Beginning or end of a frame\n                end\n                S7: begin\n                    if (in == 1)\n                        err <= 1; // Error for 7 or more consecutive 1s\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State Encoding\n    parameter IDLE = 3'b000, S1 = 3'b001, S2 = 3'b010, S3 = 3'b011, \n              S4 = 3'b100, S5 = 3'b101, S6 = 3'b110, ERROR = 3'b111;\n\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            state <= IDLE;\n        else \n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: next_state = in ? S1 : IDLE;\n            S1: next_state = in ? S2 : IDLE;\n            S2: next_state = in ? S3 : IDLE;\n            S3: next_state = in ? S4 : IDLE;\n            S4: next_state = in ? S5 : IDLE;\n            S5: next_state = in ? S6 : IDLE;\n            S6: next_state = in ? ERROR : IDLE;\n            ERROR: next_state = in ? ERROR : IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            disc <= 1'b0;\n            flag <= 1'b0;\n            err <= 1'b0;\n        end else begin\n            case(state)\n                IDLE: begin\n                    disc <= 1'b0;\n                    flag <= 1'b0;\n                    err <= 1'b0;\n                end\n                S6: begin\n                    if (in) err <= 1'b1;\n                    else flag <= 1'b1;\n                end\n                ERROR: begin\n                    err <= 1'b1;\n                    flag <= 1'b0;\n                    disc <= 1'b0;\n                end\n                default: begin\n                    disc <= 1'b0;\n                    flag <= 1'b0;\n                    err <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // State Encoding\n    typedef enum int {\n        S0, S1, S2, S3, S4, S5, S6, S7, SERROR\n    } state_t;\n\n    // State Register\n    state_t current_state, next_state;\n\n    // State Transition Logic (Moore FSM)\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = in ? S1 : S0;\n            S1: next_state = in ? S2 : S0;\n            S2: next_state = in ? S3 : S0;\n            S3: next_state = in ? S4 : S0;\n            S4: next_state = in ? S5 : S0;\n            S5: next_state = in ? S6 : S0;\n            S6: next_state = in ? S7 : S0;\n            S7: next_state = in ? SERROR : S0;\n            SERROR: next_state = in ? SERROR : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        // Default output\n        disc <= 0;\n        flag <= 0;\n        err <= 0;\n\n        if (reset) begin\n            disc <= 0;\n            flag <= 0;\n            err <= 0;\n        end else begin\n            case (current_state)\n                S6: if (in == 0) disc <= 1;  // 0111110\n                S7: if (in == 1) err <= 1;  // 01111111... error condition\n                    else flag <= 1;         // 01111110 flag condition\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input in,\n    output reg disc,\n    output reg flag,\n    output reg err\n);\n\n    // Define state identifiers\n    reg [3:0] state, next_state;\n\n    // State encoding\n    localparam  S0 = 4'b0000,\n                S1 = 4'b0001,\n                S2 = 4'b0010,\n                S3 = 4'b0011,\n                S4 = 4'b0100,\n                S5 = 4'b0101,\n                S6 = 4'b0110,\n                S7 = 4'b0111,\n                ERROR = 4'b1000;\n\n    // Sequential logic for state transitioning\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic for next state and output logic\n    always @(*) begin\n        // Default outputs\n        disc = 0;\n        flag = 0;\n        err = 0;\n        next_state = state; // Default state: stay in current state unless conditions cause a state change\n\n        case (state)\n            S0: begin\n                if (in == 1)\n                    next_state = S1;\n            end\n            S1: begin\n                if (in == 1)\n                    next_state = S2;\n                else\n                    next_state = S0;\n            end\n            S2: begin\n                if (in == 1)\n                    next_state = S3;\n                else\n                    next_state = S0;\n            end\n            S3: begin\n                if (in == 1)\n                    next_state = S4;\n                else\n                    next_state = S0;\n            end\n            S4: begin\n                if (in == 1)\n                    next_state = S5;\n                else\n                    next_state = S0;\n            end\n            S5: begin\n                if (in == 1)\n                    next_state = S6;\n                else\n                    next_state = S0;\n            end\n            S6: begin\n                if (in == 1)\n                    next_state = S7;\n                else begin\n                    next_state = S0;\n                    disc = 1;\n                end\n            end\n            S7: begin\n                if (in == 1)\n                    next_state = ERROR;\n                else begin\n                    next_state = S0;\n                    flag = 1;\n                end\n            end\n            ERROR: begin\n                if (in == 1)\n                    next_state = ERROR;\n                else\n                    next_state = S0;\n                err = 1;\n            end\n            default: next_state = S0;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "review2015_fancytimer", "gptgen_RTL": ["module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State encoding\n    localparam IDLE = 3'd0,\n               CHECK_PATTERN = 3'd1,\n               SHIFT_DELAY = 3'd2,\n               COUNTING = 3'd3,\n               NOTIFY = 3'd4,\n               WAIT_ACK = 3'd5;\n\n    // State register\n    reg [2:0] state = IDLE;\n\n    // Registers to hold the pattern and the delay value\n    reg [3:0] pattern_reg = 4'd0;\n    reg [3:0] delay_reg = 4'd0;\n    reg [3:0] temp_count = 4'd0;\n    reg [13:0] cycle_count = 14'd0; // enough bits to count up to 10,000 (max delay * 1000)\n\n    // Pattern to detect\n    localparam TARGET_PATTERN = 4'b1101;\n\n    // State machine\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            pattern_reg <= 4'd0;\n            delay_reg <= 4'd0;\n            counting <= 1'b0;\n            done <= 1'b0;\n            count <= 4'd0;\n            temp_count <= 4'd0;\n            cycle_count <= 14'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (data == TARGET_PATTERN[3]) begin\n                        state <= CHECK_PATTERN;\n                        pattern_reg <= {pattern_reg[2:0], data};\n                    end\n                end\n\n                CHECK_PATTERN: begin\n                    pattern_reg <= {pattern_reg[2:0], data};\n                    if (pattern_reg == TARGET_PATTERN) begin\n                        state <= SHIFT_DELAY;\n                        delay_reg <= 4'd0;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n\n                SHIFT_DELAY: begin\n                    delay_reg <= {delay_reg[2:0], data};\n                    if (&delay_reg) begin // Check if all bits shifted\n                        state <= COUNTING;\n                        temp_count <= delay_reg;\n                        cycle_count <= (delay_reg + 1) * 1000;\n                        counting <= 1'b1;\n                    end\n                end\n\n                COUNTING: begin\n                    if (cycle_count > 0) begin\n                        cycle_count <= cycle_count - 1;\n                        if (cycle_count % 1000 == 0) begin\n                            temp_count <= temp_count - 1;\n                        end\n                        count <= temp_count;\n                    end else begin\n                        state <= NOTIFY;\n                        counting <= 1'b0;\n                        count <= 4'd0;\n                        done <= 1'b1;\n                    end\n                end\n\n                NOTIFY: begin\n                    if (ack) begin\n                        state <= IDLE;\n                        done <= 1'b0;\n                    end\n                end\n\n                default: state <= IDLE;\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    localparam IDLE        = 3'd0;\n    localparam CHECK_START = 3'd1;\n    localparam LOAD_DELAY  = 3'd2;\n    localparam COUNTING    = 3'd3;\n    localparam FINISHED    = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] timer; // 12 bits to count up to 8000 cycles\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @* begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (data)\n                    next_state = CHECK_START;\n            end\n            CHECK_START: begin\n                if (shift_reg == 4'b1101)\n                    next_state = LOAD_DELAY;\n            end\n            LOAD_DELAY: begin\n                if (timer == 0)\n                    next_state = COUNTING;\n            end\n            COUNTING: begin\n                if (timer == 0)\n                    next_state = FINISHED;\n            end\n            FINISHED: begin\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output and internal logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 0;\n            delay <= 0;\n            counting <= 0;\n            done <= 0;\n            count <= 0;\n            timer <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                end\n                CHECK_START: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    timer <= 3; // Wait for 4 bits after 1101 detected\n                end\n                LOAD_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    delay <= shift_reg;\n                    timer <= (delay + 1) * 1000; // Load timer with delay\n                    counting <= 1;\n                end\n                COUNTING: begin\n                    if (timer > 0) begin\n                        timer <= timer - 1;\n                        count <= timer[12:9]; // Update count with current remaining time\n                    end else begin\n                        counting <= 0;\n                        done <= 1;\n                    }\n                end\n                FINISHED: begin\n                    if (ack) begin\n                        done <= 0;\n                        count <= 0; // Clear count when acknowledged\n                    }\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    localparam SEARCHING = 0,\n               CAPTURE_DELAY = 1,\n               COUNTING = 2,\n               DONE_WAIT = 3;\n\n    // Registers for state and delay\n    reg [1:0] state = SEARCHING;\n    reg [3:0] delay;\n    reg [3:0] captured_bits;\n    reg [12:0] timer; // Enough to count 10,000 cycles (0 to 9999)\n    reg [3:0] shift_reg;\n\n    // State transition and logic handling\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= SEARCHING;\n            counting <= 0;\n            done <= 0;\n            count <= 4'bxxxx;\n        end\n        else begin\n            case (state)\n                SEARCHING: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    if (shift_reg == 4'b1101) begin\n                        state <= CAPTURE_DELAY;\n                        captured_bits <= 0;\n                    end\n                end\n\n                CAPTURE_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    captured_bits <= captured_bits + 1;\n                    if (captured_bits == 4) begin\n                        delay <= shift_reg;\n                        state <= COUNTING;\n                        counting <= 1;\n                        timer <= (delay + 1) * 1000 - 1;\n                        count <= delay;\n                    end\n                end\n\n                COUNTING: begin\n                    if (timer > 0) begin\n                        timer <= timer - 1;\n                        if (timer % 1000 == 0) begin\n                            count <= count - 1;\n                        end\n                    end\n                    else begin\n                        state <= DONE_WAIT;\n                        counting <= 0;\n                        done <= 1;\n                    end\n                end\n\n                DONE_WAIT: begin\n                    if (ack) begin\n                        done <= 0;\n                        state <= SEARCHING;\n                    end\n                end\n\n                default: state <= SEARCHING;\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definition\n    typedef enum int {\n        IDLE,\n        DETECT_PATTERN,\n        SHIFT_DELAY,\n        COUNT,\n        NOTIFY\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Registers for shifting in data and maintaining count\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] timer; // Enough to count delay * 1000\n\n    // Pattern detection\n    localparam PATTERN = 4'b1101;\n\n    // Combinational logic for next state and outputs\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                counting = 1'b0;\n                done = 1'b0;\n                if (shift_reg == PATTERN) begin\n                    next_state = SHIFT_DELAY;\n                end else begin\n                    next_state = DETECT_PATTERN;\n                end\n            end\n            DETECT_PATTERN: begin\n                counting = 1'b0;\n                done = 1'b0;\n                if (shift_reg == PATTERN) begin\n                    next_state = SHIFT_DELAY;\n                end else begin\n                    next_state = DETECT_PATTERN;\n                end\n            end\n            SHIFT_DELAY: begin\n                counting = 1'b0;\n                done = 1'b0;\n                if (timer == 4) begin // 4 bits received\n                    delay = shift_reg;\n                    next_state = COUNT;\n                end else begin\n                    next_state = SHIFT_DELAY;\n                end\n            end\n            COUNT: begin\n                counting = 1'b1;\n                done = 1'b0;\n                if (timer == (delay + 1) * 1000) begin\n                    next_state = NOTIFY;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            NOTIFY: begin\n                counting = 1'b0;\n                done = 1'b1;\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = NOTIFY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Sequential logic for state transitions and shifting\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_reg <= 0;\n            timer <= 0;\n            count <= 4'bxxxx; // don't care\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                DETECT_PATTERN: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                end\n                SHIFT_DELAY: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                    timer <= timer + 1;\n                end\n                COUNT: begin\n                    timer <= timer + 1;\n                    count <= delay - (timer / 1000);\n                end\n                NOTIFY: begin\n                    count <= 4'bxxxx; // don't care\n                end\n                default: begin\n                    timer <= 0;\n                    shift_reg <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    localparam IDLE = 0,\n               CHECK_PATTERN = 1,\n               SHIFT_DELAY = 2,\n               COUNT = 3,\n               WAIT_ACK = 4;\n\n    // Signal and state declarations\n    reg [2:0] state, next_state;\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] timer; // 4096 is enough to count upto 1000*4 cycles\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        counting = 0;\n        done = 0;\n        count = 4'bx;\n\n        case(state)\n            IDLE: begin\n                if (data == 1'b1)  // Start detecting pattern 1101\n                    next_state = CHECK_PATTERN;\n                shift_reg = 0;\n            end\n\n            CHECK_PATTERN: begin\n                shift_reg = {shift_reg[2:0], data}; // Shift in the incoming data\n                if (shift_reg == 4'b1101)\n                    next_state = SHIFT_DELAY;\n            end\n\n            SHIFT_DELAY: begin\n                delay = {delay[2:0], data}; // Shift in the delay bits\n                if (&shift_reg) // Once we've shifted in 4 bits\n                    next_state = COUNT;\n                shift_reg = shift_reg + 1'b1;\n            end\n\n            COUNT: begin\n                counting = 1;\n                count = delay; // Update the count output\n                if (timer == (delay + 1) * 1000 - 1) begin\n                    if (delay > 0)\n                        delay = delay - 1;\n                    timer = 0; // Reset timer for the next second\n                end else begin\n                    timer = timer + 1;\n                end\n\n                if (delay == 0 && timer == 1000) // Finished counting down to zero\n                    next_state = WAIT_ACK;\n            end\n\n            WAIT_ACK: begin\n                done = 1;\n                count = 0;\n                if (ack == 1'b1) // Wait for user acknowledgement\n                    next_state = IDLE;\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    localparam IDLE = 0, DETECT = 1, LOAD_DELAY = 2, COUNTING = 3, NOTIFY = 4;\n\n    // Registers for state machine and data storage\n    reg [2:0] state, next_state;\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] timer; // Enough to count up to 8000 cycles\n\n    // State Machine: State transitions and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            count <= 4'bxxxx;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    counting <= 0;\n                    done <= 0;\n                    count <= 4'bxxxx;\n                end\n                DETECT: begin\n                    if (shift_reg == 4'b1101) begin\n                        delay <= 4'b0000;\n                        counting <= 0;\n                    end\n                end\n                LOAD_DELAY: begin\n                    delay <= shift_reg;\n                    counting <= 1;\n                    timer <= (shift_reg + 1) * 1000 - 1;\n                end\n                COUNTING: begin\n                    counting <= 1;\n                    if (timer == 0) begin\n                        done <= 1;\n                        counting <= 0;\n                    end else begin\n                        timer <= timer - 1;\n                        count <= timer / 1000;\n                    end\n                end\n                NOTIFY: begin\n                    done <= 1;\n                    counting <= 0;\n                    if (ack) begin\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (data == 1) ? DETECT : IDLE;\n            DETECT: next_state = (shift_reg == 4'b1101) ? LOAD_DELAY : DETECT;\n            LOAD_DELAY: next_state = COUNTING;\n            COUNTING: next_state = (timer == 0) ? NOTIFY : COUNTING;\n            NOTIFY: next_state = (ack) ? IDLE : NOTIFY;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Shift register to capture the input pattern and delay\n    always @(posedge clk) begin\n        if (state == DETECT || state == LOAD_DELAY)\n            shift_reg <= {shift_reg[2:0], data};\n    end\n\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State definitions\n    localparam IDLE = 3'd0,\n               CHECK_START = 3'd1,\n               SHIFT_DELAY = 3'd2,\n               COUNTING = 3'd3,\n               DONE = 3'd4;\n\n    // State, shift register, and counter declaration\n    reg [2:0] state, next_state;\n    reg [3:0] shift_reg;\n    reg [3:0] delay;\n    reg [12:0] counter; // Sufficient to count up to 9000 cycles\n\n    // State machine logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            counting <= 0;\n            done <= 0;\n            count <= 4'bxxxx;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and outputs control\n    always @(*) begin\n        next_state = state; // Default is to stay in the same state\n        counting = 0;\n        done = 0;\n        count = 4'bxxxx;\n\n        case (state)\n            IDLE: begin\n                if (data)\n                    next_state = CHECK_START;\n            end\n            CHECK_START: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT_DELAY;\n                end\n            end\n            SHIFT_DELAY: begin\n                delay = shift_reg;\n                next_state = COUNTING;\n                counter = (delay + 1) * 1000;\n            end\n            COUNTING: begin\n                counting = 1;\n                count = delay;\n                if (counter > 0) begin\n                    counter = counter - 1;\n                end else begin\n                    next_state = DONE;\n                end\n                if (counter % 1000 == 0 && counter != 0) begin\n                    delay = delay - 1;\n                end\n            end\n            DONE: begin\n                done = 1;\n                count = 0;\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        end\n    end\n\n    // Shift register to capture input pattern or delay\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n        end else if (state == CHECK_START || state == SHIFT_DELAY) begin\n            shift_reg <= {shift_reg[2:0], data};\n        end\n    end\n\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State declaration\n    parameter IDLE = 0, DETECT = 1, LOAD_DELAY = 2, COUNT = 3, DONE = 4;\n    reg [2:0] state, next_state;\n\n    // Registers to hold data and count values\n    reg [3:0] delay;\n    reg [3:0] bit_count;\n    reg [12:0] timer; // Large enough to hold up to 10000 cycles (9999 max)\n\n    // Shift register to detect pattern\n    reg [3:0] shift_reg;\n\n    // State machine logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'b0000;\n            bit_count <= 0;\n            delay <= 0;\n            timer <= 0;\n            counting <= 0;\n            done <= 0;\n            count <= 4'bxxxx;\n        end else begin\n            case (state)\n                IDLE: begin\n                    counting <= 0;\n                    done <= 0;\n                    count <= 4'bxxxx;\n                    if (shift_reg == 4'b1101) begin\n                        state <= LOAD_DELAY;\n                        bit_count <= 0;\n                        delay <= 0;\n                    end else begin\n                        shift_reg <= {shift_reg[2:0], data};\n                    end\n                end\n                LOAD_DELAY: begin\n                    if (bit_count < 4) begin\n                        delay <= {delay[2:0], data};\n                        bit_count <= bit_count + 1;\n                    end else begin\n                        state <= COUNT;\n                        timer <= (delay + 1) * 1000 - 1;\n                        counting <= 1;\n                        count <= delay;\n                    end\n                end\n                COUNT: begin\n                    if (timer > 0) begin\n                        timer <= timer - 1;\n                        if (timer % 1000 == 0) begin\n                            count <= count - 1;\n                        end\n                    end else begin\n                        state <= DONE;\n                        done <= 1;\n                        counting <= 0;\n                    end\n                end\n                DONE: begin\n                    if (ack) state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (shift_reg == 4'b1101) ? LOAD_DELAY : IDLE;\n            LOAD_DELAY: next_state = (bit_count == 4) ? COUNT : LOAD_DELAY;\n            COUNT: next_state = (timer == 0) ? DONE : COUNT;\n            DONE: next_state = ack ? IDLE : DONE;\n            default: next_state = IDLE;\n        end\n    end\n\n    // Output assignment\n    always @(posedge clk) begin\n        if (state == COUNT) begin\n            count <= delay - (timer / 1000);\n        end\n    end\n\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n    // Define states\n    localparam  IDLE = 3'b000,\n                CHECK_PATTERN = 3'b001,\n                LOAD_DELAY = 3'b010,\n                COUNTING = 3'b011,\n                WAIT_ACK = 3'b100;\n\n    // State, delay, and counter variables\n    reg [2:0] state, next_state;\n    reg [3:0] delay;\n    reg [3:0] shift_reg;\n    reg [12:0] timer; // large enough to count up to 9000 cycles\n\n    // State machine logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            count <= 4'bxxxx;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                counting = 0;\n                done = 0;\n                count = 4'bxxxx;\n\n                if (data == 1'b1)\n                    next_state = CHECK_PATTERN;\n            end\n            CHECK_PATTERN: begin\n                if (shift_reg == 4'b1101)\n                    next_state = LOAD_DELAY;\n            end\n            LOAD_DELAY: begin\n                delay = shift_reg;\n                next_state = COUNTING;\n            end\n            COUNTING: begin\n                counting = 1;\n                if (timer == 0) begin\n                    if (delay == 0) begin\n                        next_state = WAIT_ACK;\n                        done = 1;\n                        counting = 0;\n                    end else begin\n                        delay = delay - 1;\n                        timer = 1000;\n                    end\n                end\n                count = delay;\n            end\n            WAIT_ACK: begin\n                if (ack) begin\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Shift register and timer control\n    always @(posedge clk) begin\n        if (state == CHECK_PATTERN || state == LOAD_DELAY) begin\n            shift_reg <= {shift_reg[2:0], data};\n        end\n\n        // Timer management\n        if (state == COUNTING) begin\n            if (timer > 0) \n                timer <= timer - 1;\n        end else if (state == LOAD_DELAY) begin\n            timer <= (delay + 1) * 1000;\n        end\n    end\n\n    // Initialize shift register and delay\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_reg <= 4'b0000;\n            delay <= 4'b0000;\n        end\n    end\nendmodule\n", "module top_module(\n    input wire clk,\n    input wire reset,\n    input wire data,\n    output reg [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack\n);\n\n    // State declaration\n    typedef enum int {IDLE, CHECK_PATTERN, CAPTURE_DELAY, COUNTING, NOTIFY} state_t;\n    state_t current_state, next_state;\n\n    // Registers to hold internal values\n    reg [3:0] pattern_shift_reg;\n    reg [3:0] delay;\n    reg [12:0] counter;  // To count up to 9999 (needs at least 13 bits)\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            pattern_shift_reg <= 4'b0;\n            delay <= 4'b0;\n            counter <= 13'b0;\n            counting <= 0;\n            done <= 0;\n            count <= 4'b0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                IDLE: begin\n                    pattern_shift_reg <= {pattern_shift_reg[2:0], data};\n                end\n                CHECK_PATTERN: begin\n                    if (pattern_shift_reg == 4'b1101) begin\n                        delay <= {delay[2:0], data};\n                    end\n                end\n                CAPTURE_DELAY: begin\n                    delay <= {delay[2:0], data};\n                end\n                COUNTING: begin\n                    if (counter > 0) begin\n                        counter <= counter - 1;\n                    end\n                    count <= counter[12:9]; // Represents remaining time\n                end\n                NOTIFY: begin\n                    if (ack) begin\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (pattern_shift_reg == 4'b1101) begin\n                    next_state = CHECK_PATTERN;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            CHECK_PATTERN: begin\n                if (pattern_shift_reg == 4'b1101 && delay == 4'b0) begin\n                    next_state = CAPTURE_DELAY;\n                end else begin\n                    next_state = COUNTING;\n                end\n            end\n            CAPTURE_DELAY: begin\n                if (delay[3:0] != 4'b0) begin\n                    next_state = COUNTING;\n                end else begin\n                    next_state = CAPTURE_DELAY;\n                end\n            end\n            COUNTING: begin\n                if (counter == 0) begin\n                    next_state = NOTIFY;\n                end else begin\n                    next_state = COUNTING;\n                end\n            end\n            NOTIFY: begin\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = NOTIFY;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Counting and outputs\n    always @(posedge clk) begin\n        case (current_state)\n            COUNTING: begin\n                counting <= 1;\n                if (counter == 0) begin\n                    done <= 1;\n                    counting <= 0;\n                    count <= 4'b0;\n                end\n            end\n            NOTIFY: begin\n                counting <= 0;\n                count <= 4'b0;\n            end\n            default: begin\n                counting <= 0;\n                count <= 4'b0;\n                if (current_state != NOTIFY) done <= 0;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "ece241_2013_q4", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n    // State encoding\n    localparam LOW = 2'b00,\n               MID = 2'b01,\n               HIGH = 2'b10;\n\n    // State and previous state variables\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge reset) begin\n        if (reset)\n            state <= LOW;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on sensor inputs\n    always @(*) begin\n        case(s)\n            3'b111: next_state = HIGH;  // Above s[3]\n            3'b011: next_state = HIGH;  // Between s[3] and s[2]\n            3'b001: next_state = MID;   // Between s[2] and s[1]\n            3'b000: next_state = LOW;   // Below s[1]\n            default: next_state = LOW;  // Default to LOW to handle unused states\n        end\n    end\n\n    // Output logic based on current state and previous state\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset outputs\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n        end else begin\n            case (state)\n                HIGH: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                MID: begin\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (state == MID && next_state == HIGH) ? 1 : 0;\n                end\n                LOW: begin\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (state == LOW && next_state == MID) ? 1 : 0;\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // States for FSM\n    reg [2:0] current_state, next_state;\n\n    // State encoding\n    localparam  ABOVE_S3 = 3'b111,\n                BETWEEN_S3_S2 = 3'b110,\n                BETWEEN_S2_S1 = 3'b100,\n                BELOW_S1 = 3'b000;\n\n    // Previous level storage to determine flow direction\n    reg [2:0] previous_level;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= BELOW_S1; // Reset to equivalent of water being low\n            previous_level <= 3'b000;  // No sensors asserted\n        end\n        else begin\n            current_state <= next_state;\n            previous_level <= s;       // Store current sensor state as previous level\n        end\n    end\n\n    // Next state logic based on sensor input\n    always @(*) begin\n        case (s)\n            3'b111: next_state = ABOVE_S3;\n            3'b110: next_state = BETWEEN_S3_S2;\n            3'b100: next_state = BETWEEN_S2_S1;\n            3'b000: next_state = BELOW_S1;\n            default: next_state = current_state; // Hold state if sensor inputs are invalid/ambiguous\n        end\n    end\n\n    // Output logic based on current state and previous level\n    always @(*) begin\n        // Default output condition\n        fr3 = 0;\n        fr2 = 0;\n        fr1 = 0;\n        dfr = 0;\n\n        case (current_state)\n            ABOVE_S3: begin\n                // Outputs are already set to 0 in default\n            end\n            BETWEEN_S3_S2: begin\n                fr1 = 1;\n                dfr = (previous_level < s) ? 1 : 0; // Increase flow if level is rising\n            end\n            BETWEEN_S2_S1: begin\n                fr1 = 1;\n                fr2 = 1;\n                dfr = (previous_level < s) ? 1 : 0; // Increase flow if level is rising\n            end\n            BELOW_S1: begin\n                fr1 = 1;\n                fr2 = 1;\n                fr3 = 1;\n                dfr = 1; // Maximum flow\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    localparam  LOW_LEVEL = 3'b000,\n                BETWEEN_LOW_MID = 3'b001,\n                BETWEEN_MID_HIGH = 3'b010,\n                HIGH_LEVEL = 3'b011;\n\n    reg [2:0] state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= LOW_LEVEL;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case(state)\n            LOW_LEVEL: begin\n                if(s[1] && !s[2] && !s[3]) next_state = BETWEEN_LOW_MID;\n                else if(s[1] && s[2] && !s[3]) next_state = BETWEEN_MID_HIGH;\n                else if(s[1] && s[2] && s[3]) next_state = HIGH_LEVEL;\n                else next_state = LOW_LEVEL;\n            end\n            BETWEEN_LOW_MID: begin\n                if(!s[1]) next_state = LOW_LEVEL;\n                else if(s[2] && !s[3]) next_state = BETWEEN_MID_HIGH;\n                else if(s[1] && s[2] && s[3]) next_state = HIGH_LEVEL;\n                else next_state = BETWEEN_LOW_MID;\n            end\n            BETWEEN_MID_HIGH: begin\n                if(!s[2]) next_state = BETWEEN_LOW_MID;\n                else if(!s[1]) next_state = LOW_LEVEL;\n                else if(s[1] && s[2] && s[3]) next_state = HIGH_LEVEL;\n                else next_state = BETWEEN_MID_HIGH;\n            end\n            HIGH_LEVEL: begin\n                if(!s[3]) next_state = BETWEEN_MID_HIGH;\n                else if(!s[2]) next_state = BETWEEN_LOW_MID;\n                else if(!s[1]) next_state = LOW_LEVEL;\n                else next_state = HIGH_LEVEL;\n            end\n            default: next_state = LOW_LEVEL;\n        endcase\n    end\n\n    // Output Logic based on Current State\n    always @(state) begin\n        case(state)\n            LOW_LEVEL: begin\n                fr3 = 1;\n                fr2 = 1;\n                fr1 = 1;\n                dfr = 1;  // Increase flow rate due to water level being low\n            end\n            BETWEEN_LOW_MID: begin\n                fr3 = 0;\n                fr2 = 1;\n                fr1 = 1;\n                dfr = 0;\n            end\n            BETWEEN_MID_HIGH: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 1;\n                dfr = 1; // Increase flow if rising from BETWEEN_LOW_MID\n            end\n            HIGH_LEVEL: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 0;\n                dfr = 0; // No need to increase flow rate, high water level\n            end\n            default: begin\n                fr3 = 1;\n                fr2 = 1;\n                fr1 = 1;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n    // State encoding\n    localparam [2:0] \n        LOW = 3'b000,\n        BTW_S1_S2 = 3'b001,\n        BTW_S2_S3 = 3'b010,\n        ABOVE_S3 = 3'b011;\n        \n    reg [2:0] current_state, next_state;\n    reg last_below_s1;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= LOW;\n            last_below_s1 <= 1'b1; // Reset as if water was low for a long time\n        end else begin\n            current_state <= next_state;\n            if (current_state == LOW) last_below_s1 <= 1'b1;\n            else if (current_state == ABOVE_S3) last_below_s1 <= 1'b0;\n            else last_below_s1 <= last_below_s1; // Keep the previous value unless at extremes\n        end\n    end\n\n    // Next state logic based on sensor inputs\n    always @(*) begin\n        case (s)\n            3'b111: next_state = ABOVE_S3;\n            3'b011: next_state = BTW_S2_S3;\n            3'b001: next_state = BTW_S1_S2;\n            3'b000: next_state = LOW;\n            default: next_state = current_state; // Remain in the current state for undefined sensor states\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(current_state or last_below_s1) begin\n        case (current_state)\n            LOW: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = 1'b0;\n            end\n            BTW_S1_S2: begin\n                fr3 = 1'b0;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = last_below_s1 ? 1'b1 : 1'b0;\n            end\n            BTW_S2_S3: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b1;\n                dfr = last_below_s1 ? 1'b1 : 1'b0;\n            end\n            ABOVE_S3: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n            default: begin\n                fr3 = 1'b0;\n                fr2 = 1'b0;\n                fr1 = 1'b0;\n                dfr = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    localparam [2:0] \n        LEVEL_BELOW_S1 = 3'b001,\n        LEVEL_BETWEEN_S1_S2 = 3'b010,\n        LEVEL_BETWEEN_S2_S3 = 3'b011,\n        LEVEL_ABOVE_S3 = 3'b100;\n\n    // Registers to store the current and previous states\n    reg [2:0] current_state, next_state;\n\n    // Combinational logic to determine next state based on sensor input\n    always @(*) begin\n        case (s)\n            3'b111: next_state = LEVEL_ABOVE_S3;\n            3'b011: next_state = LEVEL_BETWEEN_S2_S3;\n            3'b001: next_state = LEVEL_BETWEEN_S1_S2;\n            3'b000: next_state = LEVEL_BELOW_S1;\n            default: next_state = LEVEL_BELOW_S1; // Default case to handle unused states\n        endcase\n    end\n\n    // Sequential logic to update the current state on the rising edge of the clock\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= LEVEL_BELOW_S1;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for output control based on the current state\n    always @(*) begin\n        // Default outputs\n        fr3 = 0;\n        fr2 = 0;\n        fr1 = 0;\n        dfr = 0;\n\n        case (current_state)\n            LEVEL_BELOW_S1: begin\n                fr3 = 1;\n                fr2 = 1;\n                fr1 = 1;\n                dfr = 0;\n            end\n            LEVEL_BETWEEN_S1_S2: begin\n                fr3 = 0;\n                fr2 = 1;\n                fr1 = 1;\n                dfr = (next_state != current_state && next_state == LEVEL_BETWEEN_S2_S3);\n            end\n            LEVEL_BETWEEN_S2_S3: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 1;\n                dfr = (next_state != current_state && next_state == LEVEL_ABOVE_S3);\n            end\n            LEVEL_ABOVE_S3: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 0;\n                dfr = 0;\n            end\n            default: begin\n                fr3 = 0;\n                fr2 = 0;\n                fr1 = 0;\n                dfr = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State encoding\n    localparam [2:0] \n        STATE_ABOVE_S3 = 3'b111,\n        STATE_BETWEEN_S3_S2 = 3'b110,\n        STATE_BETWEEN_S2_S1 = 3'b100,\n        STATE_BELOW_S1 = 3'b000;\n\n    // Registered state and previous state storage\n    reg [2:0] current_state, previous_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset to a state as if below the lowest sensor for a long time\n            current_state <= STATE_BELOW_S1;\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n        end else begin\n            // Store current state to previous state\n            previous_state <= current_state;\n\n            // Determine the new state based on sensor input\n            case (s)\n                3'b111: current_state <= STATE_ABOVE_S3;\n                3'b110: current_state <= STATE_BETWEEN_S3_S2;\n                3'b100: current_state <= STATE_BETWEEN_S2_S1;\n                3'b000: current_state <= STATE_BELOW_S1;\n                default: current_state <= STATE_BELOW_S1; // Default case to handle unused states\n            endcase\n\n            // Output logic based on the current state\n            case (current_state)\n                STATE_ABOVE_S3: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                STATE_BETWEEN_S3_S2: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (previous_state < current_state) ? 1 : 0; // Open dfr if water level is rising\n                end\n                STATE_BETWEEN_S2_S1: begin\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (previous_state < current_state) ? 1 : 0; // Open dfr if water level is rising\n                end\n                STATE_BELOW_S1: begin\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1; // Always maximum flow rate below s[1]\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // Define states\n    typedef enum {\n        STATE_LOW, // Below s[1]\n        STATE_BETWEEN_LOW_MID, // Between s[1] and s[2]\n        STATE_BETWEEN_MID_HIGH, // Between s[2] and s[3]\n        STATE_HIGH // Above s[3]\n    } state_t;\n\n    // State and previous state registers\n    reg [1:0] current_state, next_state;\n    reg [1:0] previous_state;\n\n    // State machine sequential logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_LOW;\n            previous_state <= STATE_LOW;\n        end else begin\n            current_state <= next_state;\n            previous_state <= current_state;\n        end\n    end\n\n    // State machine next state logic\n    always @* begin\n        case (s)\n            3'b111: next_state = STATE_HIGH;\n            3'b011: next_state = STATE_BETWEEN_MID_HIGH;\n            3'b001: next_state = STATE_BETWEEN_LOW_MID;\n            3'b000: next_state = STATE_LOW;\n            default: next_state = current_state; // Maintain current state in any other case\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        if (reset) begin\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0;\n        end else begin\n            case (current_state)\n                STATE_HIGH: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                STATE_BETWEEN_MID_HIGH: begin\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (previous_state < current_state);\n                end\n                STATE_BETWEEN_LOW_MID: begin\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (previous_state < current_state);\n                end\n                STATE_LOW: begin\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    reg [2:0] last_state;\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset state: no sensors are asserted, all flow controls are open\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 0; // Supplemental flow valve is closed on reset\n            last_state <= 3'b000;\n        end else begin\n            case (s)\n                3'b111: begin // Water level is above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0; // No flow needed, all valves closed\n                end\n                3'b011: begin // Water level is between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (last_state < 3'b011) ? 1 : 0; // Open supplemental if rising\n                end\n                3'b001: begin // Water level is between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (last_state < 3'b001) ? 1 : 0; // Open supplemental if rising\n                end\n                3'b000: begin // Water level is below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1; // Max flow, all valves open\n                end\n                default: begin\n                    // Invalid state, should not happen\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n            endcase\n            last_state <= s; // Update last known state\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    // State declaration\n    typedef enum logic [2:0] {\n        STATE_LOW,            // Below s[1]\n        STATE_BETWEEN_LOW_MID, // Between s[1] and s[2]\n        STATE_BETWEEN_MID_HIGH, // Between s[2] and s[3]\n        STATE_HIGH            // Above s[3]\n    } state_t;\n\n    // State registers\n    state_t current_state, next_state;\n\n    // Previous water level (to determine increasing or decreasing)\n    logic prev_low;  // True if previous was below s[1]\n\n    // State transition and output logic\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= STATE_LOW;\n            prev_low <= 1'b1; // Assuming water level has been low for a long time\n        end else begin\n            current_state <= next_state;\n            prev_low <= (current_state == STATE_LOW);\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        case (current_state)\n            STATE_LOW: begin\n                if (s[1]) next_state = STATE_BETWEEN_LOW_MID;\n                else next_state = STATE_LOW;\n            end\n            STATE_BETWEEN_LOW_MID: begin\n                if (s[2]) next_state = STATE_BETWEEN_MID_HIGH;\n                else if (!s[1]) next_state = STATE_LOW;\n                else next_state = STATE_BETWEEN_LOW_MID;\n            end\n            STATE_BETWEEN_MID_HIGH: begin\n                if (s[3]) next_state = STATE_HIGH;\n                else if (!s[2]) next_state = STATE_BETWEEN_LOW_MID;\n                else next_state = STATE_BETWEEN_MID_HIGH;\n            end\n            STATE_HIGH: begin\n                if (!s[3]) next_state = STATE_BETWEEN_MID_HIGH;\n                else next_state = STATE_HIGH;\n            end\n            default: next_state = STATE_LOW;\n        endcase\n    end\n\n    // Output logic based on the state\n    always_comb begin\n        // Default values\n        fr3 = 1'b0;\n        fr2 = 1'b0;\n        fr1 = 1'b0;\n        dfr = 1'b0;\n\n        case (current_state)\n            STATE_LOW: begin\n                fr3 = 1'b1;\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n            end\n            STATE_BETWEEN_LOW_MID: begin\n                fr2 = 1'b1;\n                fr1 = 1'b1;\n                dfr = prev_low; // Increase flow rate if previously lower\n            end\n            STATE_BETWEEN_MID_HIGH: begin\n                fr1 = 1'b1;\n            end\n            STATE_HIGH: begin\n                // All flow rates off\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input [3:1] s,\n    output reg fr3,\n    output reg fr2,\n    output reg fr1,\n    output reg dfr\n);\n\n    reg [2:0] last_s;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset the state as if the water level has been low for a long time\n            fr3 <= 1;\n            fr2 <= 1;\n            fr1 <= 1;\n            dfr <= 1;\n            last_s <= 3'b000;\n        end\n        else begin\n            // Update the last known sensor state\n            last_s <= s;\n\n            // Determine the flow rate based on the current sensor readings\n            case(s)\n                3'b111: begin // Water level above s[3]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 0;\n                    dfr <= 0;\n                end\n                3'b011: begin // Water level between s[3] and s[2]\n                    fr3 <= 0;\n                    fr2 <= 0;\n                    fr1 <= 1;\n                    dfr <= (last_s < 3'b011) ? 1 : 0;\n                end\n                3'b001: begin // Water level between s[2] and s[1]\n                    fr3 <= 0;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= (last_s < 3'b001) ? 1 : 0;\n                end\n                3'b000: begin // Water level below s[1]\n                    fr3 <= 1;\n                    fr2 <= 1;\n                    fr1 <= 1;\n                    dfr <= 1;\n                end\n                default: begin\n                    // In case of any undefined sensor states, maintain the previous state\n                    fr3 <= fr3;\n                    fr2 <= fr2;\n                    fr1 <= fr1;\n                    dfr <= dfr;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"]}
{"task_id": "fsm_serial", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State definitions\n    parameter IDLE = 0,\n              START = 1,\n              RECEIVE = 2,\n              STOP = 3,\n              ERROR = 4;\n\n    // State variable\n    reg [2:0] state, next_state;\n\n    // Bit counter\n    reg [3:0] bit_count;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    bit_count <= 0;\n                end\n                RECEIVE: begin\n                    if (bit_count == 8) begin\n                        bit_count <= 0;\n                    end else begin\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                STOP: begin\n                    done <= 1;\n                end\n                ERROR: begin\n                    done <= 0;\n                end\n                default: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0)  // start bit detected\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                if (in == 0)\n                    next_state = RECEIVE;\n                else\n                    next_state = ERROR;\n            end\n            RECEIVE: begin\n                if (bit_count == 7)  // last data bit\n                    next_state = STOP;\n                else\n                    next_state = RECEIVE;\n            end\n            STOP: begin\n                if (in == 1)\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                if (in == 1)  // waiting for a valid stop bit\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n    // State definition\n    parameter IDLE = 0,\n              START = 1,\n              RECEIVE = 2,\n              STOP = 3,\n              ERROR = 4;\n\n    // State register\n    reg [2:0] state, next_state;\n\n    // Data bit counter\n    reg [3:0] bit_count;\n\n    // FSM state transitions and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVE) begin\n                if (bit_count == 8) \n                    bit_count <= 0;\n                else \n                    bit_count <= bit_count + 1;\n            end else begin\n                bit_count <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                done = 0;\n                if (in == 0) // detect start bit\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n\n            START: begin\n                if (in == 0) // confirm start bit\n                    next_state = RECEIVE;\n                else\n                    next_state = IDLE;\n            end\n\n            RECEIVE: begin\n                if (bit_count == 7) // last data bit received\n                    next_state = STOP;\n                else\n                    next_state = RECEIVE;\n            end\n\n            STOP: begin\n                if (in == 1) begin\n                    done = 1; // correct stop bit\n                    next_state = IDLE;\n                end else begin\n                    done = 0;\n                    next_state = ERROR; // incorrect stop bit\n                end\n            end\n\n            ERROR: begin\n                done = 0;\n                if (in == 1)\n                    next_state = IDLE; // wait until a stop bit to recover\n                else\n                    next_state = ERROR;\n            end\n\n            default: begin\n                next_state = IDLE;\n                done = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State declaration\n    localparam IDLE = 3'd0,\n               START = 3'd1,\n               RECEIVE = 3'd2,\n               STOP = 3'd3,\n               ERROR = 3'd4;\n\n    // Variables\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0) // Detecting start bit\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = RECEIVE;\n            end\n            RECEIVE: begin\n                if (bit_count == 8) // Received 8 bits\n                    next_state = STOP;\n                else\n                    next_state = RECEIVE;\n            end\n            STOP: begin\n                if (in == 1) // Stop bit detected\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                if (in == 1) // Waiting for a valid stop bit\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and bit counting logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            case (state)\n                RECEIVE: begin\n                    bit_count <= bit_count + 1;\n                end\n                STOP: begin\n                    if (in == 1) // Correct stop bit\n                        done <= 1;\n                    else\n                        done <= 0;\n                    bit_count <= 0;\n                end\n                IDLE, START, ERROR: begin\n                    bit_count <= 0;\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // Define FSM states\n    localparam IDLE = 3'd0,\n               START = 3'd1,\n               RECEIVE = 3'd2,\n               STOP = 3'd3,\n               ERROR = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;  // To count the 8 data bits\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 4'd0;\n            done <= 1'b0;\n        end \n        else begin\n            state <= next_state;\n            case(state)\n                START: begin\n                    if (bit_count < 8) begin\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                RECEIVE: begin\n                    if (bit_count < 8) begin\n                        bit_count <= bit_count + 1;\n                    end\n                    else begin\n                        bit_count <= 4'd0;\n                    end\n                end\n                default: bit_count <= 4'd0;\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            IDLE: next_state = in ? IDLE : START; // Wait for start bit\n            START: next_state = (bit_count < 8) ? START : RECEIVE;\n            RECEIVE: begin\n                if (bit_count < 8) begin\n                    next_state = RECEIVE;\n                end\n                else if (in == 1'b1) begin\n                    next_state = IDLE;\n                end\n                else begin\n                    next_state = ERROR;\n                end\n            end\n            ERROR: next_state = in ? IDLE : ERROR; // Wait for a stop bit (1) to recover\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            IDLE: done = 1'b0;\n            START: done = 1'b0;\n            RECEIVE: done = (bit_count == 8 && in == 1'b1) ? 1'b1 : 1'b0;\n            ERROR: done = 1'b0;\n            default: done = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // Define state codes\n    localparam [3:0] IDLE       = 4'b0000,\n                     START_BIT  = 4'b0001,\n                     DATA_BITS  = 4'b0010,\n                     STOP_BIT   = 4'b0011,\n                     ERROR      = 4'b0100;\n\n    // State, data bit counter and data register\n    reg [3:0] state, next_state;\n    reg [3:0] bit_count;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                end\n                DATA_BITS: begin\n                    if (bit_count == 8) begin\n                        bit_count <= 0; // Reset bit counter after 8 bits\n                    end else begin\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                STOP_BIT: begin\n                    done <= 1;\n                end\n                ERROR: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0)\n                    next_state = START_BIT; // Detected start bit\n                else\n                    next_state = IDLE;\n            end\n            START_BIT: begin\n                next_state = DATA_BITS; // Move to data bits reception\n            end\n            DATA_BITS: begin\n                if (bit_count == 7)\n                    next_state = STOP_BIT; // All data bits received, expect stop bit\n                else\n                    next_state = DATA_BITS; // Continue reading data bits\n            end\n            STOP_BIT: begin\n                if (in == 1)\n                    next_state = IDLE; // Stop bit correct, prepare for next byte\n                else\n                    next_state = ERROR; // Stop bit error, handle error state\n            end\n            ERROR: begin\n                if (in == 1)\n                    next_state = IDLE; // Wait until a stop bit (1) is found\n                else\n                    next_state = ERROR; // Continue in error state\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State declaration using parameters for readability\n    parameter IDLE = 0,\n              START = 1,\n              RECEIVE = 2,\n              STOP = 3,\n              ERROR = 4;\n\n    // Current state and next state variables\n    reg [2:0] current_state, next_state;\n    // Counter for the 8 data bits\n    reg [3:0] bit_count;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state and output combinational logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                done = 0;\n                if (in == 0)  // detecting start bit\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                done = 0;\n                if (in == 0) begin  // confirm start bit\n                    next_state = RECEIVE;\n                    bit_count = 0;\n                end else\n                    next_state = ERROR; // not a valid start, should not happen\n            end\n            RECEIVE: begin\n                done = 0;\n                if (bit_count < 8) begin\n                    bit_count = bit_count + 1;  // count the received bits\n                    next_state = RECEIVE;\n                end else\n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1) begin  // check stop bit\n                    done = 1;\n                    next_state = IDLE;\n                end else\n                    next_state = ERROR;  // stop bit error, wait for a correct stop bit\n            end\n            ERROR: begin\n                done = 0;\n                if (in == 1)  // wait until we find stop bit\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: begin\n                next_state = IDLE;\n                done = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 0,\n               START_BIT = 1,\n               RECEIVE_DATA = 2,\n               STOP_BIT = 3,\n               ERROR = 4;\n\n    // FSM state register\n    reg [2:0] state, next_state;\n\n    // Data bit counter\n    reg [3:0] bit_counter;\n\n    // FSM logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_counter <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVE_DATA) begin\n                bit_counter <= bit_counter + 1;\n            end else if (state == IDLE || state == STOP_BIT || state == ERROR) begin\n                bit_counter <= 0;\n            end\n            if (state == STOP_BIT && next_state == IDLE) begin\n                done <= 1;\n            end else begin\n                done <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0)                            // Start bit detected\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            end\n            \n            START_BIT: begin\n                if (in == 0)                            // Confirming start bit\n                    next_state = RECEIVE_DATA;\n                else\n                    next_state = IDLE;                  // False start, go back to IDLE\n            end\n\n            RECEIVE_DATA: begin\n                if (bit_counter < 8)                     // Receive 8 data bits\n                    next_state = RECEIVE_DATA;\n                else\n                    next_state = STOP_BIT;\n            end\n\n            STOP_BIT: begin\n                if (in == 1)                             // Stop bit received\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;                  // Error, wrong stop bit\n            end\n\n            ERROR: begin\n                if (in == 1)                             // Looking for stop bit to recover\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;                  // Stay in error state until a stop bit is found\n            end\n\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State Declaration\n    typedef enum reg [3:0] {\n        IDLE = 4'b0000,\n        START = 4'b0001,\n        BIT0 = 4'b0010,\n        BIT1 = 4'b0011,\n        BIT2 = 4'b0100,\n        BIT3 = 4'b0101,\n        BIT4 = 4'b0110,\n        BIT5 = 4'b0111,\n        BIT6 = 4'b1000,\n        BIT7 = 4'b1001,\n        STOP = 4'b1010,\n        ERROR = 4'b1011\n    } state_t;\n\n    // Current and Next State Variables\n    reg [3:0] current_state, next_state;\n    reg [3:0] bit_count;\n\n    // Sequential block for state updating\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational block for next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                done = 0;\n                if (in == 0)  // Check for start bit\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                done = 0;\n                if (in == 0)  // Remain in start if still 0\n                    next_state = START;\n                else  // Move to first bit when in goes high\n                    next_state = BIT0;\n            end\n            BIT0, BIT1, BIT2, BIT3, BIT4, BIT5, BIT6, BIT7: begin\n                done = 0;\n                next_state = current_state + 1;  // Move to next bit state\n            end\n            STOP: begin\n                if (in == 1) begin\n                    done = 1;  // Successfully received the full byte\n                    next_state = IDLE;\n                end else begin\n                    done = 0;\n                    next_state = ERROR;  // Error if stop bit not detected\n                end\n            end\n            ERROR: begin\n                done = 0;\n                if (in == 1)  // Wait in ERROR state until a stop bit (1) is found\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: begin\n                done = 0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE = 0,\n               START_BIT = 1,\n               RECEIVE_BITS = 2,\n               STOP_BIT = 3,\n               ERROR = 4;\n\n    // State, bit counter and data register\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state == RECEIVE_BITS) begin\n                bit_count <= bit_count + 1;\n            end else if (state == IDLE || state == STOP_BIT || state == ERROR) begin\n                bit_count <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                done = 0;\n                if (in == 0) // start bit detected\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n            end\n            START_BIT: begin\n                done = 0;\n                next_state = RECEIVE_BITS; // Move to receiving data bits\n            end\n            RECEIVE_BITS: begin\n                done = 0;\n                if (bit_count == 8) // Received 8 bits\n                    next_state = STOP_BIT;\n                else\n                    next_state = RECEIVE_BITS;\n            end\n            STOP_BIT: begin\n                if (in == 1) begin\n                    done = 1; // Correct stop bit\n                    next_state = IDLE;\n                end else begin\n                    done = 0;\n                    next_state = ERROR; // Expected stop bit but not received\n                end\n            end\n            ERROR: begin\n                done = 0;\n                if (in == 1) // Looking for a stop bit to recover\n                    next_state = IDLE;\n                else\n                    next_state = ERROR;\n            end\n            default: begin\n                done = 0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg done\n);\n    // State Encoding\n    localparam IDLE = 0,\n               START_BIT = 1,\n               RECEIVE_DATA = 2,\n               STOP_BIT = 3,\n               CHECK_STOP_BIT = 4;\n\n    // State and data bit counter variables\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n\n    // FSM state transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n\n            case (state)\n                IDLE: done <= 0; // Clear done in IDLE state\n\n                CHECK_STOP_BIT:\n                    if (in == 1'b1) begin\n                        done <= 1;\n                    end\n                default: done <= 0;\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE:\n                if (in == 0) // Start bit detected\n                    next_state = START_BIT;\n                else\n                    next_state = IDLE;\n\n            START_BIT:\n                next_state = RECEIVE_DATA; // Move to receive data bits\n\n            RECEIVE_DATA:\n                if (bit_count == 8) // All data bits received\n                    next_state = STOP_BIT;\n                else\n                    next_state = RECEIVE_DATA;\n\n            STOP_BIT:\n                next_state = CHECK_STOP_BIT;\n\n            CHECK_STOP_BIT:\n                if (in == 1'b1) // Valid stop bit\n                    next_state = IDLE;\n                else // Invalid stop bit, stay and wait for a valid one\n                    next_state = STOP_BIT;\n\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\n    // Bit counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            bit_count <= 0;\n        end else if (state == RECEIVE_DATA) begin\n            if (bit_count < 8)\n                bit_count <= bit_count + 1;\n        end else if (state == STOP_BIT) begin\n            bit_count <= 0; // Reset bit count after stop bit phase\n        end\n    end\nendmodule\n"]}
{"task_id": "fsm_serialdata", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE = 0,\n               START_BIT = 1,\n               RECEIVE_BITS = 2,\n               STOP_BIT = 3,\n               ERROR = 4;\n\n    // State variable\n    reg [2:0] state, next_state;\n    reg [7:0] data_buffer;\n    reg [3:0] bit_count;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        case (state)\n            IDLE: begin\n                next_state = (in == 0) ? START_BIT : IDLE;\n            end\n\n            START_BIT: begin\n                next_state = (in == 0) ? RECEIVE_BITS : IDLE;\n            end\n\n            RECEIVE_BITS: begin\n                if (bit_count == 8) begin\n                    next_state = (in == 1) ? STOP_BIT : ERROR;\n                end else begin\n                    next_state = RECEIVE_BITS;\n                end\n            end\n\n            STOP_BIT: begin\n                next_state = (in == 1) ? IDLE : ERROR;\n            end\n\n            ERROR: begin\n                next_state = (in == 1) ? IDLE : ERROR;\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            out_byte <= 0;\n            done <= 0;\n            data_buffer <= 0;\n            bit_count <= 0;\n        end else begin\n            case(state)\n                START_BIT: begin\n                    // Initialize everything when seeing start bit\n                    data_buffer <= 0;\n                    bit_count <= 0;\n                    done <= 0;\n                end\n\n                RECEIVE_BITS: begin\n                    data_buffer <= (data_buffer >> 1) | (in << 7);\n                    bit_count <= bit_count + 1;\n                end\n\n                STOP_BIT: begin\n                    out_byte <= data_buffer;\n                    done <= 1;\n                end\n\n                IDLE: begin\n                    done <= 0;\n                end\n\n                ERROR: begin\n                    // Wait for stop bit to reset to IDLE\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State declaration\n    localparam IDLE = 3'b000,\n               START = 3'b001,\n               RECEIVE = 3'b010,\n               STOP = 3'b011,\n               ERROR = 3'b100;\n\n    reg [2:0] current_state, next_state;\n    reg [7:0] data_buffer;\n    reg [3:0] bit_count;\n\n    // State transition\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic and outputs\n    always @(*) begin\n        next_state = current_state; // Default state: hold current state\n        done = 0;\n        case (current_state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START;\n            end\n            START: begin\n                if (in == 0) begin // Confirming start bit\n                    next_state = RECEIVE;\n                    bit_count = 0;\n                    data_buffer = 0;\n                end\n                else // False start, return to idle\n                    next_state = IDLE;\n            end\n            RECEIVE: begin\n                if (bit_count < 8) begin\n                    data_buffer[bit_count] = in; // Store bits from LSB to MSB\n                    bit_count = bit_count + 1;\n                end\n                else \n                    next_state = STOP;\n            end\n            STOP: begin\n                if (in == 1) begin // Stop bit is correct\n                    out_byte = data_buffer;\n                    done = 1;\n                    next_state = IDLE;\n                end\n                else // Incorrect stop bit, stay in error state until a correct stop bit is received\n                    next_state = ERROR;\n            end\n            ERROR: begin\n                // Stay in error state until a stop bit (1) is detected\n                if (in == 1)\n                    next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic \n    always @(posedge clk) begin\n        if (reset) begin\n            out_byte <= 0;\n            done <= 0;\n        end\n        else begin\n            if (current_state == STOP && in == 1) begin\n                out_byte <= data_buffer;\n                done <= 1;\n            end\n            else begin\n                done <= 0;\n            end\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // Declare state constants\n    localparam IDLE = 0,\n               START_BIT = 1,\n               RECEIVE_BITS = 2,\n               STOP_BIT = 3,\n               ERROR = 4;\n\n    // State variable\n    reg [2:0] current_state, next_state;\n\n    // Bit counter for received bits\n    reg [3:0] bit_count;\n\n    // Temporary register to hold incoming byte\n    reg [7:0] temp_byte;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        next_state = current_state; // Default state: stay in current state\n        done = 0; // Default output\n        case (current_state)\n            IDLE: begin\n                if (in == 0) // Start bit detected\n                    next_state = START_BIT;\n            end\n            START_BIT: begin\n                next_state = RECEIVE_BITS; // Move to receive data bits\n                bit_count = 0; // Initialize bit counter\n                temp_byte = 0; // Clear temporary byte storage\n            end\n            RECEIVE_BITS: begin\n                if (bit_count < 8) begin\n                    temp_byte = (temp_byte >> 1) | (in << 7); // Shift in the received bit, LSB first\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = STOP_BIT; // All 8 bits received, check for stop bit\n                end\n            end\n            STOP_BIT: begin\n                if (in == 1) begin // Stop bit is correct\n                    next_state = IDLE;\n                    out_byte = temp_byte; // Update output byte\n                    done = 1; // Indicate successful reception\n                end else begin\n                    next_state = ERROR; // Incorrect stop bit, handle error\n                end\n            end\n            ERROR: begin\n                if (in == 1) // Wait for a stop bit to synchronize\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg [7:0] out_byte,\n\toutput reg done\n);\n\n\t// State definitions\n\tparameter IDLE = 0,\n\t          START_BIT = 1,\n\t          RECEIVE_BITS = 2,\n\t          STOP_BIT = 3,\n\t          ERROR = 4;\n\n\t// FSM state register\n\treg [2:0] state, next_state;\n\t\n\t// Bit counter for received bits\n\treg [3:0] bit_count;\n\t\n\t// Data register to hold incoming bits\n\treg [7:0] data_shift_reg;\n\n\t// Next state logic and state registers\n\talways @(posedge clk or posedge reset) begin\n\t\tif (reset) begin\n\t\t\tstate <= IDLE;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\t\n\t// FSM transitions and output logic\n\talways @(*) begin\n\t\t// Defaults\n\t\tnext_state = state;\n\t\tdone = 0;\n\t\tout_byte = data_shift_reg;\n\n\t\tcase (state)\n\t\t\tIDLE: begin\n\t\t\t\tif (in == 0) begin  // Start bit detected\n\t\t\t\t\tnext_state = START_BIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tSTART_BIT: begin\n\t\t\t\tnext_state = RECEIVE_BITS;  // Move to receive data bits\n\t\t\t\tbit_count = 0;\n\t\t\t\tdata_shift_reg = 0;\n\t\t\tend\n\t\t\t\n\t\t\tRECEIVE_BITS: begin\n\t\t\t\tif (bit_count < 8) begin\n\t\t\t\t\tdata_shift_reg[bit_count] = in;  // Shift in the LSB first\n\t\t\t\t\tbit_count = bit_count + 1;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = STOP_BIT;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tSTOP_BIT: begin\n\t\t\t\tif (in == 1) begin  // Correct stop bit\n\t\t\t\t\tout_byte = data_shift_reg;\n\t\t\t\t\tdone = 1;\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend else begin\n\t\t\t\t\tnext_state = ERROR;  // Incorrect stop bit, handle error state\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tERROR: begin  // Wait in error state until a stop bit (1) is found\n\t\t\t\tif (in == 1) begin\n\t\t\t\t\tnext_state = IDLE;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tendcase\n\tend\n\t\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 0,\n               START = 1,\n               RECEIVE = 2,\n               STOP = 3;\n\n    // FSM state variable\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count;  // To count the bits received\n\n    // Next state and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 0;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (!in) begin  // Start bit detected (active low)\n                        next_state <= START;\n                    end\n                    done <= 0;\n                end\n                START: begin\n                    if (bit_count < 8) begin\n                        next_state <= RECEIVE;\n                    end else begin\n                        next_state <= STOP;\n                    end\n                    bit_count <= bit_count + 1;\n                    out_byte <= (out_byte >> 1) | (in << 7);\n                end\n                RECEIVE: begin\n                    if (bit_count < 8) begin\n                        out_byte <= (out_byte >> 1) | (in << 7);\n                        bit_count <= bit_count + 1;\n                    end else begin\n                        next_state <= STOP;\n                    end\n                end\n                STOP: begin\n                    if (in == 1) begin  // Stop bit should be high\n                        done <= 1;\n                        next_state <= IDLE;\n                    end else begin\n                        next_state <= IDLE;  // Incorrect stop bit, go to IDLE and wait for next start bit\n                    end\n                    bit_count <= 0;\n                end\n                default: next_state <= IDLE;\n            endcase\n        end\n    end\n\n    // Reset state logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            next_state <= IDLE;\n            out_byte <= 0;\n            bit_count <= 0;\n            done <= 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // Define the states\n    localparam IDLE = 3'd0,\n               START = 3'd1,\n               RECEIVE = 3'd2,\n               STOP = 3'd3,\n               ERROR = 3'd4;  // State to handle error in stop bit\n\n    // State, bit counter and temporary storage for incoming bits\n    reg [2:0] state, next_state;\n    reg [3:0] bit_count;\n    reg [7:0] temp_byte;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_count <= 0;\n            out_byte <= 0;\n            done <= 0;\n        end\n        else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in == 0)  // Start bit detected\n                        next_state <= START;\n                end\n                START: begin\n                    next_state <= RECEIVE;\n                    bit_count <= 0;\n                    temp_byte <= 0;\n                end\n                RECEIVE: begin\n                    temp_byte[bit_count] <= in;\n                    bit_count <= bit_count + 1;\n                    if (bit_count == 7)\n                        next_state <= STOP;\n                end\n                STOP: begin\n                    if (in == 1) begin\n                        out_byte <= temp_byte;\n                        done <= 1;\n                        next_state <= IDLE;\n                    end else begin\n                        next_state <= ERROR;\n                    end\n                end\n                ERROR: begin\n                    if (in == 1)  // Waiting for a valid stop bit\n                        next_state <= IDLE;\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 0,\n               RECEIVE_START = 1,\n               RECEIVE_BITS = 2,\n               CHECK_STOP = 3,\n               ERROR = 4;\n\n    // State, bit counter and temporary byte storage\n    reg [2:0] state, next_state;\n    reg [2:0] bit_counter;\n    reg [7:0] temp_byte;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 0;\n            done <= 0;\n            bit_counter <= 0;\n            temp_byte <= 0;\n        end else begin\n            state <= next_state;\n            case(state)\n                RECEIVE_BITS: begin\n                    temp_byte[bit_counter] <= in;\n                    bit_counter <= bit_counter + 1;\n                end\n                CHECK_STOP: begin\n                    if (in == 1) begin\n                        out_byte <= temp_byte;\n                        done <= 1;\n                    end else begin\n                        done <= 0;\n                    end\n                end\n                default: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to staying in the current state\n        case (state)\n            IDLE: begin\n                if (in == 0) // Detect start bit\n                    next_state = RECEIVE_START;\n            end\n            RECEIVE_START: begin\n                next_state = RECEIVE_BITS; // Start receiving bits\n                bit_counter = 0; // Reset bit counter\n            end\n            RECEIVE_BITS: begin\n                if (bit_counter == 7) // After receiving 8 bits\n                    next_state = CHECK_STOP;\n            end\n            CHECK_STOP: begin\n                next_state = (in == 1) ? IDLE : ERROR; // Check stop bit\n            end\n            ERROR: begin\n                if (in == 1) // Wait for a valid stop bit to recover\n                    next_state = IDLE;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State declaration\n    typedef enum int {\n        IDLE,\n        START,\n        RECEIVE,\n        STOP,\n        ERROR\n    } state_t;\n\n    // State registers\n    reg [2:0] current_state, next_state;\n    reg [3:0] bit_count;  // to count the bits received\n\n    // FSM and data handling\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            out_byte <= 8'b0;\n            bit_count <= 0;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                IDLE: begin\n                    out_byte <= 8'b0;\n                    bit_count <= 0;\n                    done <= 0;\n                end\n                RECEIVE: begin\n                    if (bit_count < 8) begin\n                        // Store bits from LSB to MSB\n                        out_byte <= {in, out_byte[7:1]};\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                STOP: begin\n                    done <= 1;  // Indicate a complete byte received\n                end\n                ERROR: begin\n                    // Wait for a stop bit to clear the error state\n                    done <= 0;\n                    if (in == 1) begin\n                        next_state <= IDLE;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: next_state = (in == 0) ? START : IDLE;\n            START: next_state = RECEIVE;\n            RECEIVE: next_state = (bit_count == 8) ? STOP : RECEIVE;\n            STOP: next_state = (in == 1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 0,\n               START = 1,\n               RECEIVE = 2,\n               CHECK_STOP = 3;\n\n    // FSM state variable\n    reg [1:0] state, next_state;\n    reg [2:0] bit_count; // to count the bits received\n\n    // Data shift register\n    reg [7:0] data_shift;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= IDLE;\n            out_byte <= 8'd0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    out_byte <= 8'd0;\n                    done <= 0;\n                end\n                START: begin\n                    // Nothing to do here\n                end\n                RECEIVE: begin\n                    // Shift in the bits as they come, LSB first\n                    data_shift <= {in, data_shift[7:1]};\n                end\n                CHECK_STOP: begin\n                    if (in == 1) begin\n                        out_byte <= data_shift;\n                        done <= 1;\n                    end else begin\n                        done <= 0;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in == 0) // Detect start bit\n                    next_state = START;\n                else\n                    next_state = IDLE;\n            end\n            START: begin\n                next_state = RECEIVE;\n                bit_count = 0; // Reset bit counter\n            end\n            RECEIVE: begin\n                if (bit_count < 7) begin\n                    next_state = RECEIVE;\n                    bit_count = bit_count + 1;\n                end else begin\n                    next_state = CHECK_STOP;\n                end\n            end\n            CHECK_STOP: begin\n                if (done) begin\n                    next_state = IDLE; // Transmission successful, go to IDLE\n                end else begin\n                    next_state = IDLE; // Look for next start bit\n                end\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Initialize variables\n    initial begin\n        state = IDLE;\n        next_state = IDLE;\n        out_byte = 0;\n        done = 0;\n        data_shift = 0;\n        bit_count = 0;\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg [7:0] out_byte,\n    output reg done\n);\n\n    // State declaration\n    reg [3:0] state, next_state;\n    localparam  IDLE = 4'd0,\n                START_BIT = 4'd1,\n                BIT_0 = 4'd2,\n                BIT_1 = 4'd3,\n                BIT_2 = 4'd4,\n                BIT_3 = 4'd5,\n                BIT_4 = 4'd6,\n                BIT_5 = 4'd7,\n                BIT_6 = 4'd8,\n                BIT_7 = 4'd9,\n                STOP_BIT = 4'd10,\n                ERROR = 4'd11;\n\n    // Bit counter to track the number of bits received\n    reg [3:0] bit_counter;\n\n    // Sequential logic for state transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            bit_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state >= BIT_0 && state <= BIT_7) begin\n                bit_counter <= bit_counter + 1;\n            end else begin\n                bit_counter <= 0;\n            end\n        end\n    end\n\n    // Combinational logic for next state logic\n    always @(*) begin\n        case (state)\n            IDLE: next_state = (in == 0) ? START_BIT : IDLE;\n            START_BIT: next_state = BIT_0;\n            BIT_0: next_state = (bit_counter == 0) ? BIT_1 : BIT_0;\n            BIT_1: next_state = (bit_counter == 1) ? BIT_2 : BIT_1;\n            BIT_2: next_state = (bit_counter == 2) ? BIT_3 : BIT_2;\n            BIT_3: next_state = (bit_counter == 3) ? BIT_4 : BIT_3;\n            BIT_4: next_state = (bit_counter == 4) ? BIT_5 : BIT_4;\n            BIT_5: next_state = (bit_counter == 5) ? BIT_6 : BIT_5;\n            BIT_6: next_state = (bit_counter == 6) ? BIT_7 : BIT_6;\n            BIT_7: next_state = (bit_counter == 7) ? STOP_BIT : BIT_7;\n            STOP_BIT: next_state = (in == 1) ? IDLE : ERROR;\n            ERROR: next_state = (in == 1) ? IDLE : ERROR;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Combinational logic for output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            out_byte <= 0;\n            done <= 0;\n        end else if (state >= BIT_0 && state <= BIT_7 && next_state != ERROR) begin\n            out_byte[bit_counter] <= in;\n        end else if (state == STOP_BIT && in == 1) begin\n            done <= 1;\n        end else if (state == ERROR) begin\n            done <= 0;\n        end else if (state == IDLE) begin\n            done <= 0;\n        end\n    end\nendmodule\n"]}
{"task_id": "gshare", "gptgen_RTL": ["module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n    // Define the size of the Pattern History Table (PHT)\n    parameter PHT_SIZE = 128;\n    parameter COUNTER_BITS = 2;\n\n    // Declare the PHT and the global history register\n    reg [COUNTER_BITS-1:0] pht [PHT_SIZE-1:0];\n    reg [6:0] global_history;\n\n    // Compute the index by hashing the PC with the global history\n    wire [6:0] index = predict_pc ^ global_history;\n\n    // Predict taken or not\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            predict_taken <= 1'b0;\n            predict_history <= 7'b0;\n            // Reset all PHT entries\n            integer i;\n            for (i = 0; i < PHT_SIZE; i++) begin\n                pht[i] <= 2'b01;  // Initialize PHT to weakly not taken\n            end\n        end else begin\n            if (predict_valid) begin\n                // Output the prediction and the history used for the prediction\n                predict_taken <= pht[index][1];\n                predict_history <= global_history;\n            end\n            if (train_valid) begin\n                // Training logic\n                if (train_taken && pht[train_pc ^ train_history] != 2'b11) begin\n                    pht[train_pc ^ train_history] <= pht[train_pc ^ train_history] + 1'b1;\n                end else if (!train_taken && pht[train_pc ^ train_history] != 2'b00) begin\n                    pht[train_pc ^ train_history] <= pht[train_pc ^ train_history] - 1'b1;\n                end\n                \n                // Update global history on training\n                global_history <= {global_history[5:0], train_taken};\n\n                // If there was a misprediction, correct the history\n                if (train_mispredicted) begin\n                    global_history <= train_history;\n                end\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Constant for size of branch predictor table\n    localparam TABLE_SIZE = 128; // 2^7 entries for 7-bit index\n\n    // Define a 2-bit saturating counter array for PHT\n    reg [1:0] pht[TABLE_SIZE-1:0];\n\n    // Global branch history register\n    reg [6:0] global_history;\n\n    // Combinational logic for index calculation using xor of PC and global history\n    wire [6:0] predict_index = predict_pc ^ global_history;\n    wire [6:0] train_index = train_pc ^ train_history;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset global history and all PHT entries\n            global_history <= 7'b0;\n            integer i;\n            for (i = 0; i < TABLE_SIZE; i++) begin\n                pht[i] <= 2'b01; // Initialize to weakly taken state\n            end\n        end\n        else begin\n            // Training logic\n            if (train_valid) begin\n                // Misprediction recovery\n                if (train_mispredicted) begin\n                    global_history <= train_history; // Recover to the state after mispredicted branch\n                end\n\n                // PHT update\n                if (train_taken && pht[train_index] < 2'b11) begin\n                    pht[train_index] <= pht[train_index] + 1; // Increment saturating counter\n                end\n                else if (!train_taken && pht[train_index] > 2'b00) begin\n                    pht[train_index] <= pht[train_index] - 1; // Decrement saturating counter\n                }\n            end\n\n            // Prediction logic\n            if (predict_valid) begin\n                predict_taken <= pht[predict_index][1]; // Take the MSB of the saturating counter\n                predict_history <= global_history; // Output current global history\n\n                // Update global history on prediction\n                global_history <= {global_history[5:0], predict_taken};\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n\n    // Define the size of the pattern history table (PHT)\n    localparam PHT_SIZE = 128;\n\n    // Declare the PHT and the global history register\n    reg [1:0] pht[PHT_SIZE-1:0];\n    reg [6:0] global_history;\n\n    // Combinational logic for hashing PC with global history\n    wire [6:0] hash_index;\n    assign hash_index = predict_pc ^ global_history;\n\n    // Predict logic\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = pht[hash_index][1]; // Take the MSB as the prediction\n            predict_history = global_history;\n        end\n    end\n\n    // Sequential logic for updating on positive edge of clock or asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset logic\n            global_history <= 7'b0;\n            // Reset all entries in the PHT to weakly not taken (01)\n            integer i;\n            for (i = 0; i < PHT_SIZE; i++) begin\n                pht[i] <= 2'b01;\n            end\n        end else begin\n            // Update global history register\n            if (predict_valid && !train_valid) begin\n                // Shift in the least significant bit (LSB) of the most significant bit (MSB) of the PHT\n                global_history <= {global_history[5:0], pht[hash_index][1]};\n            end\n\n            // Training logic\n            if (train_valid) begin\n                // Handle misprediction recovery\n                if (train_mispredicted) begin\n                    global_history <= train_history;\n                end else begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n\n                // Update the PHT based on the training data\n                wire [6:0] train_index = train_pc ^ train_history;\n                case (pht[train_index])\n                    2'b00: if (train_taken) pht[train_index] <= 2'b01;\n                    2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: if (!train_taken) pht[train_index] <= 2'b10;\n                endcase\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n    // Parameters for the PHT size and history size\n    parameter PHT_SIZE = 128;\n    parameter HISTORY_BITS = 7;\n\n    // 128-entry table of two-bit saturating counters\n    reg [1:0] pht[PHT_SIZE-1:0];\n    \n    // 7-bit global branch history register\n    reg [6:0] global_history;\n\n    // Combinational logic for generating index using XOR hash\n    wire [6:0] index_predict, index_train;\n    assign index_predict = predict_pc ^ global_history;\n    assign index_train = train_pc ^ train_history;\n\n    // Predict logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            global_history <= 7'b0;\n            predict_taken <= 1'b0;\n            predict_history <= 7'b0;\n        end else begin\n            // Handle prediction\n            if(predict_valid) begin\n                predict_taken <= pht[index_predict][1];  // Most significant bit determines the prediction\n                predict_history <= global_history;       // Capture the history used for prediction\n                global_history <= {global_history[5:0], pht[index_predict][1]};  // Shift and update history\n            end\n            \n            // Handle training\n            if(train_valid) begin\n                if (train_mispredicted) begin\n                    global_history <= train_history;  // Recover the history register\n                end\n                // Update the PHT based on the training data\n                if (pht[index_train] != 2'b11 && train_taken)\n                    pht[index_train] <= pht[index_train] + 1;\n                else if (pht[index_train] != 2'b00 && !train_taken)\n                    pht[index_train] <= pht[index_train] - 1;\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Parameters for sizes\n    parameter HISTORY_BITS = 7;\n    parameter PC_BITS = 7;\n    parameter PHT_SIZE = 128;  // 2^7\n\n    // Internal Registers\n    reg [6:0] global_history;\n    reg [1:0] PHT [0:PHT_SIZE-1];\n\n    // Combinational logic for indexing into PHT\n    wire [6:0] predict_index, train_index;\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            predict_taken <= 1'b0;\n            predict_history <= 7'b0;\n        end\n        else begin\n            // Handle predictions\n            if (predict_valid) begin\n                predict_taken <= PHT[predict_index][1];  // Taking the MSB as the prediction bit\n                predict_history <= global_history;  // Sending current history\n            end\n\n            // Update history register on every positive clock edge if prediction is valid\n            if (predict_valid) begin\n                global_history <= {global_history[HISTORY_BITS-2:0], PHT[predict_index][1]};\n            }\n\n            // Handle training\n            if (train_valid) begin\n                // Training takes precedence over updating history if misprediction\n                if (train_mispredicted) begin\n                    global_history <= {train_history[HISTORY_BITS-2:0], train_taken};\n                }\n\n                // Update the PHT based on training\n                if (PHT[train_index][1] && !train_taken) begin\n                    // Decrease counter if MSB is set and outcome was not taken\n                    if (PHT[train_index] > 2'b00) PHT[train_index] <= PHT[train_index] - 1;\n                end\n                else if (!PHT[train_index][1] && train_taken) begin\n                    // Increase counter if MSB is reset and outcome was taken\n                    if (PHT[train_index] < 2'b11) PHT[train_index] <= PHT[train_index] + 1;\n                }\n            }\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Define the Pattern History Table (PHT)\n    reg [1:0] pht[127:0];\n    \n    // Define the Global Branch History Register (GBHR)\n    reg [6:0] gbhr;\n\n    // Calculate index by XORing PC with GBHR\n    wire [6:0] index = predict_pc ^ gbhr;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset the Pattern History Table and Global Branch History Register\n            integer i;\n            for (i = 0; i < 128; i++) begin\n                pht[i] <= 2'b01; // Initialize saturating counters to weakly taken (01)\n            end\n            gbhr <= 7'b0000000;\n        end\n        else begin\n            // Update the GBHR and PHT during training\n            if (train_valid) begin\n                if (train_mispredicted) begin\n                    gbhr <= train_history; // Recover the GBHR to the state after the mispredicted branch\n                end\n                else begin\n                    gbhr <= {gbhr[5:0], train_taken}; // Shift left and update with outcome\n                }\n\n                // Update PHT based on the training outcome\n                case (pht[train_pc ^ train_history])\n                    2'b00: if (train_taken) pht[train_pc ^ train_history] <= 2'b01;\n                    2'b01: pht[train_pc ^ train_history] <= train_taken ? 2'b10 : 2'b00;\n                    2'b10: pht[train_pc ^ train_history] <= train_taken ? 2'b11 : 2'b01;\n                    2'b11: if (!train_taken) pht[train_pc ^ train_history] <= 2'b10;\n                endcase\n            end\n\n            // Predictive update of the GBHR for the next cycle if no training conflicts\n            if (predict_valid && !train_valid) begin\n                gbhr <= {gbhr[5:0], pht[index][1]}; // Predict taken if MSB of counter is 1\n            end\n        end\n    end\n    \n    // Handle predictions during the same cycle (combinational logic)\n    always @* begin\n        if (predict_valid) begin\n            predict_taken = pht[index][1]; // Take the MSB of the 2-bit counter as the prediction\n            predict_history = gbhr;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n    input predict_valid,\n    input [6:0] predict_pc,\n    output predict_taken, \n    output [6:0] predict_history,\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    // Parameters and local variables\n    reg [6:0] global_history;\n    reg [1:0] pht[127:0]; // 128-entry pattern history table of 2-bit counters\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n    integer i;\n\n    // Calculating the index for prediction and training using XOR of PC and global history\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Outputs\n    assign predict_taken = pht[predict_index][1]; // MSB indicates the prediction\n    assign predict_history = global_history;\n\n    // Asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            // Reset the global history and pattern history table\n            global_history <= 7'b0;\n            for(i = 0; i < 128; i = i + 1) begin\n                pht[i] <= 2'b01; // Initialize to weakly taken\n            end\n        end else begin\n            if(train_valid) begin\n                // Training logic\n                if(train_mispredicted) begin\n                    global_history <= train_history;\n                end else begin\n                    global_history <= {global_history[5:0], train_taken};\n                end\n                // Update the PHT according to the outcome\n                if(train_taken && pht[train_index] != 2'b11) begin\n                    pht[train_index] <= pht[train_index] + 1;\n                end else if (!train_taken && pht[train_index] != 2'b00) begin\n                    pht[train_index] <= pht[train_index] - 1;\n                end\n            end\n            else if(predict_valid) begin\n                // Update global history on predictions (not mispredictions)\n                global_history <= {global_history[5:0], pht[predict_index][1]};\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n    // Define constants\n    localparam integer PHT_SIZE = 128; // Size of Pattern History Table\n    localparam integer HISTORY_BITS = 7; // Size of global history and PC\n\n    // Registers and memories\n    reg [1:0] PHT[PHT_SIZE-1:0]; // Pattern History Table\n    reg [HISTORY_BITS-1:0] global_history; // Global history register\n\n    // Wires\n    wire [HISTORY_BITS-1:0] hash_index_predict;\n    wire [HISTORY_BITS-1:0] hash_index_train;\n\n    // Hashing for index calculation\n    assign hash_index_predict = predict_pc ^ global_history;\n    assign hash_index_train = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            global_history <= 0;\n            predict_taken <= 0;\n            predict_history <= 0;\n        end else if(predict_valid) begin\n            predict_taken <= PHT[hash_index_predict] > 1; // Predict taken if counter is 2 or 3\n            predict_history <= global_history;\n            global_history <= {global_history[HISTORY_BITS-2:0], PHT[hash_index_predict] > 1};\n        end\n    end\n\n    // Training logic\n    always @(posedge clk) begin\n        if(train_valid) begin\n            // Update PHT entry based on training data\n            if (train_taken && PHT[hash_index_train] != 2'b11) begin\n                PHT[hash_index_train] <= PHT[hash_index_train] + 1;\n            end else if (!train_taken && PHT[hash_index_train] != 2'b00) begin\n                PHT[hash_index_train] <= PHT[hash_index_train] - 1;\n            end\n\n            // Recover the global history in case of a misprediction\n            if (train_mispredicted) begin\n                global_history <= train_history;\n            end\n        end\n    end\n\n    // Initialization of PHT (asynchronously reset)\n    integer i;\n    always @(posedge areset) begin\n        if(areset) begin\n            for(i = 0; i < PHT_SIZE; i = i + 1) begin\n                PHT[i] <= 2'b01; // Initialize PHT entries to weakly not taken\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken,\n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history,\n    input [6:0] train_pc\n);\n    reg [1:0] PHT[127:0];  // Pattern History Table with 128 entries of 2-bit saturating counters\n    reg [6:0] global_history; // 7-bit global history register\n\n    wire [6:0] predict_index;\n    wire [6:0] train_index;\n\n    // Compute index for prediction and training using xor hash of PC and global history\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Prediction logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            global_history <= 7'b0;\n            predict_taken <= 0;\n            predict_history <= 7'b0;\n        end\n        else if (predict_valid) begin\n            predict_taken <= PHT[predict_index][1];\n            predict_history <= global_history;\n            // Update the global history for the next prediction\n            global_history <= {global_history[5:0], PHT[predict_index][1]};\n        end\n    end\n\n    // Training logic\n    always @(posedge clk) begin\n        if (train_valid) begin\n            // Update the PHT based on the actual outcome of the branch\n            if (train_taken) begin\n                if (PHT[train_index] != 2'b11) // Saturating increment\n                    PHT[train_index] <= PHT[train_index] + 1;\n            end\n            else begin\n                if (PHT[train_index] != 2'b00) // Saturating decrement\n                    PHT[train_index] <= PHT[train_index] - 1;\n            }\n\n            // Recover the global history if there was a misprediction\n            if (train_mispredicted) begin\n                global_history <= train_history;\n            }\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset, \n\n    input predict_valid,\n    input [6:0] predict_pc,\n    output reg predict_taken, \n    output reg [6:0] predict_history,\n\n    input train_valid,\n    input train_taken,\n    input train_mispredicted,\n    input [6:0] train_history, \n    input [6:0] train_pc\n);\n\n    reg [1:0] pht[127:0]; // Pattern History Table with 128 entries of 2-bit saturating counters\n    reg [6:0] global_history; // 7-bit global branch history register\n\n    wire [6:0] predict_index, train_index;\n    wire [1:0] predict_counter, train_counter;\n\n    // Hash function using XOR for index calculation\n    assign predict_index = predict_pc ^ global_history;\n    assign train_index = train_pc ^ train_history;\n\n    // Access PHT for prediction\n    assign predict_counter = pht[predict_index];\n\n    // On reset\n    always @(posedge areset) begin\n        if(areset) begin\n            global_history <= 7'b0;\n            for (int i = 0; i < 128; i++) begin\n                pht[i] <= 2'b01; // Initialize PHT to weakly not taken\n            end\n        end\n    end\n\n    // Prediction logic\n    always @(*) begin\n        if (predict_valid) begin\n            predict_taken = predict_counter[1];\n            predict_history = global_history;\n        end\n    end\n\n    // Update logic on positive edge of clock\n    always @(posedge clk) begin\n        if (train_valid) begin\n            // Mispredict recovery\n            if (train_mispredicted) begin\n                global_history <= train_history;\n            end else begin\n                global_history <= {global_history[5:0], train_taken};\n            end\n\n            // Train PHT based on actual outcome\n            case (pht[train_index])\n                2'b00: pht[train_index] <= train_taken ? 2'b01 : 2'b00;\n                2'b01: pht[train_index] <= train_taken ? 2'b10 : 2'b00;\n                2'b10: pht[train_index] <= train_taken ? 2'b11 : 2'b01;\n                2'b11: pht[train_index] <= train_taken ? 2'b11 : 2'b10;\n            endcase\n        end\n        else if (predict_valid) begin\n            // Update global history without misprediction recovery\n            global_history <= {global_history[5:0], predict_counter[1]};\n        end\n    end\n\nendmodule\n"]}
{"task_id": "lemmings4", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10,\n               DIG = 2'b11;\n\n    // Other variables\n    reg [1:0] state, next_state;\n    reg [5:0] fall_time; // To count fall time, 6 bits accommodate up to 63\n    \n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            walk_left <= 1;\n            walk_right <= 0;\n            aaah <= 0;\n            digging <= 0;\n            fall_time <= 0;\n        end else begin\n            state <= next_state;\n            case (next_state)\n                WALK_LEFT: begin\n                    walk_left <= 1;\n                    walk_right <= 0;\n                    aaah <= 0;\n                    digging <= 0;\n                end\n                WALK_RIGHT: begin\n                    walk_left <= 0;\n                    walk_right <= 1;\n                    aaah <= 0;\n                    digging <= 0;\n                end\n                FALL: begin\n                    walk_left <= 0;\n                    walk_right <= 0;\n                    aaah <= 1;\n                    digging <= 0;\n                    if (ground == 1 && fall_time > 20) begin\n                        walk_left <= 0;\n                        walk_right <= 0;\n                        aaah <= 0;\n                        digging <= 0;\n                    end\n                end\n                DIG: begin\n                    walk_left <= 0;\n                    walk_right <= 0;\n                    aaah <= 0;\n                    digging <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                    fall_time = 0;\n                end else if (dig) begin\n                    next_state = DIG;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                    fall_time = 0;\n                end else if (dig) begin\n                    next_state = DIG;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_time > 20) begin\n                        next_state = WALK_LEFT; // Default state after splat\n                    end else begin\n                        next_state = (fall_time % 2 == 0) ? WALK_LEFT : WALK_RIGHT;\n                    end\n                end else begin\n                    next_state = FALL;\n                    fall_time = fall_time + 1;\n                end\n            end\n            DIG: begin\n                if (!ground) begin\n                    next_state = FALL;\n                    fall_time = 0;\n                end else begin\n                    next_state = DIG;\n                end\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Definitions\n    localparam WALK_LEFT = 0,\n               WALK_RIGHT = 1,\n               FALLING = 2,\n               DIGGING = 3,\n               SPLATTERED = 4;\n\n    // Registers\n    reg [2:0] state, next_state;\n    reg [5:0] fall_counter;  // 6 bits to count up to 20+\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                if (ground == 1 && fall_counter > 20) begin\n                    fall_counter <= 0; // Reset fall counter when hitting the ground after long fall\n                end else if (ground == 0) begin\n                    fall_counter <= fall_counter + 1; // Increment fall counter while falling\n                end else begin\n                    fall_counter <= 0; // Reset on ground contact after short fall\n                end\n            end else begin\n                fall_counter <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT, WALK_RIGHT: begin\n                if (ground == 0) begin\n                    next_state = FALLING;\n                end else if (dig == 1 && ground == 1) begin\n                    next_state = DIGGING;\n                end else if (bump_left == 1) begin\n                    next_state = WALK_RIGHT;\n                end else if (bump_right == 1) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = state;\n                end\n            end\n            FALLING: begin\n                if (ground == 0) begin\n                    if (fall_counter > 20) begin\n                        next_state = SPLATTERED;\n                    end else begin\n                        next_state = FALLING;\n                    end\n                end else if (ground == 1) begin\n                    next_state = (state == WALK_LEFT || next_state == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                end\n            end\n            DIGGING: begin\n                if (ground == 0) begin\n                    next_state = FALLING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            SPLATTERED: begin\n                next_state = SPLATTERED; // Remains in this state once splattered\n            end\n            default: next_state = WALK_LEFT; // Fallback state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Reset all outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING: aaah = 1;\n            DIGGING: digging = 1;\n            SPLATTERED: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Definition\n    typedef enum {\n        WALK_LEFT,\n        WALK_RIGHT,\n        FALLING,\n        DIGGING,\n        SPLATTER\n    } state_t;\n\n    reg [5:0] fall_time; // To count the fall time and check for splatter\n    state_t current_state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            current_state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == FALLING) begin\n                fall_time <= ground ? 0 : fall_time + 1;\n            end else begin\n                fall_time <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(current_state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left && !bump_right) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right && !bump_left) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground && fall_time > 20) next_state = SPLATTER;\n                else if (ground) next_state = (bump_right) ? WALK_LEFT : WALK_RIGHT; // Resume previous direction prior to fall\n                else next_state = FALLING;\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n                else next_state = DIGGING;\n            end\n            SPLATTER: next_state = SPLATTER;\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default all outputs to 0\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case(current_state)\n            WALK_LEFT: walk_left = 1;\n            WALK_RIGHT: walk_right = 1;\n            FALLING: aaah = 1;\n            DIGGING: digging = 1;\n            SPLATTER: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10,\n               DIG = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg [5:0] fall_time; // Counter to track falling time\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALL) begin\n                if (aaah)\n                    fall_time <= fall_time + 1;\n                else\n                    fall_time <= 0;\n            end else begin\n                fall_time <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default to staying in the current state\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_time > 20)\n                        next_state = WALK_LEFT; // Reset to default after splattering\n                    else if (fall_time == 0)\n                        next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                end\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (ground)\n                    next_state = (walk_left ? WALK_LEFT : WALK_RIGHT); // Continue walking in the original direction after digging\n            end\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'd0,\n               WALK_RIGHT = 2'd1,\n               FALL = 2'd2,\n               DIG = 2'd3;\n\n    // Registers to hold current state and next state\n    reg [1:0] current_state, next_state;\n    reg [5:0] fall_time; // Counter to measure fall time to check if splatters\n\n    // State transition logic with inputs\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == FALL)\n                fall_time <= fall_time + 1;\n            else\n                fall_time <= 0;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        next_state = current_state; // Default to stay in current state unless conditions met\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (fall_time > 20) // Check for splatter\n                        next_state = WALK_LEFT; // Reset to initial state if splattered\n                    else // Resume last direction\n                        next_state = (fall_time[0]) ? WALK_RIGHT : WALK_LEFT;\n                end\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (!dig)\n                    next_state = (fall_time[0]) ? WALK_RIGHT : WALK_LEFT;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        walk_left = (current_state == WALK_LEFT);\n        walk_right = (current_state == WALK_RIGHT);\n        aaah = (current_state == FALL);\n        digging = (current_state == DIG);\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // Define state codes\n    localparam WALK_LEFT = 2'b00, \n               WALK_RIGHT = 2'b01, \n               FALL = 2'b10, \n               DIG = 2'b11;\n\n    // State and fall counter\n    reg [1:0] state, next_state;\n    reg [5:0] fall_counter;  // 6 bits to count up to 20+\n\n    // State machine transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            state <= next_state;\n            if(state == FALL)\n                fall_counter <= fall_counter + 1;\n            else\n                fall_counter <= 0;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT: begin\n                if(!ground)\n                    next_state = FALL;\n                else if(dig)\n                    next_state = DIG;\n                else if(bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if(!ground)\n                    next_state = FALL;\n                else if(dig)\n                    next_state = DIG;\n                else if(bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            FALL: begin\n                if(ground && fall_counter > 20)\n                    next_state = WALK_LEFT; // Reset to a default state as lemming splatters\n                else if(ground)\n                    next_state = (state == FALL && walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n\n            DIG: begin\n                if(!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case(state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            \n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            \n            FALL: begin\n                aaah = 1;\n            end\n            \n            DIG: begin\n                digging = 1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    parameter WALK_LEFT = 0, WALK_RIGHT = 1, FALLING = 2, DIGGING = 3, SPLATTER = 4;\n    reg [2:0] state, next_state;\n    reg [5:0] fall_time;  // Counter to track fall time\n\n    // State Transition Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                fall_time <= fall_time + 1;\n            end else begin\n                fall_time <= 0;\n            end\n        end\n    end\n\n    // Next State Logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground && fall_time > 20) next_state = SPLATTER;\n                else if (ground) next_state = (bump_right ? WALK_LEFT : (bump_left ? WALK_RIGHT : state));\n                else next_state = FALLING;\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n                else if (ground) next_state = (bump_right ? WALK_LEFT : (bump_left ? WALK_RIGHT : DIGGING));\n            end\n            SPLATTER: begin\n                next_state = SPLATTER;\n            end\n            default: next_state = SPLATTER;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALLING: begin\n                aaah = 1;\n            end\n            DIGGING: begin\n                digging = 1;\n            end\n            SPLATTER: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput reg walk_left,\n\toutput reg walk_right,\n\toutput reg aaah,\n\toutput reg digging\n);\n\n\treg [5:0] fall_count; // Counter for fall duration to check if the Lemming splatters\n\tparameter WALK_LEFT = 0, WALK_RIGHT = 1, FALL = 2, DIG = 3, SPLATTERED = 4;\n\treg [2:0] state, next_state;\n\n\t// State transition logic\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\tstate <= WALK_LEFT;\n\t\tend else begin\n\t\t\tstate <= next_state;\n\t\tend\n\tend\n\n\t// Next state logic based on current state and inputs\n\talways @(*) begin\n\t\tcase (state)\n\t\t\tWALK_LEFT: begin\n\t\t\t\tif (!ground) next_state = FALL;\n\t\t\t\telse if (dig) next_state = DIG;\n\t\t\t\telse if (bump_left) next_state = WALK_RIGHT;\n\t\t\t\telse next_state = WALK_LEFT;\n\t\t\tend\n\t\t\tWALK_RIGHT: begin\n\t\t\t\tif (!ground) next_state = FALL;\n\t\t\t\telse if (dig) next_state = DIG;\n\t\t\t\telse if (bump_right) next_state = WALK_LEFT;\n\t\t\t\telse next_state = WALK_RIGHT;\n\t\t\tend\n\t\t\tFALL: begin\n\t\t\t\tif (ground && fall_count > 20) next_state = SPLATTERED;\n\t\t\t\telse if (ground) next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n\t\t\t\telse next_state = FALL;\n\t\t\tend\n\t\t\tDIG: begin\n\t\t\t\tif (!ground) next_state = FALL;\n\t\t\t\telse next_state = DIG;\n\t\t\tend\n\t\t\tSPLATTERED: begin\n\t\t\t\tnext_state = SPLATTERED; // Once splattered, remains in this state\n\t\t\tend\n\t\t\tdefault: next_state = SPLATTERED; // Safety default\n\t\tendcase\n\tend\n\n\t// Output logic and fall count management\n\talways @(posedge clk or posedge areset) begin\n\t\tif (areset) begin\n\t\t\twalk_left <= 1;\n\t\t\twalk_right <= 0;\n\t\t\taaah <= 0;\n\t\t\tdigging <= 0;\n\t\t\tfall_count <= 0;\n\t\tend else begin\n\t\t\tcase (state)\n\t\t\t\tWALK_LEFT: begin\n\t\t\t\t\twalk_left <= 1;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\tend\n\t\t\t\tWALK_RIGHT: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 1;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\tend\n\t\t\t\tFALL: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 1;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\t\tif (!ground) fall_count <= fall_count + 1;\n\t\t\t\t\telse fall_count <= 0;\n\t\t\t\tend\n\t\t\t\tDIG: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 1;\n\t\t\t\tend\n\t\t\t\tSPLATTERED: begin\n\t\t\t\t\twalk_left <= 0;\n\t\t\t\t\twalk_right <= 0;\n\t\t\t\t\taaah <= 0;\n\t\t\t\t\tdigging <= 0;\n\t\t\t\tend\n\t\t\tendcase\n\t\tend\n\tend\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Declaration\n    localparam WALK_LEFT = 0, WALK_RIGHT = 1, FALL = 2, DIG = 3, SPLATTER = 4;\n    reg [2:0] current_state, next_state;\n    reg [5:0] fall_counter; // 6 bits to count up to 20\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n            fall_counter <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == FALL) begin\n                if (ground == 0)\n                    fall_counter <= fall_counter + 1;\n                else\n                    fall_counter <= 0;\n            end else \n                fall_counter <= 0;\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground && fall_counter > 20)\n                    next_state = SPLATTER;\n                else if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n            SPLATTER: begin\n                next_state = SPLATTER;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic based on state\n    always @* begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n            DIG: begin\n                digging = 1;\n            end\n            SPLATTER: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    localparam WALK_LEFT = 3'd0,\n               WALK_RIGHT = 3'd1,\n               FALLING = 3'd2,\n               DIGGING = 3'd3,\n               SPLATTER = 3'd4;\n\n    reg [2:0] state, next_state;\n    reg [5:0] fall_time; // Counter to track time spent falling\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            fall_time <= 0;\n        end else begin\n            state <= next_state;\n            if (state == FALLING) begin\n                fall_time <= fall_time + 1;\n            end else begin\n                fall_time <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = state; // Default is to stay in current state\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left) next_state = WALK_RIGHT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right) next_state = WALK_LEFT;\n            end\n            FALLING: begin\n                if (ground && fall_time > 20) next_state = SPLATTER;\n                else if (ground) next_state = (fall_time ? WALK_LEFT : WALK_RIGHT);\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n            end\n            SPLATTER: begin\n                next_state = SPLATTER; // Once splattered, no change\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALLING);\n        digging = (state == DIGGING);\n\n        // Zero outputs in SPLATTER state\n        if (state == SPLATTER) begin\n            walk_left = 0;\n            walk_right = 0;\n            aaah = 0;\n            digging = 0;\n        end\n    end\nendmodule\n"]}
{"task_id": "review2015_fsm", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // Define states\n    parameter IDLE = 0,\n              CHECK_PATTERN = 1,\n              SHIFT_DATA = 2,\n              COUNT = 3,\n              NOTIFY = 4,\n              WAIT_ACK = 5;\n\n    reg [2:0] state, next_state;\n    reg [3:0] shift_counter;\n    reg [3:0] pattern_reg;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (pattern_reg == 4'b1101)\n                    next_state = SHIFT_DATA;\n                else\n                    next_state = IDLE;\n            end\n            CHECK_PATTERN: begin\n                next_state = (pattern_reg == 4'b1101) ? SHIFT_DATA : CHECK_PATTERN;\n            end\n            SHIFT_DATA: begin\n                if (shift_counter == 4)\n                    next_state = COUNT;\n                else\n                    next_state = SHIFT_DATA;\n            end\n            COUNT: begin\n                if (done_counting)\n                    next_state = NOTIFY;\n                else\n                    next_state = COUNT;\n            end\n            NOTIFY: begin\n                next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACK;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output and internal registers logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n            pattern_reg <= 0;\n            shift_counter <= 0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    pattern_reg <= {pattern_reg[2:0], data};\n                    shift_ena <= 0;\n                    counting <= 0;\n                    done <= 0;\n                end\n                CHECK_PATTERN: begin\n                    pattern_reg <= {pattern_reg[2:0], data};\n                end\n                SHIFT_DATA: begin\n                    shift_ena <= 1;\n                    pattern_reg <= {pattern_reg[2:0], data};\n                    shift_counter <= shift_counter + 1;\n                end\n                COUNT: begin\n                    shift_ena <= 0;\n                    counting <= 1;\n                    shift_counter <= 0;\n                end\n                NOTIFY: begin\n                    counting <= 0;\n                    done <= 1;\n                end\n                WAIT_ACK: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State Declaration\n    typedef enum reg [2:0] {\n        IDLE, DETECT_1, DETECT_11, DETECT_110, DETECT_1101, SHIFT_BITS, COUNTING, NOTIFY, WAIT_ACK\n    } state_type;\n\n    // State Register\n    reg [2:0] current_state, next_state;\n\n    // Bit counter for shifting in bits after detecting 1101\n    reg [2:0] bit_counter;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= IDLE;\n            bit_counter <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == SHIFT_BITS) begin\n                if (bit_counter < 4)\n                    bit_counter <= bit_counter + 1;\n                else\n                    bit_counter <= 0;\n            end\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (data == 1)\n                    next_state = DETECT_1;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_1: begin\n                if (data == 1)\n                    next_state = DETECT_11;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_11: begin\n                if (data == 0)\n                    next_state = DETECT_110;\n                else\n                    next_state = DETECT_11; // stay in this state if 1 continues\n            end\n            DETECT_110: begin\n                if (data == 1)\n                    next_state = DETECT_1101;\n                else\n                    next_state = IDLE;\n            end\n            DETECT_1101: begin\n                next_state = SHIFT_BITS;\n            end\n            SHIFT_BITS: begin\n                if (bit_counter < 3)\n                    next_state = SHIFT_BITS;\n                else\n                    next_state = COUNTING;\n            end\n            COUNTING: begin\n                if (done_counting)\n                    next_state = NOTIFY;\n                else\n                    next_state = COUNTING;\n            end\n            NOTIFY: begin\n                if (ack)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = NOTIFY;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACK;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Default all outputs to 0\n        shift_ena = 0;\n        counting = 0;\n        done = 0;\n\n        case (current_state)\n            SHIFT_BITS: begin\n                shift_ena = 1;\n            end\n            COUNTING: begin\n                counting = 1;\n            end\n            NOTIFY: begin\n                done = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // Define states using parameters for better readability\n    parameter IDLE = 0,\n              CHECK_PATTERN = 1,\n              SHIFT_BITS = 2,\n              COUNT = 3,\n              NOTIFY = 4,\n              WAIT_ACK = 5;\n    \n    // State register\n    reg [2:0] current_state, next_state;\n    \n    // Pattern detection shift register\n    reg [3:0] pattern_shift_reg;\n    \n    // Bit shift counter\n    reg [2:0] bit_count;\n    \n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            pattern_shift_reg <= 0;\n            bit_count <= 0;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n            \n            case (current_state)\n                IDLE: begin\n                    pattern_shift_reg <= {pattern_shift_reg[2:0], data};\n                end\n                CHECK_PATTERN: begin\n                    pattern_shift_reg <= {pattern_shift_reg[2:0], data};\n                end\n                SHIFT_BITS: begin\n                    bit_count <= (bit_count == 4) ? 0 : bit_count + 1;\n                end\n                COUNT: begin\n                    // Hold state\n                end\n                NOTIFY: begin\n                    // Hold state\n                end\n                WAIT_ACK: begin\n                    // Hold state\n                end\n            endcase\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        next_state = current_state; // Default keep current state\n        \n        case (current_state)\n            IDLE: begin\n                if (pattern_shift_reg == 4'b1101)\n                    next_state = SHIFT_BITS;\n            end\n            CHECK_PATTERN: begin\n                if (pattern_shift_reg == 4'b1101)\n                    next_state = SHIFT_BITS;\n                else\n                    next_state = IDLE;\n            end\n            SHIFT_BITS: begin\n                if (bit_count == 4)\n                    next_state = COUNT;\n                else\n                    next_state = SHIFT_BITS;\n            end\n            COUNT: begin\n                if (done_counting)\n                    next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Output logic\n    always @(*) begin\n        shift_ena = (current_state == SHIFT_BITS);\n        counting = (current_state == COUNT);\n        done = (current_state == NOTIFY);\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    output reg done,\n    input done_counting,\n    input ack );\n\n    // State Declaration\n    typedef enum int {\n        WAIT_START_SEQ,\n        SHIFT_DATA,\n        COUNT_WAIT,\n        NOTIFY_USER,\n        WAIT_ACK\n    } state_type;\n\n    // State registers\n    state_type state, next_state;\n\n    // Shift counter to track when to stop shifting data\n    reg [2:0] shift_counter;\n\n    // Pattern Detection for sequence 1101\n    reg [3:0] pattern_reg;\n\n    // State Machine Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= WAIT_START_SEQ;\n            pattern_reg <= 4'b0000;\n        end else begin\n            state <= next_state;\n            pattern_reg <= {pattern_reg[2:0], data};  // Shift in the new data bit\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default assignments\n        next_state = state;\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            WAIT_START_SEQ: begin\n                if (pattern_reg == 4'b1101)\n                    next_state = SHIFT_DATA;\n            end\n            SHIFT_DATA: begin\n                shift_ena = 1'b1;\n                if (shift_counter == 3)  // 0 to 3 makes 4 cycles\n                    next_state = COUNT_WAIT;\n            end\n            COUNT_WAIT: begin\n                counting = 1'b1;\n                if (done_counting)\n                    next_state = NOTIFY_USER;\n            end\n            NOTIFY_USER: begin\n                done = 1'b1;\n                if (ack)\n                    next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = WAIT_START_SEQ;\n            end\n        end\n    end\n\n    // Shift counter control\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            shift_counter <= 0;\n        else if (state == SHIFT_DATA && shift_counter < 3)\n            shift_counter <= shift_counter + 1;\n        else if (state != SHIFT_DATA)\n            shift_counter <= 0;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State declaration\n    typedef enum int {\n        IDLE,\n        CHECK_PATTERN,\n        SHIFT_DATA,\n        COUNT,\n        NOTIFY,\n        WAIT_ACK\n    } state_t;\n\n    // State registers\n    state_t current_state, next_state;\n\n    // Shift register to detect the pattern 1101\n    reg [3:0] shift_reg;\n    reg [2:0] shift_count;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_reg <= 4'b0000;\n            shift_count <= 3'b000;\n        end else begin\n            current_state <= next_state;\n            if (current_state == CHECK_PATTERN || current_state == SHIFT_DATA)\n                shift_reg <= {shift_reg[2:0], data};\n            if (current_state == SHIFT_DATA)\n                shift_count <= shift_count + 1;\n            if (current_state == WAIT_ACK && ack)\n                shift_count <= 0;  // reset shift count after acknowledging\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                next_state = (data == 1'b1) ? CHECK_PATTERN : IDLE;\n            end\n            CHECK_PATTERN: begin\n                if (shift_reg == 4'b1101)\n                    next_state = SHIFT_DATA;\n                else\n                    next_state = CHECK_PATTERN;\n            end\n            SHIFT_DATA: begin\n                if (shift_count >= 3)\n                    next_state = COUNT;\n                else\n                    next_state = SHIFT_DATA;\n            end\n            COUNT: begin\n                if (done_counting)\n                    next_state = NOTIFY;\n                else\n                    next_state = COUNT;\n            end\n            NOTIFY: begin\n                next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = WAIT_ACK;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        shift_ena = (current_state == SHIFT_DATA);\n        counting = (current_state == COUNT);\n        done = (current_state == NOTIFY);\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // Define states\n    typedef enum int {SEARCH, SHIFT, COUNT, NOTIFY, WAIT_ACK} state_t;\n    state_t current_state, next_state;\n\n    // Shift register to detect the pattern 1101\n    reg [3:0] shift_reg;\n\n    // Counter for the shift enable\n    reg [2:0] shift_count;\n\n    // State machine\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= SEARCH;\n            shift_reg <= 4'b0000;\n            shift_count <= 0;\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                SEARCH: begin\n                    shift_reg <= {shift_reg[2:0], data};\n                end\n                SHIFT: begin\n                    if (shift_count < 4) begin\n                        shift_count <= shift_count + 1;\n                    end\n                end\n                COUNT: begin\n                    // Hold state\n                end\n                NOTIFY: begin\n                    // Hold state\n                end\n                WAIT_ACK: begin\n                    if (ack) begin\n                        done <= 0;  // Reset the done signal\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        next_state = current_state;\n        case (current_state)\n            SEARCH: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT;\n                    shift_ena = 1;\n                    shift_count = 0;\n                end\n            end\n            SHIFT: begin\n                if (shift_count >= 4) begin\n                    next_state = COUNT;\n                    shift_ena = 0;\n                    counting = 1;\n                end else begin\n                    shift_ena = 1;  // Keep enabling shifting\n                end\n            end\n            COUNT: begin\n                if (done_counting) begin\n                    next_state = NOTIFY;\n                    counting = 0;\n                    done = 1;\n                end\n            end\n            NOTIFY: begin\n                next_state = WAIT_ACK;\n            end\n            WAIT_ACK: begin\n                if (ack) begin\n                    next_state = SEARCH;\n                end\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n    // State definition\n    typedef enum {\n        IDLE,\n        CHECK_PATTERN,\n        SHIFT_DATA,\n        COUNT,\n        NOTIFY,\n        WAIT_ACK\n    } state_t;\n\n    // State registers\n    reg [2:0] current_state, next_state;\n    reg [3:0] pattern_shift_reg;\n    reg [2:0] shift_counter;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        next_state = current_state; // Default keep current state\n        case (current_state)\n            IDLE: begin\n                if (data == 1'b1) // Start of potential pattern\n                    next_state = CHECK_PATTERN;\n            end\n            CHECK_PATTERN: begin\n                if (pattern_shift_reg == 4'b1101)\n                    next_state = SHIFT_DATA;\n            end\n            SHIFT_DATA: begin\n                if (shift_counter == 4)\n                    next_state = COUNT;\n            end\n            COUNT: begin\n                if (done_counting)\n                    next_state = NOTIFY;\n            end\n            NOTIFY: begin\n                if (ack)\n                    next_state = WAIT_ACK;\n                else\n                    next_state = NOTIFY;\n            end\n            WAIT_ACK: begin\n                if (!ack)\n                    next_state = IDLE; // Release after acknowledgement\n            end\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n        end else begin\n            // Default outputs\n            shift_ena <= 0;\n            counting <= 0;\n            done <= 0;\n\n            case (current_state)\n                CHECK_PATTERN: begin\n                    pattern_shift_reg <= {pattern_shift_reg[2:0], data};\n                end\n                SHIFT_DATA: begin\n                    shift_ena <= 1;\n                    shift_counter <= shift_counter + 1;\n                end\n                COUNT: begin\n                    counting <= 1;\n                end\n                NOTIFY: begin\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Initialize and reset counters\n    always @(posedge clk) begin\n        if (current_state == IDLE || reset) begin\n            pattern_shift_reg <= 0;\n            shift_counter <= 0;\n        end else if (current_state == SHIFT_DATA && next_state != SHIFT_DATA) begin\n            shift_counter <= 0; // Reset counter when leaving shift data state\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // Define state encoding\n    typedef enum logic [3:0] {\n        IDLE = 4'b0000,\n        CHECK_PATTERN = 4'b0001,\n        SHIFT = 4'b0010,\n        COUNT = 4'b0100,\n        WAIT_DONE = 4'b1000,\n        NOTIFY_USER = 4'b1001,\n        WAIT_ACK = 4'b1010\n    } state_t;\n\n    // State registers\n    state_t state, next_state;\n\n    // Pattern matching for 1101\n    reg [3:0] shift_reg;\n\n    // Shift count for enabling shifting 4 times\n    integer shift_count;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            shift_reg <= 4'b0000;\n            shift_count <= 0;\n        end else begin\n            state <= next_state;\n            shift_reg <= (state == CHECK_PATTERN) ? {shift_reg[2:0], data} : shift_reg;\n            shift_count <= (state == SHIFT) ? shift_count + 1 : 0;\n        end\n    end\n\n    // Combinational logic for next state logic and outputs\n    always @(*) begin\n        // Default outputs\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (state)\n            IDLE: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT;\n                end else begin\n                    next_state = CHECK_PATTERN;\n                end\n            end\n            CHECK_PATTERN: begin\n                if (shift_reg == 4'b1101) begin\n                    next_state = SHIFT;\n                end else begin\n                    next_state = CHECK_PATTERN;\n                end\n            end\n            SHIFT: begin\n                shift_ena = 1'b1;\n                if (shift_count >= 3) begin\n                    next_state = COUNT;\n                end else begin\n                    next_state = SHIFT;\n                end\n            end\n            COUNT: begin\n                counting = 1'b1;\n                if (done_counting) begin\n                    next_state = NOTIFY_USER;\n                end else begin\n                    next_state = COUNT;\n                end\n            end\n            NOTIFY_USER: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WAIT_ACK;\n                end\n            end\n            WAIT_ACK: begin\n                done = 1'b1;\n                if (ack) begin\n                    next_state = IDLE;\n                end else begin\n                    next_state = WAIT_ACK;\n                end\n            end\n            default: next_state = IDLE;\n        endcase\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n// State declaration\ntypedef enum reg [2:0] {\n    IDLE,\n    CHECK_PATTERN,\n    SHIFT_DATA,\n    COUNT,\n    NOTIFY,\n    WAIT_ACK\n} state_t;\n\n// Internal signals\nreg [3:0] shift_reg;\nreg [2:0] bit_count;\nstate_t current_state, next_state;\n\n// State Transition\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= IDLE;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic and output logic\nalways @(*) begin\n    // Default assignments to avoid latches\n    shift_ena = 1'b0;\n    counting = 1'b0;\n    done = 1'b0;\n    next_state = current_state; // Default to stay in current state unless conditions to transition are met\n\n    case (current_state)\n        IDLE: begin\n            if (data == 1'b1) begin // Start detecting pattern\n                next_state = CHECK_PATTERN;\n                shift_reg = 4'b1101; // Start checking for the pattern 1101\n            end\n        end\n        CHECK_PATTERN: begin\n            if (shift_reg == 4'b1101) begin\n                next_state = SHIFT_DATA;\n                bit_count = 0; // Reset bit counter for shifting\n            end else begin\n                shift_reg = {shift_reg[2:0], data}; // Shift in new data bit\n            end\n        end\n        SHIFT_DATA: begin\n            shift_ena = 1'b1;\n            bit_count = bit_count + 1;\n            if (bit_count == 4) begin // After shifting 4 bits\n                next_state = COUNT;\n                counting = 1'b1;\n            end\n        end\n        COUNT: begin\n            if (done_counting) begin\n                next_state = NOTIFY;\n                done = 1'b1;\n            end\n        end\n        NOTIFY: begin\n            if (ack) begin\n                next_state = WAIT_ACK;\n            end\n        end\n        WAIT_ACK: begin\n            if (!ack) begin // Once ack goes low, ready to detect new pattern\n                next_state = IDLE;\n            end\n        end\n        default: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack\n);\n\n    // State encoding\n    typedef enum int {\n        IDLE,               // Waiting for pattern 1101\n        CHECK_PATTERN,      // Checking pattern\n        SHIFT_BITS,         // Shifting 4 bits\n        WAIT_COUNTERS,      // Waiting for counters to finish\n        NOTIFY_USER,        // Notify user\n        WAIT_ACK            // Wait for user acknowledgment\n    } state_t;\n\n    // State variable\n    reg [2:0] current_state, next_state;\n\n    // Shift register to detect the pattern 1101\n    reg [3:0] shift_reg;\n\n    // Counter for the number of bits shifted after pattern is detected\n    reg [2:0] bit_counter;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            shift_reg <= 4'b0000;\n            bit_counter <= 3'b000;\n        end else begin\n            current_state <= next_state;\n            if (current_state == CHECK_PATTERN || current_state == IDLE)\n                shift_reg <= {shift_reg[2:0], data};\n            if (current_state == SHIFT_BITS)\n                bit_counter <= bit_counter + 1;\n            else\n                bit_counter <= 3'b000;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (shift_reg == 4'b1101)\n                    next_state = SHIFT_BITS;\n                else\n                    next_state = IDLE;\n            end\n            SHIFT_BITS: begin\n                if (bit_counter == 3'b100)\n                    next_state = WAIT_COUNTERS;\n                else\n                    next_state = SHIFT_BITS;\n            end\n            WAIT_COUNTERS: begin\n                if (done_counting)\n                    next_state = NOTIFY_USER;\n                else\n                    next_state = WAIT_COUNTERS;\n            end\n            NOTIFY_USER: begin\n                if (ack)\n                    next_state = IDLE;\n                else\n                    next_state = NOTIFY_USER;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        shift_ena = 1'b0;\n        counting = 1'b0;\n        done = 1'b0;\n\n        case (current_state)\n            SHIFT_BITS: begin\n                shift_ena = 1'b1;\n            end\n            WAIT_COUNTERS: begin\n                counting = 1'b1;\n            end\n            NOTIFY_USER: begin\n                done = 1'b1;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "lemmings3", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // Define states\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               DIGGING = 2'b10,\n               FALLING = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Synchronous state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_left || bump_right)\n                    next_state = DIGGING; // maintain digging despite bumps\n                else\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n            end\n\n            FALLING: begin\n                if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALLING;\n            end\n\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALLING);\n        digging = (state == DIGGING);\n    end\n\n    // Ensure opposite flags are not high at the same time\n    always @(*) begin\n        if (walk_left)\n            walk_right = 0;\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    parameter WALK_LEFT = 2'b00;\n    parameter WALK_RIGHT = 2'b01;\n    parameter FALL = 2'b10;\n    parameter DIG = 2'b11;\n\n    // State and next state variables\n    reg [1:0] state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (next_state == WALK_LEFT || next_state == FALL) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (ground && !dig)\n                    next_state = (next_state == WALK_LEFT || next_state == FALL) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = DIG;\n            end\n            default: next_state = WALK_LEFT; // Default to WALK_LEFT on undefined states\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n            DIG: begin\n                digging = 1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n    reg [1:0] state, next_state;\n\n    // Falling edge detection for ground\n    reg ground_prev;\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            ground_prev <= 1;\n        end else begin\n            ground_prev <= ground;\n        end\n    end\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig && ground)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig && ground)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (ground_prev == 0) ? (walk_left ? WALK_LEFT : WALK_RIGHT) : FALL;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            walk_left <= 1;\n            walk_right <= 0;\n            aaah <= 0;\n            digging <= 0;\n        end else begin\n            walk_left <= (state == WALK_LEFT);\n            walk_right <= (state == WALK_RIGHT);\n            aaah <= (state == FALL);\n            digging <= (state == DIG);\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n    // State encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               DIGGING = 2'b10,\n               FALLING = 2'b11;\n\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT; // Reset to walking left\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (dig) begin\n                    next_state = DIGGING;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            DIGGING: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else begin\n                    next_state = DIGGING;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic based on state\n    always @(posedge clk) begin\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n                digging = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n                digging = 0;\n            end\n            DIGGING: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n                digging = 1;\n            end\n            FALLING: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n                digging = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n    \n    // State encoding\n    parameter WALK_LEFT = 2'b00,\n              WALK_RIGHT = 2'b01,\n              DIGGING = 2'b10,\n              FALLING = 2'b11;\n              \n    reg [1:0] state, next_state;\n    reg last_direction_left; // Keeps track of the direction before falling or digging\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            last_direction_left <= 1;\n        end else begin\n            state <= next_state;\n            if (state == WALK_LEFT || state == WALK_RIGHT)\n                last_direction_left <= (state == WALK_LEFT);\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT, WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (dig)\n                    next_state = DIGGING;\n                else if ((bump_left && !bump_right) || (bump_right && !bump_left))\n                    next_state = (state == WALK_LEFT) ? WALK_RIGHT : WALK_LEFT;\n                else\n                    next_state = state;\n            end\n            DIGGING: begin\n                if (!ground)\n                    next_state = FALLING;\n                else\n                    next_state = DIGGING;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = last_direction_left ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALLING;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALLING);\n        digging = (state == DIGGING);\n    end\n    \nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    parameter WALK_LEFT = 2'b00, WALK_RIGHT = 2'b01, FALL = 2'b10, DIG = 2'b11;\n\n    // Current and Next State Variables\n    reg [1:0] current_state, next_state;\n\n    // State Transition and Output Logic (Moore Machine)\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_right) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALL;\n                else if (dig) next_state = DIG;\n                else if (bump_left) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground) begin\n                    if (next_state == WALK_LEFT || next_state == DIG) next_state = WALK_LEFT;\n                    else next_state = WALK_RIGHT;\n                end else next_state = FALL;\n            end\n            DIG: begin\n                if (!ground) next_state = FALL;\n                else next_state = DIG;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        // Reset outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n        \n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n            DIG: begin\n                digging = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State declarations\n    typedef enum {WALK_LEFT, WALK_RIGHT, FALL, DIG} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if(areset)\n            current_state <= WALK_LEFT;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(current_state)\n            WALK_LEFT: begin\n                if(!ground)\n                    next_state = FALL;\n                else if(dig)\n                    next_state = DIG;\n                else if(bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if(!ground)\n                    next_state = FALL;\n                else if(dig)\n                    next_state = DIG;\n                else if(bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if(ground)\n                    next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if(!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default output values\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case(current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n            DIG: begin\n                digging = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // Define the state encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10,\n               DIG = 2'b11;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n            default: begin\n                next_state = WALK_LEFT;\n            end\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL);\n        digging = (state == DIG);\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10,\n               DIG = 2'b11;\n\n    reg [1:0] state, next_state;\n    reg previous_ground; // Tracks ground status in the previous cycle\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n            previous_ground <= 1'b1; // Assume starting on the ground\n        end else begin\n            state <= next_state;\n            previous_ground <= ground;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig && ground && !previous_ground)\n                    next_state = DIG;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (dig && ground && !previous_ground)\n                    next_state = DIG;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (previous_ground == WALK_LEFT) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n            DIG: begin\n                if (!ground)\n                    next_state = FALL;\n                else\n                    next_state = DIG;\n            end\n            default: next_state = WALK_LEFT; // Default to walking left\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        // Reset all outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n            DIG: begin\n                digging = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    input dig,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah,\n    output reg digging\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALLING = 2'b10,\n               DIGGING = 2'b11;\n\n    // State and next state variable\n    reg [1:0] state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT; // Asynchronously reset to walking left\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_left) next_state = WALK_RIGHT;\n                else next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground) next_state = FALLING;\n                else if (dig) next_state = DIGGING;\n                else if (bump_right) next_state = WALK_LEFT;\n                else next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground) next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                else next_state = FALLING;\n            end\n            DIGGING: begin\n                if (!ground) next_state = FALLING;\n                else next_state = DIGGING;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic based on the state\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        digging = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALLING: begin\n                aaah = 1;\n            end\n            DIGGING: begin\n                digging = 1;\n                if (walk_left) walk_left = 1;\n                else walk_right = 1;\n            end\n        endcase\n    end\nendmodule\n"]}
{"task_id": "count_clock", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // BCD Increments for seconds, minutes, and hours\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00:00 AM\n            ss <= 8'b00000000;\n            mm <= 8'b00000000;\n            hh <= 8'b00010010;\n            pm <= 1'b0;\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b01011001) begin // 59 seconds\n                ss <= 8'b00000000; // Reset seconds to 00\n                // Increment minutes\n                if (mm == 8'b01011001) begin // 59 minutes\n                    mm <= 8'b00000000; // Reset minutes to 00\n                    // Increment hours\n                    if (hh == 8'b00010010) begin // 12 hours\n                        hh <= 8'b00000001; // Reset hours to 01\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'b00001001) begin // 09 hours\n                        hh <= 8'b00010000; // Increment hours to 10 (BCD)\n                    end else begin\n                        hh <= hh + 1'b1; // Increment hours\n                    end\n                end else if (mm[3:0] == 4'b1001) begin // x9 minutes\n                    mm[3:0] <= 4'b0000; // Reset lower nibble of minutes\n                    mm[7:4] <= mm[7:4] + 1'b1; // Increment upper nibble of minutes\n                end else begin\n                    mm <= mm + 1'b1; // Increment minutes\n                end\n            end else if (ss[3:0] == 4'b1001) begin // x9 seconds\n                ss[3:0] <= 4'b0000; // Reset lower nibble of seconds\n                ss[7:4] <= ss[7:4] + 1'b1; // Increment upper nibble of seconds\n            end else begin\n                ss <= ss + 1'b1; // Increment seconds\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            if (ss == 8'h59) begin\n                ss <= 8'h00;\n                if (mm == 8'h59) begin\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM at the transition of 12:59:59 to 01:00:00\n                    end else if (hh == 8'h11) begin\n                        hh <= 8'h12;\n                    end else begin\n                        hh <= hh + 8'h01;\n                    end\n                end else begin\n                    mm <= mm + 8'h01;\n                end\n            end else begin\n                ss <= ss + 8'h01;\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n    // Reset values for hours, minutes, and seconds\n    parameter RESET_HH = 8'b00010010; // 12 in BCD\n    parameter RESET_MM = 8'b00000000; // 00 in BCD\n    parameter RESET_SS = 8'b00000000; // 00 in BCD\n\n    // Incrementing BCD numbers\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= RESET_HH; \n            mm <= RESET_MM;\n            ss <= RESET_SS;\n            pm <= 0; // AM\n        end\n        else if (ena) begin\n            if (ss == 8'b01011001) begin // 59 in BCD for seconds\n                ss <= 0;\n                if (mm == 8'b01011001) begin // 59 in BCD for minutes\n                    mm <= 0;\n                    if (hh == 8'b00010010) begin // 12 in BCD for hours\n                        hh <= 8'b00000001; // Reset to 01 in BCD\n                        pm <= ~pm; // Toggle AM/PM\n                    end else if (hh == 8'b00010001 && pm) begin // 11 PM\n                        hh <= 8'b00010010; // Increment to 12\n                    end else begin\n                        // Increment hours\n                        if (hh[3:0] == 4'b1001) begin // If lower digit of hours is 9\n                            hh[3:0] <= 4'b0000; // Reset to 0\n                            hh[7:4] <= hh[7:4] + 1'b1; // Increment upper digit\n                        end else begin\n                            hh[3:0] <= hh[3:0] + 1'b1; // Increment lower digit\n                        end\n                    end\n                end else begin\n                    // Increment minutes\n                    if (mm[3:0] == 4'b1001) begin // If lower digit of minutes is 9\n                        mm[3:0] <= 4'b0000; // Reset to 0\n                        mm[7:4] <= mm[7:4] + 1'b1; // Increment upper digit\n                    end else begin\n                        mm[3:0] <= mm[3:0] + 1'b1; // Increment lower digit\n                    end\n                end\n            end else begin\n                // Increment seconds\n                if (ss[3:0] == 4'b1001) begin // If lower digit of seconds is 9\n                    ss[3:0] <= 4'b0000; // Reset to 0\n                    ss[7:4] <= ss[7:4] + 1'b1; // Increment upper digit\n                end else begin\n                    ss[3:0] <= ss[3:0] + 1'b1; // Increment lower digit\n                end\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Increment the seconds\n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'b00000000; // Reset seconds to 00\n            mm <= 8'b00000000; // Reset minutes to 00\n            hh <= 8'b00010010; // Reset hours to 12\n            pm <= 1'b0;        // AM\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'b01011001) begin // if 59 seconds\n                ss <= 8'b00000000; // reset seconds to 00\n                // Increment minutes\n                if (mm == 8'b01011001) begin // if 59 minutes\n                    mm <= 8'b00000000; // reset minutes to 00\n                    // Increment hours\n                    if (hh == 8'b00010010) begin // if 12 hours\n                        hh <= 8'b00000001; // reset hours to 01\n                        pm <= ~pm; // toggle AM/PM\n                    end else if (hh[3:0] == 4'b1001) begin\n                        hh[3:0] <= 4'b0000; // reset lower nibble\n                        hh[7:4] <= hh[7:4] + 1; // increment upper nibble\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1; // increment lower nibble\n                    end\n                end else if (mm[3:0] == 4'b1001) begin\n                    mm[3:0] <= 4'b0000; // reset lower nibble\n                    mm[7:4] <= mm[7:4] + 1; // increment upper nibble\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1; // increment lower nibble\n                end\n            end else if (ss[3:0] == 4'b1001) begin\n                ss[3:0] <= 4'b0000; // reset lower nibble\n                ss[7:4] <= ss[7:4] + 1; // increment upper nibble\n            end else begin\n                ss[3:0] <= ss[3:0] + 1; // increment lower nibble\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Increment seconds\n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'b00000000;  // Reset to 00\n            mm <= 8'b00000000;  // Reset to 00\n            hh <= 8'b00010010;  // Reset to 12\n            pm <= 1'b0;         // AM\n        end else if (ena) begin\n            if (ss == 8'b01011001) begin  // 59 seconds\n                ss <= 8'b00000000;  // Reset seconds to 00\n                if (mm == 8'b01011001) begin  // 59 minutes\n                    mm <= 8'b00000000;  // Reset minutes to 00\n                    if (hh == 8'b00010010) begin  // 12 hours\n                        hh <= 8'b00000001;  // Reset hours to 01\n                        pm <= ~pm;  // Toggle AM/PM\n                    end else if (hh == 8'b00001001) begin  // 09 hours\n                        hh <= hh + 8'b00000011;  // Increment to 12\n                    end else begin\n                        hh <= hh + 8'b00000001;  // Increment hours\n                    end\n                end else begin\n                    mm <= mm + 8'b00000001;  // Increment minutes\n                end\n            end else begin\n                ss <= ss + 8'b00000001;  // Increment seconds\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Increment seconds\n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'b00000000;  // Reset seconds to 00\n            mm <= 8'b00000000;  // Reset minutes to 00\n            hh <= 8'b00010010;  // Reset hours to 12\n            pm <= 1'b0;         // AM\n        end\n        else if (ena) begin\n            if (ss == 8'b01011001) begin  // if seconds = 59\n                ss <= 8'b00000000;       // reset seconds to 00\n                if (mm == 8'b01011001) begin  // if minutes = 59\n                    mm <= 8'b00000000;       // reset minutes to 00\n                    if (hh == 8'b00010010) begin  // if hours = 12\n                        hh <= 8'b00000001;       // reset hours to 01\n                        pm <= ~pm;               // toggle AM/PM\n                    end\n                    else if (hh == 8'b00001001) begin  // if hours = 09\n                        hh <= 8'b00011010;            // increment hours to 10\n                    end\n                    else if (hh == 8'b00011010) begin  // if hours = 10\n                        hh <= 8'b00011011;            // increment hours to 11\n                    end\n                    else if (hh == 8'b00011011) begin  // if hours = 11\n                        hh <= 8'b00010010;            // increment hours to 12\n                    end\n                    else begin\n                        hh <= hh + 8'b00000001;  // increment hours\n                    end\n                }\n                else if (mm[3:0] == 4'b1001) begin\n                    mm[3:0] <= 4'b0000;       // reset lower nibble of minutes\n                    mm[7:4] <= mm[7:4] + 4'b0001;  // increment upper nibble of minutes\n                }\n                else begin\n                    mm <= mm + 8'b00000001;  // increment minutes\n                end\n            }\n            else if (ss[3:0] == 4'b1001) begin\n                ss[3:0] <= 4'b0000;       // reset lower nibble of seconds\n                ss[7:4] <= ss[7:4] + 4'b0001;  // increment upper nibble of seconds\n            }\n            else begin\n                ss <= ss + 8'b00000001;  // increment seconds\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Increment seconds\n    always @(posedge clk) begin\n        if (reset) begin\n            ss <= 8'b00000000;  // Reset seconds to 00\n            mm <= 8'b00000000;  // Reset minutes to 00\n            hh <= 8'b00010010;  // Reset hours to 12\n            pm <= 1'b0;         // AM\n        end else if (ena) begin\n            if (ss == 8'b01011001) begin  // If seconds are 59\n                ss <= 8'b00000000;  // Reset seconds to 00\n                if (mm == 8'b01011001) begin  // If minutes are 59\n                    mm <= 8'b00000000;  // Reset minutes to 00\n                    if (hh == 8'b00010010) begin  // If hours are 12\n                        hh <= 8'b00000001;  // Reset hours to 01\n                        pm <= ~pm;  // Toggle AM/PM\n                    end else if (hh == 8'b00010001) begin  // If hours are 11\n                        hh <= 8'b00010010;  // Increment hours to 12\n                    end else begin\n                        hh[3:0] <= hh[3:0] + 1;  // Increment hours BCD lower nibble\n                        if (hh[3:0] == 4'b1001) begin\n                            hh[3:0] <= 4'b0000;\n                            hh[7:4] <= hh[7:4] + 1;  // Increment hours BCD upper nibble\n                        end\n                    end\n                end else begin\n                    mm[3:0] <= mm[3:0] + 1;  // Increment minutes BCD lower nibble\n                    if (mm[3:0] == 4'b1001) begin\n                        mm[3:0] <= 4'b0000;\n                        mm[7:4] <= mm[7:4] + 1;  // Increment minutes BCD upper nibble\n                    end\n                end\n            end else begin\n                ss[3:0] <= ss[3:0] + 1;  // Increment seconds BCD lower nibble\n                if (ss[3:0] == 4'b1001) begin\n                    ss[3:0] <= 4'b0000;\n                    ss[7:4] <= ss[7:4] + 1;  // Increment seconds BCD upper nibble\n                end\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset to 12:00 AM\n        hh <= 8'h12;\n        mm <= 8'h00;\n        ss <= 8'h00;\n        pm <= 1'b0;\n    end\n    else if (ena) begin\n        // Increment seconds\n        if (ss == 8'h59) begin\n            ss <= 8'h00;\n            // Increment minutes\n            if (mm == 8'h59) begin\n                mm <= 8'h00;\n                // Increment hours\n                if (hh == 8'h12) begin\n                    hh <= 8'h01;\n                    pm <= ~pm; // Toggle AM/PM at the transition from 11:59:59 PM to 12:00:00 AM\n                end else if (hh == 8'h09) begin\n                    hh <= 8'h10; // Transition from 09 to 10, special case for BCD\n                end else if (hh == 8'h19) begin\n                    hh <= 8'h20; // Transition from 19 to 20, special case for BCD\n                end else begin\n                    hh <= hh + 1'b1;\n                end\n            end else if (mm == 8'h09) begin\n                mm <= 8'h10; // Increment from 09 to 10, special case for BCD\n            end else if (mm == 8'h19) begin\n                mm <= 8'h20; // Increment from 19 to 20, special case for BCD\n            end else if (mm == 8'h29) begin\n                mm <= 8'h30; // Increment from 29 to 30, special case for BCD\n            end else if (mm == 8'h39) begin\n                mm <= 8'h40; // Increment from 39 to 40, special case for BCD\n            end else if (mm == 8'h49) begin\n                mm <= 8'h50; // Increment from 49 to 50, special case for BCD\n            end else if (mm == 8'h59) begin\n                mm <= 8'h00; // Increment from 59 to 00, complete increment for minutes\n            end else begin\n                mm <= mm + 1'b1;\n            end\n        end else if (ss == 8'h09) begin\n            ss <= 8'h10; // Increment from 09 to 10, special case for BCD\n        end else if (ss == 8'h19) begin\n            ss <= 8'h20; // Increment from 19 to 20, special case for BCD\n        end else if (ss == 8'h29) begin\n            ss <= 8'h30; // Increment from 29 to 30, special case for BCD\n        end else if (ss == 8'h39) begin\n            ss <= 8'h40; // Increment from 39 to 40, special case for BCD\n        end else if (ss == 8'h49) begin\n            ss <= 8'h50; // Increment from 49 to 50, special case for BCD\n        end else begin\n            ss <= ss + 1'b1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Use two BCD digits for hh, mm, ss\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            hh <= 8'h12; // 12 in BCD\n            mm <= 8'h00; // 00 in BCD\n            ss <= 8'h00; // 00 in BCD\n            pm <= 1'b0;  // AM\n        end\n        else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin\n                ss <= 8'h00; // Reset seconds and increment minutes\n                if (mm == 8'h59) begin\n                    mm <= 8'h00; // Reset minutes and increment hours\n                    if (hh == 8'h12) begin\n                        hh <= 8'h01; // Reset hours to 1\n                        pm <= ~pm;  // Toggle AM/PM\n                    end else if (hh == 8'h09) begin\n                        hh <= 8'h10; // Increment to 10 from 09\n                    end else begin\n                        hh <= hh + 8'h01; // Increment hours\n                    end\n                end else if (mm == 8'h09 || ((mm & 8'h0F) == 8'h09 && mm != 8'h09)) begin\n                    mm <= mm + 8'h07; // Increment minute from 9 to 10, or 19 to 20, etc.\n                end else begin\n                    mm <= mm + 8'h01; // Increment minutes\n                end\n            end else if (ss == 8'h09 || ((ss & 8'h0F) == 8'h09 && ss != 8'h09)) begin\n                ss <= ss + 8'h07; // Increment second from 9 to 10, or 19 to 20, etc.\n            end else begin\n                ss <= ss + 8'h01; // Increment seconds\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input ena,\n    output reg pm,\n    output reg [7:0] hh,\n    output reg [7:0] mm,\n    output reg [7:0] ss\n);\n\n    // Initial conditions\n    initial begin\n        pm = 0;\n        hh = 8'h12; // 12:00 AM\n        mm = 8'h00;\n        ss = 8'h00;\n    end\n\n    // Handle clock and reset logic\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset to 12:00 AM\n            pm <= 0;\n            hh <= 8'h12;\n            mm <= 8'h00;\n            ss <= 8'h00;\n        end else if (ena) begin\n            // Increment seconds\n            if (ss == 8'h59) begin // if seconds are 59, reset to 00 and increment minutes\n                ss <= 8'h00;\n                if (mm == 8'h59) begin // if minutes are also 59, reset to 00 and increment hour\n                    mm <= 8'h00;\n                    if (hh == 8'h12) begin // if hours are 12, reset to 01\n                        hh <= 8'h01;\n                        pm <= ~pm; // Toggle AM/PM at the transition of 12:00\n                    end else if (hh == 8'h09) begin\n                        hh <= 8'h10; // Handle BCD increment for the hour tens\n                    end else if (hh[3:0] == 4'h9) begin\n                        hh[3:0] <= 4'h0;\n                        hh[7:4] <= hh[7:4] + 1;\n                    end else begin\n                        hh = hh + 1; // Normal increment\n                    end\n                end else if (mm[3:0] == 4'h9) begin\n                    mm[3:0] <= 4'h0;\n                    mm[7:4] <= mm[7:4] + 1;\n                end else begin\n                    mm = mm + 1; // Normal increment\n                end\n            end else if (ss[3:0] == 4'h9) begin\n                ss[3:0] <= 4'h0;\n                ss[7:4] <= ss[7:4] + 1;\n            end else begin\n                ss = ss + 1; // Normal increment\n            end\n        end\n    end\n\nendmodule\n"]}
{"task_id": "lemmings2", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State encoding\n    localparam WALK_LEFT = 2'b00;\n    localparam WALK_RIGHT = 2'b01;\n    localparam FALLING = 2'b10;\n\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALLING: begin\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n            default: next_state = WALK_LEFT; // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALLING);\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // Define states\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10;\n\n    // State and next state variables\n    reg [1:0] state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if(areset) begin\n            state <= WALK_LEFT;\n        end\n        else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end \n                else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end \n                else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end \n                else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end \n                else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            FALL: begin\n                if (ground) begin\n                    // Resume previous direction when falling stops\n                    next_state = (walk_left ? WALK_LEFT : WALK_RIGHT);\n                end \n                else begin\n                    next_state = FALL;\n                end\n            end\n\n            default: begin\n                next_state = WALK_LEFT;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        walk_left = (state == WALK_LEFT);\n        walk_right = (state == WALK_RIGHT);\n        aaah = (state == FALL);\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // Define the states as parameters for readability\n    parameter WALK_LEFT = 2'b00,\n              WALK_RIGHT = 2'b01,\n              FALL = 2'b10;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Asynchronous reset and synchronous state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= WALK_LEFT;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            FALL: begin\n                if (ground) begin\n                    // Continue walking in the previous direction before falling\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALL;\n                end\n            end\n\n            default: next_state = WALK_LEFT; // Default safe state\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        // Reset outputs\n        walk_left <= 0;\n        walk_right <= 0;\n        aaah <= 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left <= 1;\n            end\n            WALK_RIGHT: begin\n                walk_right <= 1;\n            end\n            FALL: begin\n                aaah <= 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // Define state encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10;\n\n    // State and next state variable\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        // Default output\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n        next_state = state;\n\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALL;\n                end else if (bump_left) begin\n                    walk_right = 1;\n                    next_state = WALK_RIGHT;\n                end else begin\n                    walk_left = 1;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    aaah = 1;\n                    next_state = FALL;\n                end else if (bump_right) begin\n                    walk_left = 1;\n                    next_state = WALK_LEFT;\n                end else begin\n                    walk_right = 1;\n                end\n            end\n            FALL: begin\n                aaah = 1;\n                if (ground) begin\n                    if (walk_left) begin\n                        next_state = WALK_LEFT;\n                        walk_left = 1;\n                    end else begin\n                        next_state = WALK_RIGHT;\n                        walk_right = 1;\n                    end\n                end\n            end\n        endcase\n    end\n\n    // Output logic for falling state\n    always @(state) begin\n        if (state != FALL) begin\n            aaah = 0;\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALLING = 2'b10;\n\n    // State and next state variable declaration\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALLING;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n\n            FALLING: begin\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALLING;\n                end\n            end\n\n            default: begin\n                next_state = WALK_LEFT; // Default to a safe state\n            end\n        endcase\n    end\n\n    // Output logic based on the state\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            walk_left <= 1;\n            walk_right <= 0;\n            aaah <= 0;\n        end else begin\n            case (state)\n                WALK_LEFT: begin\n                    walk_left <= 1;\n                    walk_right <= 0;\n                    aaah <= 0;\n                end\n\n                WALK_RIGHT: begin\n                    walk_left <= 0;\n                    walk_right <= 1;\n                    aaah <= 0;\n                end\n\n                FALLING: begin\n                    walk_left <= 0;\n                    walk_right <= 0;\n                    aaah <= 1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALLING = 2'b10;\n\n    // State and next state variables\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT; // Initial state on reset\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALLING;\n            end\n            default: next_state = WALK_LEFT; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n            end\n            FALLING: begin\n                aaah = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10;\n\n    // State variable\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end else if (bump_left) begin\n                    next_state = WALK_RIGHT;\n                end else begin\n                    next_state = WALK_LEFT;\n                end\n            end\n            WALK_RIGHT: begin\n                if (!ground) begin\n                    next_state = FALL;\n                end else if (bump_right) begin\n                    next_state = WALK_LEFT;\n                end else begin\n                    next_state = WALK_RIGHT;\n                end\n            end\n            FALL: begin\n                if (ground) begin\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                end else begin\n                    next_state = FALL;\n                end\n            end\n            default: begin\n                next_state = WALK_LEFT; // Safe state\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n            end\n            FALL: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n            default: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // Define the states\n    typedef enum {WALK_LEFT, WALK_RIGHT, FALL} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            current_state <= WALK_LEFT; // Asynchronous reset to WALK_LEFT\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                aaah = 0;\n            end\n            WALK_RIGHT: begin\n                walk_right = 1;\n                aaah = 0;\n            end\n            FALL: begin\n                aaah = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State Encoding\n    parameter WALKING_LEFT = 2'b00;\n    parameter WALKING_RIGHT = 2'b01;\n    parameter FALLING = 2'b10;\n\n    // State and Next State variables\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALKING_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALKING_LEFT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_left)\n                    next_state = WALKING_RIGHT;\n                else\n                    next_state = WALKING_LEFT;\n            end\n            WALKING_RIGHT: begin\n                if (!ground)\n                    next_state = FALLING;\n                else if (bump_right)\n                    next_state = WALKING_LEFT;\n                else\n                    next_state = WALKING_RIGHT;\n            end\n            FALLING: begin\n                if (ground)\n                    next_state = (aaah ? WALKING_LEFT : WALKING_RIGHT);  // Resume previous direction\n                else\n                    next_state = FALLING;\n            end\n            default: begin\n                next_state = WALKING_LEFT;\n            end\n        endcase\n    end\n\n    // Output logic based on state\n    always @(*) begin\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (state)\n            WALKING_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n            end\n            WALKING_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n            end\n            FALLING: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    input ground,\n    output reg walk_left,\n    output reg walk_right,\n    output reg aaah\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 2'b00,\n               WALK_RIGHT = 2'b01,\n               FALL = 2'b10;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Asynchronous reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (!ground)\n                    next_state = FALL;\n                else if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            FALL: begin\n                if (ground)\n                    next_state = (walk_left) ? WALK_LEFT : WALK_RIGHT;\n                else\n                    next_state = FALL;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // Default outputs\n        walk_left = 0;\n        walk_right = 0;\n        aaah = 0;\n\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n                aaah = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n                aaah = 0;\n            end\n            FALL: begin\n                walk_left = 0;\n                walk_right = 0;\n                aaah = 1;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q6b", "gptgen_RTL": ["module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case(y)\n            3'b000: // State A\n                Y2 = w ? 1'b0 : 1'b0;\n            3'b001: // State B\n                Y2 = w ? 1'b1 : 1'b1;\n            3'b010: // State C\n                Y2 = w ? 1'b1 : 1'b0;\n            3'b011: // State D\n                Y2 = w ? 1'b0 : 1'b0;\n            3'b100: // State E\n                Y2 = w ? 1'b1 : 1'b0;\n            3'b101: // State F\n                Y2 = w ? 1'b1 : 1'b0;\n            default:\n                Y2 = 1'bx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = 0; // A -> B (y = 001) or A -> A (y = 000), y[2] = 0 in both cases\n            3'b001: // State B\n                if (w)\n                    Y2 = 1; // B -> D (y = 011)\n                else\n                    Y2 = 0; // B -> C (y = 010)\n            3'b010: // State C\n                if (w)\n                    Y2 = 1; // C -> D (y = 011)\n                else\n                    Y2 = 0; // C -> E (y = 100)\n            3'b011: // State D\n                if (w)\n                    Y2 = 0; // D -> A (y = 000)\n                else\n                    Y2 = 1; // D -> F (y = 101)\n            3'b100: // State E\n                Y2 = 1; // E -> D (y = 011) or E -> E (y = 100), y[2] = 1 in both cases\n            3'b101: // State F\n                Y2 = 0; // F -> C (y = 010) or F -> D (y = 011), y[2] = 0 for C, 1 for D\n            default: // Default case to handle any unexpected values\n                Y2 = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case(y)\n            3'b000: begin // State A\n                if (w == 1'b1)\n                    Y2 = 1'b0; // Stays in A\n                else\n                    Y2 = 1'b0; // Goes to B\n            end\n            3'b001: begin // State B\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Goes to D\n                else\n                    Y2 = 1'b1; // Goes to C\n            end\n            3'b010: begin // State C\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Goes to D\n                else\n                    Y2 = 1'b0; // Goes to E\n            end\n            3'b011: begin // State D\n                if (w == 1'b1)\n                    Y2 = 1'b0; // Goes to A\n                else\n                    Y2 = 0; // Goes to F\n            end\n            3'b100: begin // State E\n                // E transitions only affect y[2] when going to D\n                Y2 = 1'b1; // Goes to D\n            end\n            3'b101: begin // State F\n                Y2 = 1'b1; // Goes to D\n            end\n            default: Y2 = 1'bx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b0; // Stay A or go to B\n\n            3'b001: // State B\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Go to D or C\n\n            3'b010: // State C\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Go to D or E\n\n            3'b011: // State D\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b1; // Go to A or F\n\n            3'b100: // State E\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Stay E or go to D\n\n            3'b101: // State F\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Go to D or C\n\n            default: // Default case to handle unused states\n                Y2 = 1'b0;\n        endcase\n    end\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = w ? 1'b0 : 1'b0; // A --0--> B (000 to 001), A --1--> A (000 to 000)\n            3'b001: // State B\n                Y2 = w ? 1'b1 : 1'b0; // B --0--> C (001 to 010), B --1--> D (001 to 011)\n            3'b010: // State C\n                Y2 = w ? 1'b1 : 1'b0; // C --0--> E (010 to 100), C --1--> D (010 to 011)\n            3'b011: // State D\n                Y2 = w ? 1'b0 : 1'b0; // D --0--> F (011 to 101), D --1--> A (011 to 000)\n            3'b100: // State E\n                Y2 = w ? 1'b1 : 1'b1; // E (1) --0--> E (100 to 100), E (1) --1--> D (100 to 011)\n            3'b101: // State F\n                Y2 = w ? 1'b1 : 1'b0; // F (1) --0--> C (101 to 010), F (1) --1--> D (101 to 011)\n            default: Y2 = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n    \n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = 1'b0; // Next state is either A or B which are 000 and 001 respectively (y[2] is 0 for both)\n                \n            3'b001: // State B\n                if (!w) Y2 = 1'b1; // Next state is C (010) if w is 0\n                else Y2 = 1'b0; // Next state is D (011) if w is 1\n                \n            3'b010: // State C\n                Y2 = w; // Next state is E (101) if w is 1 or D (011) if w is 0 (y[2] follows w)\n                \n            3'b011: // State D\n                if (!w) Y2 = 1'b1; // Next state is F (110) if w is 0\n                else Y2 = 1'b0; // Next state is A (000) if w is 1\n                \n            3'b101: // State E\n                Y2 = 1'b0; // Next state is E (101) or D (011), y[2] is 0 for both when w is 0 or 1 respectively\n                \n            3'b110: // State F\n                if (!w) Y2 = 1'b1; // Next state is C (010) if w is 0\n                else Y2 = 1'b0; // Next state is D (011) if w is 1\n                \n            default: Y2 = 1'bx; // Undefined state\n        endcase\n    end\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b0; // Stays in A or moves to B\n            3'b001: // State B\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b1; // Moves to D or C\n            3'b010: // State C\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Moves to D or E\n            3'b011: // State D\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b0; // Moves to A or F\n            3'b100: // State E\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0; // Stays in E or moves to D\n            3'b101: // State F\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b1; // Moves to D or C\n            default: \n                Y2 = 1'b0; // Default for undefined states\n        endcase\n    end\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b0;\n            3'b001: // State B\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0;\n            3'b010: // State C\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0;\n            3'b011: // State D\n                Y2 = (w == 1'b1) ? 1'b0 : 1'b1;\n            3'b100: // State E\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0;\n            3'b101: // State F\n                Y2 = (w == 1'b1) ? 1'b1 : 1'b0;\n            default: \n                Y2 = 1'bx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\n    always @(*) begin\n        case (y)\n            3'b000: // State A\n                if (w == 1'b1)\n                    Y2 = 1'b0; // Stay in A\n                else\n                    Y2 = 1'b0; // Go to B\n            3'b001: // State B\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Go to D\n                else\n                    Y2 = 1'b1; // Go to C\n            3'b010: // State C\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Go to D\n                else\n                    Y2 = 1'b0; // Go to E\n            3'b011: // State D\n                if (w == 1'b1)\n                    Y2 = 1'b0; // Go to A\n                else\n                    Y2 = 1'b1; // Go to F\n            3'b100: // State E\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Go to D\n                else\n                    Y2 = 1'b0; // Stay in E\n            3'b101: // State F\n                if (w == 1'b1)\n                    Y2 = 1'b1; // Go to D\n                else\n                    Y2 = 1'b0; // Go to C\n            default: Y2 = 1'bx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input [3:1] y,\n    input w,\n    output reg Y2\n);\n\nalways @(*) begin\n    case (y)\n        3'b000: // State A\n            Y2 = w ? 1'b0 : 1'b0; // A --0--> B (001), A --1--> A (000)\n        3'b001: // State B\n            Y2 = w ? 1'b1 : 1'b0; // B --0--> C (010), B --1--> D (011)\n        3'b010: // State C\n            Y2 = w ? 1'b1 : 1'b0; // C --0--> E (100), C --1--> D (011)\n        3'b011: // State D\n            Y2 = w ? 1'b0 : 1'b1; // D --0--> F (101), D --1--> A (000)\n        3'b100: // State E\n            Y2 = 1'b0; // E --0--> E (100), E --1--> D (011)\n        3'b101: // State F\n            Y2 = w ? 1'b1 : 1'b0; // F --0--> C (010), F --1--> D (011)\n        default: Y2 = 1'b0;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "ringer", "gptgen_RTL": ["module top_module(\n    input ring,\n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign motor = ring & vibrate_mode;\n    assign ringer = ring & ~vibrate_mode;\n\nendmodule\n", "module top_module(\n    input ring,\n    input vibrate_mode,\n    output reg ringer,\n    output reg motor\n);\n\nalways @(ring or vibrate_mode) begin\n    if (ring) begin\n        if (vibrate_mode) begin\n            ringer = 0;\n            motor = 1;\n        end else begin\n            ringer = 1;\n            motor = 0;\n        end\n    end else begin\n        ringer = 0;\n        motor = 0;\n    end\nend\n\nendmodule\n", "module top_module(\n    input ring,\n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\nassign ringer = ring & ~vibrate_mode;\nassign motor = ring & vibrate_mode;\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign motor = ring & vibrate_mode; // Motor should be on when there is a ring and the vibrate mode is active\n    assign ringer = ring & ~vibrate_mode; // Ringer should be on when there is a ring and the vibrate mode is not active\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n// Assign the outputs based on the condition\nassign motor = ring & vibrate_mode;  // Motor is on if there is a ring and vibrate_mode is active\nassign ringer = ring & ~vibrate_mode; // Ringer is on if there is a ring and vibrate_mode is not active\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output reg ringer,\n    output reg motor\n);\n\nalways @(*) begin\n    if (ring) begin\n        if (vibrate_mode) begin\n            motor = 1;\n            ringer = 0;\n        end\n        else begin\n            motor = 0;\n            ringer = 1;\n        end\n    end\n    else begin\n        motor = 0;\n        ringer = 0;\n    end\nend\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output reg ringer,\n    output reg motor\n);\n\nalways @(*) begin\n    if (ring) begin\n        if (vibrate_mode) begin\n            ringer = 0;\n            motor = 1;\n        end else begin\n            ringer = 1;\n            motor = 0;\n        end\n    end else begin\n        ringer = 0;\n        motor = 0;\n    end\nend\n\nendmodule\n", "module top_module(\n    input ring,\n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n// Logic to control ringer and motor based on ring and vibrate_mode inputs\nassign motor = ring & vibrate_mode;\nassign ringer = ring & ~vibrate_mode;\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n// Use combinational logic to decide the outputs based on inputs\nassign motor = ring & vibrate_mode;  // Motor is on when there is a ring and the phone is in vibrate mode\nassign ringer = ring & ~vibrate_mode; // Ringer is on when there is a ring and the phone is not in vibrate mode\n\nendmodule\n", "module top_module(\n    input ring, \n    input vibrate_mode,\n    output ringer,\n    output motor\n);\n\n    assign motor = ring & vibrate_mode; // Motor is on only when there is a ring and the vibrate_mode is active\n    assign ringer = ring & ~vibrate_mode; // Ringer is on only when there is a ring and the vibrate_mode is not active\n\nendmodule\n"]}
{"task_id": "alwaysblock1", "gptgen_RTL": ["module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement for implementing AND gate\nassign out_assign = a & b;\n\n// Using combinational always block for implementing AND gate\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement for combinational logic\nassign out_assign = a & b;\n\n// Using combinational always block\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement to create AND gate\nassign out_assign = a & b;\n\n// Using combinational always block to create AND gate\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement\nassign out_assign = a & b;\n\n// Using combinational always block\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement for combinational logic\nassign out_assign = a & b;\n\n// Using always block for combinational logic\nalways @(*) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement for combinational logic\nassign out_assign = a & b;\n\n// Using always block for combinational logic\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using an assign statement for the AND gate \nassign out_assign = a & b;\n\n// Using a combinational always block for the AND gate\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement for AND operation\nassign out_assign = a & b;\n\n// Using combinational always block for AND operation\nalways @ (a or b)\n    out_alwaysblock = a & b;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement to model the AND gate\nassign out_assign = a & b;\n\n// Using combinational always block to model the AND gate\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out_assign,\n    output reg out_alwaysblock\n);\n\n// Using assign statement to implement AND gate\nassign out_assign = a & b;\n\n// Using combinational always block to implement AND gate\nalways @ (a or b) begin\n    out_alwaysblock = a & b;\nend\n\nendmodule\n"]}
{"task_id": "zero", "gptgen_RTL": ["module top_module(\n    output zero\n);\n\nassign zero = 0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n    );\n\n    assign zero = 0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\n    assign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n", "module top_module(\n    output zero\n);\n\nassign zero = 1'b0;\n\nendmodule\n"]}
{"task_id": "circuit7", "gptgen_RTL": ["module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n    always @(posedge clk) begin\n        if (a == 1'b1)\n            q <= ~q;\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= ~q;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= ~q;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (a) \n        q <= ~q;\n    else \n        q <= q;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (a) begin\n        q <= ~q;\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\n    always @(posedge clk) begin\n        if (a)\n            q <= ~q;\n        else\n            q <= q;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n    // Flip-flop to store previous value of `a`\n    reg prev_a;\n\n    always @(posedge clk) begin\n        if (a && !prev_a)  // Detecting rising edge of `a`\n            q <= ~q;       // Toggle q on the rising edge of `a`\n        else\n            q <= q;        // Retain the previous state\n\n        prev_a <= a;       // Update previous state of `a`\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (a) begin\n        q <= 0;\n    end\n    else begin\n        q <= 1;\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (a)\n        q <= ~q;\n    else\n        q <= q;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    output reg q\n);\n    always @(posedge clk) begin\n        if (a) begin\n            q <= ~q;\n        end\n    end\nendmodule\n"]}
{"task_id": "ece241_2014_q5a", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State Declaration\n    reg state;\n    reg first_one_found;\n\n    // State Encoding\n    localparam WAIT_FOR_FIRST_1 = 1'b0,\n               COMPLEMENT_BITS  = 1'b1;\n\n    // Sequential Logic: State Transitions\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WAIT_FOR_FIRST_1;\n            first_one_found <= 1'b0;\n        end else begin\n            case (state)\n                WAIT_FOR_FIRST_1: begin\n                    if (x == 1'b1) begin\n                        first_one_found <= 1'b1;\n                        state <= COMPLEMENT_BITS;\n                    end\n                end\n                COMPLEMENT_BITS: begin\n                    if (x == 1'b1 && !first_one_found) begin\n                        state <= WAIT_FOR_FIRST_1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Combinational logic for output\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            z <= 0;\n        end else begin\n            case (state)\n                WAIT_FOR_FIRST_1: begin\n                    z <= x; // Output the bit as it is until the first '1' is encountered\n                end\n                COMPLEMENT_BITS: begin\n                    z <= ~x; // After the first '1', complement the bits\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State declaration\n    localparam PASS = 1'b0, INVERT = 1'b1;\n    reg state, next_state;\n\n    // Flip-flop for bit flipping after the first '1' is encountered\n    reg first_one_passed;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= PASS;\n            first_one_passed <= 1'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            PASS: begin\n                if (x == 1'b1) begin\n                    next_state = INVERT;\n                end else begin\n                    next_state = PASS;\n                end\n            end\n            INVERT: begin\n                next_state = INVERT;  // Remain in INVERT state once entered\n            end\n            default: begin\n                next_state = PASS;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            PASS: begin\n                z = x;  // Directly pass the input to the output\n            end\n            INVERT: begin\n                z = ~x;  // Invert the input bit once the first '1' is encountered\n            end\n            default: begin\n                z = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State definition\n    localparam IDLE = 1'b0;\n    localparam COMPLEMENT = 1'b1;\n\n    // Register to hold the current state\n    reg state;\n\n    // Register to hold the first '1' encountered\n    reg first_one_detected;\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset all registers\n            state <= IDLE;\n            z <= 0;\n            first_one_detected <= 0;\n        end else begin\n            case(state)\n                IDLE: begin\n                    if (x == 1) begin\n                        // Once the first '1' is encountered, move to COMPLEMENT state\n                        first_one_detected <= 1;\n                        state <= COMPLEMENT;\n                        z <= 1;  // The first '1' stays as '1' in 2's complement\n                    end else begin\n                        // If '0', remains in IDLE state\n                        z <= 0; \n                    end\n                end\n\n                COMPLEMENT: begin\n                    if (first_one_detected) begin\n                        // Once in COMPLEMENT state, invert the bits after the first '1'\n                        z <= ~x;\n                    end else begin\n                        // If the first one has not been detected, output is '0'\n                        z <= x;\n                    end\n                end\n\n                default: begin\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State definitions\n    localparam IDLE = 1'b0, COMPLEMENT = 1'b1;\n    \n    // State register\n    reg state, next_state;\n\n    // Flip logic for 2's complement\n    reg first_one_found;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                z = 0;\n                if (x == 1) begin\n                    next_state = COMPLEMENT;\n                    first_one_found = 1;  // First '1' encountered, start complementing next bits\n                end else begin\n                    next_state = IDLE;\n                    first_one_found = 0;\n                end\n            end\n            COMPLEMENT: begin\n                if (first_one_found) begin\n                    z = ~x;  // Complement the bits after the first '1'\n                end else begin\n                    z = x;   // Pass the first '1' unchanged\n                    first_one_found = 1;\n                end\n                next_state = COMPLEMENT;\n            end\n            default: begin\n                z = 0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Handle the first 1 logic and output appropriately\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            first_one_found <= 0;\n        end else if (state == IDLE && x == 1) begin\n            first_one_found <= 1;\n        end else if (state == COMPLEMENT) begin\n            first_one_found <= 1;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State definitions\n    localparam WAIT_FOR_ONE = 0;\n    localparam INVERT_BITS = 1;\n\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WAIT_FOR_ONE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WAIT_FOR_ONE: begin\n                // Wait for the least significant '1'\n                if (x == 1) begin\n                    next_state = INVERT_BITS;\n                end else begin\n                    next_state = WAIT_FOR_ONE;\n                end\n            end\n            INVERT_BITS: begin\n                // Continue in this state until reset\n                next_state = INVERT_BITS;\n            end\n            default: begin\n                next_state = WAIT_FOR_ONE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state == INVERT_BITS) begin\n            z <= ~x;  // Invert bits after seeing the first '1'\n        end else begin\n            z <= x;  // Pass the bits through until the first '1' is encountered\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State declarations\n    localparam WAIT_FOR_ONE = 1'b0,\n               COMPLEMENT = 1'b1;\n\n    // Signal declaration\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WAIT_FOR_ONE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WAIT_FOR_ONE: \n                if (x == 1'b1)\n                    next_state = COMPLEMENT;\n                else\n                    next_state = WAIT_FOR_ONE;\n\n            COMPLEMENT:\n                next_state = COMPLEMENT;\n                \n            default:\n                next_state = WAIT_FOR_ONE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (areset)\n            z <= 1'b0;\n        else begin\n            case (state)\n                WAIT_FOR_ONE:\n                    z <= x;  // Directly pass the LSB as it's unchanged in 2's complement\n\n                COMPLEMENT:\n                    z <= ~x; // Complement all bits following the first '1'\n\n                default:\n                    z <= 1'b0;\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State Declaration\n    localparam IDLE = 1'b0,\n               COMPLEMENT = 1'b1;\n\n    // Signal to track the current state and next state\n    reg current_state, next_state;\n\n    // Flip-flop to hold bit until next positive clock edge\n    reg first_zero_passed;\n\n    // Sequential logic for state transitioning\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= IDLE;\n            first_zero_passed <= 0;\n        end else begin\n            current_state <= next_state;\n            if (current_state == IDLE && x == 1'b0) begin\n                // Only change this register when in IDLE and the first zero is read\n                first_zero_passed <= 1'b1;\n            end\n        end\n    end\n\n    // Combinational logic for next state logic and output logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (first_zero_passed) begin\n                    z = x;  // Pass through the first zero and subsequent bits unchanged\n                    next_state = COMPLEMENT;\n                end else begin\n                    z = 0;  // Output is zero until the first zero is passed\n                    next_state = IDLE;\n                end\n            end\n            COMPLEMENT: begin\n                z = ~x;  // Complement each bit after the first zero\n                next_state = COMPLEMENT;\n            end\n            default: begin\n                z = 0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State definition\n    localparam WAIT_FOR_ONE = 1'b0,\n               FLIP_BITS     = 1'b1;\n\n    // Signal declaration\n    reg state;\n    reg state_next;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WAIT_FOR_ONE;\n        else\n            state <= state_next;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        state_next = state; // Default to hold current state\n        case (state)\n            WAIT_FOR_ONE: begin\n                z = x; // Pass through the first '1' encountered\n                if (x == 1'b1)\n                    state_next = FLIP_BITS;\n            end\n            FLIP_BITS: begin\n                z = ~x; // Invert bits after the first '1'\n            end\n            default: begin\n                z = 1'bx; // Should never be here\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    localparam WAIT_FOR_ONE = 1'b0,\n               INVERT_BITS = 1'b1;\n\n    // State registers\n    reg state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WAIT_FOR_ONE;\n        else\n            state <= next_state;\n    end\n\n    // Combinatorial logic for next state and output\n    always @(*) begin\n        case (state)\n            WAIT_FOR_ONE: begin\n                if (x == 1) \n                    next_state = INVERT_BITS;\n                else\n                    next_state = WAIT_FOR_ONE;\n                z = 0; // Output 0 until the first '1' is encountered\n            end\n            INVERT_BITS: begin\n                next_state = INVERT_BITS;\n                z = ~x; // Invert each bit after the first '1'\n            end\n            default: begin\n                next_state = WAIT_FOR_ONE;\n                z = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input x,\n    output reg z\n);\n    // State Definitions\n    localparam IDLE = 1'b0,\n               COMPLEMENT = 1'b1;\n\n    // State Registers\n    reg state, next_state;\n\n    // Flip-Flop to hold the input until it is processed\n    reg temp_x;\n    reg first_one_found;\n\n    // State transition and output logic\n    always @(posedge clk, posedge areset) begin\n        if (areset) begin\n            state <= IDLE;\n            z <= 0;\n            first_one_found <= 0;\n            temp_x <= 0;\n        end else begin\n            state <= next_state;\n            temp_x <= x; // Capture the input x at each clock\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        case(state)\n            IDLE: begin\n                if (temp_x == 1'b1) begin\n                    // Transition to COMPLEMENT state if 1 is found\n                    next_state = COMPLEMENT;\n                    first_one_found = 1;\n                end else begin\n                    // Stay in IDLE if 0's are still incoming\n                    next_state = IDLE;\n                end\n                z = 0; // Output is 0 until the first 1 is encountered\n            end\n\n            COMPLEMENT: begin\n                // Once in COMPLEMENT state, output the complement of input\n                if (first_one_found) begin\n                    z = ~temp_x;\n                end else begin\n                    z = temp_x;\n                end\n                next_state = COMPLEMENT;\n            end\n\n            default: begin\n                next_state = IDLE;\n                z = 0;\n            end\n        endcase\n    end\n\n    // Output logic: directly linked to state actions\n    always @(state) begin\n        case (state)\n            IDLE: z = 0;\n            COMPLEMENT: z = first_one_found ? ~temp_x : temp_x;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "fsm3", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input areset,\n    output out\n);\n\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Output logic (Moore output depends only on the state)\n    assign out = (state == D);\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A; // Asynchronous reset\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle any undefined states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    // State variable\n    reg [1:0] current_state, next_state;\n\n    // Next state logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // State transition logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_B : STATE_A;\n            STATE_B: next_state = in ? STATE_B : STATE_C;\n            STATE_C: next_state = in ? STATE_D : STATE_A;\n            STATE_D: next_state = in ? STATE_B : STATE_C;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 0;\n            STATE_B: out = 0;\n            STATE_C: out = 0;\n            STATE_D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State declaration using parameters for better readability\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State Encoding\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= STATE_A;  // Asynchronous reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_B : STATE_A;\n            STATE_B: next_state = in ? STATE_B : STATE_C;\n            STATE_C: next_state = in ? STATE_D : STATE_A;\n            STATE_D: next_state = in ? STATE_B : STATE_C;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 0;\n            STATE_B: out = 0;\n            STATE_C: out = 0;\n            STATE_D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State Encoding\n    typedef enum reg [1:0] {\n        S_A = 2'b00,\n        S_B = 2'b01,\n        S_C = 2'b10,\n        S_D = 2'b11\n    } state_t;\n\n    // State variable and next state declaration\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            current_state <= S_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = (in == 0) ? S_A : S_B;\n            S_B: next_state = (in == 0) ? S_C : S_B;\n            S_C: next_state = (in == 0) ? S_A : S_D;\n            S_D: next_state = (in == 0) ? S_C : S_B;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(current_state)\n            S_A: out = 0;\n            S_B: out = 0;\n            S_C: out = 0;\n            S_D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    reg [1:0] state, next_state;\n\n    // State Declaration\n    localparam A = 2'b00;\n    localparam B = 2'b01;\n    localparam C = 2'b10;\n    localparam D = 2'b11;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= A;  // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case(state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        S_A = 2'b00,\n        S_B = 2'b01,\n        S_C = 2'b10,\n        S_D = 2'b11\n    } state_t;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= S_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = in ? S_B : S_A;\n            S_B: next_state = in ? S_B : S_C;\n            S_C: next_state = in ? S_D : S_A;\n            S_D: next_state = in ? S_B : S_C;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S_A: out = 1'b0;\n            S_B: out = 1'b0;\n            S_C: out = 1'b0;\n            S_D: out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // State transition logic and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            current_state <= STATE_A;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_B : STATE_A;\n            STATE_B: next_state = in ? STATE_B : STATE_C;\n            STATE_C: next_state = in ? STATE_D : STATE_A;\n            STATE_D: next_state = in ? STATE_B : STATE_C;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(current_state)\n            STATE_A: out = 0;\n            STATE_B: out = 0;\n            STATE_C: out = 0;\n            STATE_D: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        S_A = 2'b00,\n        S_B = 2'b01,\n        S_C = 2'b10,\n        S_D = 2'b11\n    } state_t;\n\n    // Signal to hold current state\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= S_A;  // Reset state to A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = in ? S_B : S_A;\n            S_B: next_state = in ? S_B : S_C;\n            S_C: next_state = in ? S_D : S_A;\n            S_D: next_state = in ? S_B : S_C;\n            default: next_state = S_A;  // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic based on state (Moore output)\n    always @(*) begin\n        case (current_state)\n            S_A: out = 0;\n            S_B: out = 0;\n            S_C: out = 0;\n            S_D: out = 1;\n            default: out = 0;  // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State variables\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state and output logic based on current state and input\n    always @(*) begin\n        case(state)\n            A: begin\n                next_state = in ? B : A;\n                out = 0;\n            end\n            B: begin\n                next_state = in ? B : C;\n                out = 0;\n            end\n            C: begin\n                next_state = in ? D : A;\n                out = 0;\n            end\n            D: begin\n                next_state = in ? B : C;\n                out = 1;\n            end\n            default: begin\n                next_state = A; // Default state\n                out = 0;\n            end\n        endcase\n    end\nendmodule\n"]}
{"task_id": "vector2", "gptgen_RTL": ["module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n// Reversing the byte order of a 32-bit input vector\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n// Reversing the byte order of the 32-bit input\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n    // Reverse the byte order of the 32-bit input\n    assign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n// Assign each byte in reverse order\nassign out[31:24] = in[7:0];\nassign out[23:16] = in[15:8];\nassign out[15:8] = in[23:16];\nassign out[7:0] = in[31:24];\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n// Reversing the byte order for a 32-bit vector\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\n// Assigning the input byte order reversed to the output\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n", "module top_module (\n    input [31:0] in,\n    output [31:0] out\n);\n\nassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\n\nendmodule\n"]}
{"task_id": "m2014_q4c", "gptgen_RTL": ["module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r) begin\n        q <= 1'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n    always_ff @(posedge clk) begin\n        if (r)\n            q <= 1'b0; // Reset q to 0 when r is high\n        else\n            q <= d; // Load d into q on the positive edge of clk otherwise\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\n// D flip-flop with active high synchronous reset\nalways @(posedge clk) begin\n    if (r)\n        q <= 0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r) begin\n        q <= 0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input r,\n    output logic q\n);\n\nalways @(posedge clk) begin\n    if (r)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "mt2015_q4a", "gptgen_RTL": ["module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Implementing the boolean function z = (x ^ y) & x\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n    assign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nassign z = (x ^ y) & x;\n\nendmodule\n"]}
{"task_id": "ece241_2013_q8", "gptgen_RTL": ["module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        S0, // Idle state waiting for '1'\n        S1, // '1' detected, waiting for '0'\n        S2  // '10' detected, waiting for '1'\n    } state_type;\n\n    // State variable\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0; // Asynchronous reset\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S2: z = x; // Output '1' only when in state S2 and x is '1'\n            default: z = 0; // Default output is '0'\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    localparam [1:0] S0 = 2'b00,  // No correct bits or only '1' detected\n                     S1 = 2'b01,  // Sequence '10' detected\n                     S2 = 2'b10;  // Sequence '101' detected\n\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (current_state)\n            S0: \n                next_state = x ? S0 : S1;  // Stay in S0 if x=1, else move to S1 on x=0\n            S1: \n                next_state = x ? S2 : S1;  // Move to S2 if x=1, else stay in S1 on x=0\n            S2:\n                next_state = x ? S0 : S1;  // Move to S0 if x=1, else move to S1 on x=0\n            default: \n                next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (current_state == S2 && x); // Output z is 1 when '101' sequence is completed and x=1\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    localparam S0 = 2'b00,  // Waiting for '1'\n              S1 = 2'b01,  // '1' received, waiting for '0'\n              S2 = 2'b10;  // '10' received, waiting for '1'\n\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn) \n            current_state <= S0;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (current_state == S2) && x;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // Define the states\n    typedef enum reg [1:0] {\n        S0, // Waiting for the first '1'\n        S1, // '1' received, waiting for '0'\n        S2  // '10' received, waiting for '1'\n    } state_t;\n\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            S0: begin\n                if (x == 1)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x == 0)\n                    next_state = S2;\n                else\n                    next_state = S1;\n            end\n            S2: begin\n                if (x == 1) begin\n                    next_state = S1;\n                end else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S2: z = (x == 1); // Output is high only when final '1' is received after '10'\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State Encoding\n    localparam [1:0] S0 = 2'b00, // idle, waiting for '1'\n                     S1 = 2'b01, // '1' received, waiting for '0'\n                     S2 = 2'b10; // '10' received, waiting for '1'\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S2: z = x ? 1'b1 : 1'b0;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    parameter IDLE = 2'b00, S1 = 2'b01, S2 = 2'b10;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // State transition logic with Mealy outputs\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn) \n            current_state <= IDLE; // Asynchronous reset\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE:\n                if (x == 1)\n                    next_state = S1;\n                else\n                    next_state = IDLE;\n            S1:\n                if (x == 0)\n                    next_state = S2;\n                else\n                    next_state = S1; // Stay in S1 if '1' is received\n            S2:\n                if (x == 1)\n                    next_state = S1; // Move to S1 waiting for another '0' to complete '101'\n                else\n                    next_state = IDLE; // Reset to IDLE if '0' follows\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // By default z is 0\n        z = 0;\n        // z is asserted when '1' completes the sequence '101' and we are in state S2\n        if (current_state == S2 && x == 1)\n            z = 1;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        S0, // Waiting for '1'\n        S1, // '1' received, waiting for '0'\n        S2  // '10' received, waiting for '1'\n    } state_type;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge aresetn) begin\n        if (!aresetn) \n            current_state <= S0; // Asynchronous reset to initial state\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic and output logic (Mealy)\n    always @(*) begin\n        // Default output\n        z = 0;\n        case (current_state)\n            S0: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S0;\n            end\n            S1: begin\n                if (x)\n                    next_state = S1;\n                else\n                    next_state = S2;\n            end\n            S2: begin\n                if (x) begin\n                    next_state = S1;\n                    z = 1; // Output is asserted when sequence 101 is detected\n                end else\n                    next_state = S0;\n            end\n            default: next_state = S0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        S0, // Initial state\n        S1, // Detected '1'\n        S2  // Detected '10'\n    } state_type;\n\n    // State register\n    state_type state, next_state;\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            S2: z = x ? 1 : 0; // Output is 1 only when the sequence 101 is detected\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    reg [1:0] state, next_state;\n    \n    // State declaration\n    localparam  S0 = 2'b00, // Waiting for '1'\n                S1 = 2'b01, // '1' received, waiting for '0'\n                S2 = 2'b10; // '10' received, waiting for '1'\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic: Mealy type\n    always @(*) begin\n        case (state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = x; // Only output '1' when in S2 and input x is '1' (i.e., sequence 101)\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input aresetn,\n    input x,\n    output reg z\n);\n\n    // State encoding declaration\n    typedef enum reg [1:0] {\n        S0, // Initial state: wait for '1'\n        S1, // Detected '1', wait for '0'\n        S2  // Detected '10', wait for '1' to complete '101'\n    } state_t;\n\n    // State register\n    state_t state, next_state;\n\n    // State transition logic\n    always @(posedge clk, negedge aresetn) begin\n        if (!aresetn)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S1 : S2;\n            S2: next_state = x ? S1 : S0;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        z = (state == S2 && x);\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q6", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum logic [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // State variable\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A; // Default to state A for safety\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_E = 3'b100,\n        STATE_F = 3'b101\n    } state_type;\n\n    // State and next state variables\n    reg [2:0] current_state, next_state;\n\n    // State machine transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        // Default action\n        next_state = current_state;\n        z = 0;\n\n        case (current_state)\n            STATE_A: begin\n                if (w == 1'b0)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (w == 1'b0)\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_D;\n            end\n            STATE_C: begin\n                if (w == 1'b0)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_D;\n            end\n            STATE_D: begin\n                if (w == 1'b0)\n                    next_state = STATE_F;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_E: begin\n                z = 1;\n                if (w == 1'b0)\n                    next_state = STATE_E;\n                else\n                    next_state = STATE_D;\n            end\n            STATE_F: begin\n                z = 1;\n                if (w == 1'b0)\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_D;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State Encoding\n    parameter A = 3'd0,\n              B = 3'd1,\n              C = 3'd2,\n              D = 3'd3,\n              E = 3'd4,\n              F = 3'd5;\n\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to initial state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A; // Default case to handle undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // Define the states with binary encoding\n    typedef enum reg [2:0] {\n        S_A = 3'b000,\n        S_B = 3'b001,\n        S_C = 3'b010,\n        S_D = 3'b011,\n        S_E = 3'b100,\n        S_F = 3'b101\n    } state_t;\n\n    // State variable\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S_A;  // Reset to initial state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input w\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = w ? S_A : S_B;\n            S_B: next_state = w ? S_D : S_C;\n            S_C: next_state = w ? S_D : S_E;\n            S_D: next_state = w ? S_A : S_F;\n            S_E: next_state = w ? S_D : S_E;\n            S_F: next_state = w ? S_D : S_C;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic: z is 1 in states E and F\n    always @(current_state) begin\n        case (current_state)\n            S_E: z = 1;\n            S_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // Define state encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // State and next state variables\n    reg [2:0] current_state, next_state;\n\n    // Sequential logic for state transition\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Initial state\n        else\n            current_state <= next_state;\n    end\n\n    // Combinational logic for next state\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? A : B; // A transitions\n            B: next_state = w ? D : C; // B transitions\n            C: next_state = w ? D : E; // C transitions\n            D: next_state = w ? A : F; // D transitions\n            E: next_state = w ? D : E; // E transitions, stays in E if w = 0\n            F: next_state = w ? D : C; // F transitions\n            default: next_state = A; // Default case to handle undefined states\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            E: z = 1; // E outputs 1\n            F: z = 1; // F outputs 1\n            default: z = 0; // All other states output 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // Define state encoding\n    typedef enum reg [2:0] {\n        S_A = 3'd0,\n        S_B = 3'd1,\n        S_C = 3'd2,\n        S_D = 3'd3,\n        S_E = 3'd4,\n        S_F = 3'd5\n    } state_t;\n\n    // Current and next state variables\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) \n            current_state <= S_A;\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input w\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = (w == 0) ? S_B : S_A;\n            S_B: next_state = (w == 0) ? S_C : S_D;\n            S_C: next_state = (w == 0) ? S_E : S_D;\n            S_D: next_state = (w == 0) ? S_F : S_A;\n            S_E: next_state = (w == 0) ? S_E : S_D;\n            S_F: next_state = (w == 0) ? S_C : S_D;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S_E: z = 1;\n            S_F: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // Current and Next State Declarations\n    reg [2:0] current_state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A; // Default case to handle any undefined state\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'd0,\n        B = 3'd1,\n        C = 3'd2,\n        D = 3'd3,\n        E = 3'd4,\n        F = 3'd5\n    } state_t;\n\n    // Current and next state variables\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            state <= A;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? A : B;\n            B: next_state = w ? D : C;\n            C: next_state = w ? D : E;\n            D: next_state = w ? A : F;\n            E: next_state = w ? D : E;\n            F: next_state = w ? D : C;\n            default: next_state = A; // default case to handle undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: z = 0;\n            B: z = 0;\n            C: z = 0;\n            D: z = 0;\n            E: z = 1;\n            F: z = 1;\n            default: z = 0; // default case to handle undefined states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S_A = 3'b000,\n        S_B = 3'b001,\n        S_C = 3'b010,\n        S_D = 3'b011,\n        S_E = 3'b100,\n        S_F = 3'b101\n    } state_t;\n\n    // State register\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = w ? S_A : S_B;\n            S_B: next_state = w ? S_D : S_C;\n            S_C: next_state = w ? S_D : S_E;\n            S_D: next_state = w ? S_A : S_F;\n            S_E: next_state = w ? S_D : S_E;\n            S_F: next_state = w ? S_D : S_C;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S_E: z = 1;\n            S_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n    // State encoding\n    typedef enum reg [2:0] {\n        S_A = 3'b000,\n        S_B = 3'b001,\n        S_C = 3'b010,\n        S_D = 3'b011,\n        S_E = 3'b100,\n        S_F = 3'b101\n    } state_t;\n\n    reg [2:0] current_state, next_state;\n\n    // State register\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= S_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = w ? S_A : S_B;\n            S_B: next_state = w ? S_D : S_C;\n            S_C: next_state = w ? S_D : S_E;\n            S_D: next_state = w ? S_A : S_F;\n            S_E: next_state = w ? S_D : S_E;\n            S_F: next_state = w ? S_D : S_C;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S_E: z = 1;\n            S_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "fsm_ps2data", "gptgen_RTL": ["module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n    // State definitions\n    localparam WAIT_FOR_START = 0,\n               BYTE1 = 1,\n               BYTE2 = 2,\n               BYTE3 = 3;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Registers to hold bytes\n    reg [7:0] byte1, byte2;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= WAIT_FOR_START;\n            done <= 0;\n            out_bytes <= 24'd0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                WAIT_FOR_START: begin\n                    done <= 0;\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        next_state <= BYTE1;\n                    end else begin\n                        next_state <= WAIT_FOR_START;\n                    end\n                end\n                BYTE1: begin\n                    byte2 <= in;\n                    next_state <= BYTE2;\n                end\n                BYTE2: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                    next_state <= BYTE3;\n                end\n                BYTE3: begin\n                    done <= 0;\n                    next_state <= WAIT_FOR_START;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            WAIT_FOR_START: begin\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = WAIT_FOR_START;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = WAIT_FOR_START;\n            end\n            default: begin\n                next_state = WAIT_FOR_START;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State definition\n    reg [1:0] state, next_state;\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // Registers to hold bytes\n    reg [7:0] byte1, byte2;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'bx;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    if (in[3] == 1'b1) begin\n                        byte1 <= in;\n                        next_state <= BYTE1;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                    done <= 0;\n                end\n                BYTE1: begin\n                    byte2 <= in;\n                    next_state <= BYTE2;\n                    done <= 0;\n                end\n                BYTE2: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                    next_state <= IDLE;\n                end\n                default: begin\n                    next_state <= IDLE;\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [23:0] next_out_bytes;\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // Sequential logic for state transitioning\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            out_bytes <= 24'b0;\n            done <= 0;\n        end\n        else begin\n            state <= next_state;\n            out_bytes <= next_out_bytes;\n            done <= (next_state == BYTE3);\n        end\n    end\n\n    // Combinational logic for next state and output\n    always @(*) begin\n        next_state = state;\n        next_out_bytes = out_bytes;\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) begin\n                    next_state = BYTE1;\n                    next_out_bytes[23:16] = in;\n                end\n            end\n\n            BYTE1: begin\n                next_state = BYTE2;\n                next_out_bytes[15:8] = in;\n            end\n\n            BYTE2: begin\n                next_state = BYTE3;\n                next_out_bytes[7:0] = in;\n            end\n\n            BYTE3: begin\n                next_state = IDLE;\n                // Retain the assembled bytes only for one cycle when done is asserted\n                next_out_bytes = {in, out_bytes[23:8]};\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    reg [1:0] state, next_state;\n    reg [7:0] byte1, byte2, byte3;\n\n    // State Encoding\n    localparam WAIT_FOR_START = 2'd0,\n               BYTE1_RECEIVED = 2'd1,\n               BYTE2_RECEIVED = 2'd2,\n               BYTE3_RECEIVED = 2'd3;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_FOR_START;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WAIT_FOR_START: begin\n                if (in[3] == 1) begin\n                    next_state = BYTE1_RECEIVED;\n                end else begin\n                    next_state = WAIT_FOR_START;\n                end\n            end\n            BYTE1_RECEIVED: begin\n                next_state = BYTE2_RECEIVED;\n            end\n            BYTE2_RECEIVED: begin\n                next_state = BYTE3_RECEIVED;\n            end\n            BYTE3_RECEIVED: begin\n                next_state = WAIT_FOR_START;\n            end\n            default: begin\n                next_state = WAIT_FOR_START;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            done <= 0;\n            out_bytes <= 24'd0;\n        end else begin\n            case(state)\n                WAIT_FOR_START: begin\n                    done <= 0;\n                end\n                BYTE1_RECEIVED: begin\n                    byte1 <= in;\n                    done <= 0;\n                end\n                BYTE2_RECEIVED: begin\n                    byte2 <= in;\n                    done <= 0;\n                end\n                BYTE3_RECEIVED: begin\n                    byte3 <= in;\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                end\n                default: begin\n                    done <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n    // State definitions\n    localparam WAIT_START = 0,\n               BYTE1 = 1,\n               BYTE2 = 2,\n               BYTE3 = 3;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Byte storage\n    reg [7:0] byte1, byte2;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_START;\n            done <= 0;\n            out_bytes <= 0;\n        end else begin\n            state <= next_state;\n            case (state)\n                WAIT_START: begin\n                    done <= 0;\n                end\n                BYTE1: begin\n                    byte1 <= in;\n                end\n                BYTE2: begin\n                    byte2 <= in;\n                end\n                BYTE3: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @* begin\n        case (state)\n            WAIT_START: next_state = (in[3] == 1) ? BYTE1 : WAIT_START;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = (in[3] == 1) ? BYTE1 : WAIT_START;\n            default: next_state = WAIT_START;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state != BYTE3) begin\n            done <= 0;\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // Define state identifiers\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // Byte storage registers\n    reg [7:0] byte1, byte2, byte3;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'd0;\n        end\n        else begin\n            current_state <= next_state;\n            case (current_state)\n                IDLE: begin\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        done <= 0;\n                    end\n                end\n                BYTE1: begin\n                    byte2 <= in;\n                    done <= 0;\n                end\n                BYTE2: begin\n                    byte3 <= in;\n                    done <= 0;\n                end\n                BYTE3: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: next_state = (in[3] == 1) ? BYTE1 : IDLE;\n            BYTE1: next_state = BYTE2;\n            BYTE2: next_state = BYTE3;\n            BYTE3: next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    reg [1:0] state;\n    reg [1:0] next_state;\n    reg [7:0] byte1, byte2, byte3;\n\n    // State definitions\n    localparam IDLE = 2'b00;\n    localparam BYTE1 = 2'b01;\n    localparam BYTE2 = 2'b10;\n    localparam BYTE3 = 2'b11;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            out_bytes <= 24'd0;\n            done <= 1'b0;\n            byte1 <= 8'd0;\n            byte2 <= 8'd0;\n            byte3 <= 8'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                end\n                BYTE1: begin\n                    byte1 <= in;\n                end\n                BYTE2: begin\n                    byte2 <= in;\n                end\n                BYTE3: begin\n                    byte3 <= in;\n                    out_bytes <= {byte1, byte2, byte3};\n                    done <= 1'b1;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    reg [1:0] state;\n    reg [23:0] message;\n\n    // State Encoding\n    localparam IDLE = 2'd0,\n               BYTE1 = 2'd1,\n               BYTE2 = 2'd2,\n               COMPLETE = 2'd3;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n            done <= 0;\n            out_bytes <= 24'd0;\n            message <= 24'd0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 0;\n                    if (in[3] == 1) begin\n                        // Start of the new message\n                        message[23:16] <= in;  // Store first byte\n                        state <= BYTE1;\n                    end\n                end\n                BYTE1: begin\n                    message[15:8] <= in;  // Store second byte\n                    state <= BYTE2;\n                end\n                BYTE2: begin\n                    message[7:0] <= in;  // Store third byte\n                    state <= COMPLETE;\n                end\n                COMPLETE: begin\n                    out_bytes <= message;  // Output the complete message\n                    done <= 1; // Indicate that a message has been completed\n                    state <= IDLE; // Return to IDLE to search for next message\n                end\n                default: state <= IDLE;\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 2'd0,\n               BYTE1 = 2'd1,\n               BYTE2 = 2'd2,\n               BYTE3 = 2'd3;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Register to hold bytes\n    reg [7:0] byte1, byte2;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n            out_bytes <= 24'd0;\n            done <= 0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                IDLE: begin\n                    done <= 0;\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        next_state <= BYTE1;\n                    end\n                end\n                BYTE1: begin\n                    byte2 <= in;\n                    next_state <= BYTE2;\n                end\n                BYTE2: begin\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1;\n                    next_state <= BYTE3;\n                end\n                BYTE3: begin\n                    done <= 0;\n                    if (in[3] == 1) begin\n                        byte1 <= in;\n                        next_state <= BYTE1;\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n                default: begin\n                    next_state <= IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg [23:0] out_bytes,\n    output reg done\n);\n\n    // State Definitions\n    localparam IDLE = 2'd0,\n               BYTE1 = 2'd1,\n               BYTE2 = 2'd2,\n               BYTE3 = 2'd3;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Register to hold incoming bytes\n    reg [7:0] byte1, byte2;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                // Start capturing bytes when in[3] is 1\n                if (in[3] == 1) \n                    next_state = BYTE1;\n                else \n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                // After the third byte, go back to IDLE, look for start of next message\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic and byte capturing\n    always @(posedge clk) begin\n        if (reset) begin\n            byte1 <= 8'd0;\n            byte2 <= 8'd0;\n            out_bytes <= 24'd0;\n            done <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    done <= 1'b0;\n                end\n                BYTE1: begin\n                    // Capture first byte\n                    byte1 <= in;\n                end\n                BYTE2: begin\n                    // Capture second byte\n                    byte2 <= in;\n                end\n                BYTE3: begin\n                    // Capture third byte and signal done\n                    out_bytes <= {byte1, byte2, in};\n                    done <= 1'b1;\n                end\n                default: begin\n                    done <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"]}
{"task_id": "vector1", "gptgen_RTL": ["module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n    assign out_hi = in[15:8];\n    assign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];  // Assign the upper byte of the input to out_hi\nassign out_lo = in[7:0];   // Assign the lower byte of the input to out_lo\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\nassign out_hi = in[15:8];\nassign out_lo = in[7:0];\n\nendmodule\n", "module top_module (\n    input [15:0] in,\n    output [7:0] out_hi,\n    output [7:0] out_lo\n);\n\n// Assigning the upper 8 bits of the input to out_hi\nassign out_hi = in[15:8];\n\n// Assigning the lower 8 bits of the input to out_lo\nassign out_lo = in[7:0];\n\nendmodule\n"]}
{"task_id": "norgate", "gptgen_RTL": ["module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n", "module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a | b);\n\nendmodule\n"]}
{"task_id": "m2014_q6c", "gptgen_RTL": ["module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n// State Encoding:\n// A: 000001, B: 000010, C: 000100, D: 001000, E: 010000, F: 100000\n\n// Y2 corresponds to B, Y4 corresponds to D\n\n// Next state logic for Y2 (state B)\nassign Y2 = (y[1] & ~w) | (y[3] & w);  // B -> (A & ~w) | (C & w)\n\n// Next state logic for Y4 (state D)\nassign Y4 = (y[2] & w) | (y[3] & ~w) | (y[5] & w) | (y[6] & w);  // D -> (B & w) | (C & ~w) | (E & w) | (F & w)\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // State encoding\n    // A: 000001\n    // B: 000010\n    // C: 000100\n    // D: 001000\n    // E: 010000\n    // F: 100000\n\n    // Y2 corresponds to state B (y[2])\n    // From the state machine transitions:\n    // - State B is entered from state A when w = 0.\n    // Thus, Y2 (next state is B) = current state A and w = 0\n    assign Y2 = y[1] & ~w;\n\n    // Y4 corresponds to state D (y[4])\n    // From the state machine transitions:\n    // - State D is entered from state B when w = 1,\n    // - State D is entered from state C when w = 1,\n    // - State D is entered from state E when w = 1,\n    // - State D is entered from state F when w = 1.\n    // Thus, Y4 (next state is D) = (current state B and w = 1) OR\n    //                              (current state C and w = 1) OR\n    //                              (current state E and w = 1) OR\n    //                              (current state F and w = 1)\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // State A -> y[1] = 1; State B -> y[2] = 1; State C -> y[3] = 1\n    // State D -> y[4] = 1; State E -> y[5] = 1; State F -> y[6] = 1\n\n    // Next state logic for Y2 (State B)\n    // B can be reached from A with w=0 or from C with w=1\n    assign Y2 = (y[1] & ~w) | (y[3] & w);\n\n    // Next state logic for Y4 (State D)\n    // D can be reached from B with w=1 or from C with w=1 or from F with w=1\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // State A corresponds to y[1] => 000001\n    // State B corresponds to y[2] => 000010\n    // State C corresponds to y[3] => 000100\n    // State D corresponds to y[4] => 001000\n    // State E corresponds to y[5] => 010000\n    // State F corresponds to y[6] => 100000\n\n    // Next-state logic for Y2 (state B)\n    // From the state diagram:\n    // - State B is entered from State A if w = 0\n    // - State B corresponds to y[2]\n    assign Y2 = (y[1] & ~w);\n\n    // Next-state logic for Y4 (state D)\n    // From the state diagram:\n    // - State D is entered from State B if w = 1\n    // - State D is entered from State C if w = 1\n    // - State D is entered from State E if w = 1\n    // - State D is entered from State F if w = 1\n    // - State D corresponds to y[4]\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // State Encoding\n    // A: 000001\n    // B: 000010\n    // C: 000100\n    // D: 001000\n    // E: 010000\n    // F: 100000\n\n    // Next state logic for Y2 (B state)\n    // Y2 will be 1 in the next state if:\n    // (Current state is A and w is 0) or (Current state is C and w is 0)\n    assign Y2 = (y[1] & ~w) | (y[3] & ~w);\n\n    // Next state logic for Y4 (D state)\n    // Y4 will be 1 in the next state if:\n    // (Current state is B and w is 1) or (Current state is C and w is 1) or\n    // (Current state is E and w is 1) or (Current state is F and w is 1)\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // State A (000001), State B (000010), State C (000100), State D (001000), State E (010000), State F (100000)\n\n    // Y2 corresponds to state B\n    // State transitions leading to state B:\n    // B(0) from A(0) when w = 0\n\n    assign Y2 = (y[1] & ~w);\n\n    // Y4 corresponds to state D\n    // State transitions leading to state D:\n    // D(0) from B(0) when w = 1\n    // D(0) from C(0) when w = 1\n    // D(1) from E(1) when w = 1\n    // D(1) from F(1) when w = 1\n\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // Assignments for Y2 and Y4 based on current state (y) and input (w)\n    // Using one-hot encoding, the states are:\n    // A: 000001, B: 000010, C: 000100, D: 001000, E: 010000, F: 100000\n\n    // Y2 corresponds to state B\n    // By inspecting the state transitions:\n    // - State A (000001) transitions to state B (000010) if w = 0\n    // - State B (000010), C (000100), D (001000) and E (010000) do not transition to B\n    // - State F (100000) transitions to state B (000010) if w = 0\n    assign Y2 = (y[1] & ~w) | (y[6] & ~w);\n\n    // Y4 corresponds to state D\n    // By inspecting the state transitions:\n    // - State A (000001) transitions to state D (001000) if w = 1\n    // - State B (000010) transitions to state D (001000) if w = 1\n    // - State C (000100) transitions to state D (001000) if w = 1\n    // - State D (001000) does not remain in state D\n    // - State E (010000) transitions to state D (001000) if w = 1\n    // - State F (100000) transitions to state D (001000) if w = 1\n    assign Y4 = ((y[1] | y[2] | y[3] | y[5] | y[6]) & w);\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n    // Assign outputs based on current state y and input w\n    // State B is represented by y[2], State D by y[4]\n\n    // Y2 represents the next state logic for state B\n    // From state transitions:\n    // - From A to B if w == 0 (A is y[1])\n    // - Stays in B if in B and w == 0 (covered by else state C -> y[2] to false)\n    assign Y2 = (y[1] & ~w);\n\n    // Y4 represents the next state logic for state D\n    // From state transitions:\n    // - From B to D if w == 1 (B is y[2])\n    // - From C to D if w == 1 (C is y[3])\n    // - From E to D if w == 1 (E is y[5])\n    // - From F to D if w == 1 (F is y[6])\n    assign Y4 = (y[2] & w) | (y[3] & w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n", "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\n    // State B (y[2]) is active when transitioning from:\n    // - State A and w = 0 (000001 & w == 0)\n    // - State C and w = 1 (000100 & w == 1)\n    assign Y2 = (y[1] & ~w) | (y[3] & w);\n\n    // State E (y[4]) is active when transitioning from:\n    // - State C and w = 0 (000100 & w == 0)\n    assign Y4 = y[3] & ~w;\n\nendmodule\n", "module top_module (\n    input [6:1] y,\n    input w,\n    output Y2,\n    output Y4\n);\n\n    // State A (y[1]), B (y[2]), C (y[3]), D (y[4]), E (y[5]), F (y[6])\n\n    // Next state logic for Y2 (y[2] corresponds to state B)\n    assign Y2 = (y[1] & ~w) | (y[3] & w);\n\n    // Next state logic for Y4 (y[4] corresponds to state D)\n    assign Y4 = (y[2] & w) | (y[3] & ~w) | (y[5] & w) | (y[6] & w);\n\nendmodule\n"]}
{"task_id": "mux256to1", "gptgen_RTL": ["module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n// Assign the output based on the selected input bit determined by 'sel'\nassign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\nassign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\nassign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n", "module top_module (\n    input [255:0] in,\n    input [7:0] sel,\n    output out\n);\n\n    assign out = in[sel];\n\nendmodule\n"]}
{"task_id": "ece241_2014_q4", "gptgen_RTL": ["module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Declare the flip-flop outputs and their complements\n    wire q_xor, q_and, q_or;\n    wire not_q_xor, not_q_and, not_q_or;\n\n    // Flip-Flop outputs\n    always @(posedge clk) begin\n        q_xor <= x ^ q_xor;\n        q_and <= x & ~q_and;\n        q_or <= x | ~q_or;\n    end\n\n    // Generate the complements of the flip-flop outputs\n    assign not_q_xor = ~q_xor;\n    assign not_q_and = ~q_and;\n    assign not_q_or = ~q_or;\n\n    // Three-input XNOR for output Z\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Internal signals for flip-flop outputs\n    wire q_xor, q_and, q_or;\n\n    // Internal signals for the D flip-flop inputs\n    wire d_xor, d_and, d_or;\n\n    // XOR gate with input x and the output of its corresponding D flip-flop\n    assign d_xor = x ^ q_xor;\n\n    // AND gate with input x and the complement of the output of its corresponding D flip-flop\n    assign d_and = x & ~q_and;\n\n    // OR gate with input x and the complement of the output of its corresponding D flip-flop\n    assign d_or = x | ~q_or;\n\n    // D flip-flops\n    DFF dff_xor(\n        .clk(clk),\n        .d(d_xor),\n        .q(q_xor)\n    );\n\n    DFF dff_and(\n        .clk(clk),\n        .d(d_and),\n        .q(q_and)\n    );\n\n    DFF dff_or(\n        .clk(clk),\n        .d(d_or),\n        .q(q_or)\n    );\n\n    // Three-input XNOR gate to produce the output z\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\n    // Definition of D flip-flop module\n    module DFF(\n        input clk,\n        input d,\n        output reg q\n    );\n        always @(posedge clk) begin\n            q <= d;\n        end\n    endmodule\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Declare the flip-flop outputs\n    reg q_xor, q_and, q_or;\n\n    // D flip-flop outputs initialization\n    initial begin\n        q_xor = 0;\n        q_and = 0;\n        q_or = 0;\n    end\n\n    // Logic connections between input, flip-flops, and gates\n    wire xor_out, and_out, or_out;\n\n    // XOR gate with feedback from its corresponding flip-flop\n    assign xor_out = x ^ q_xor;\n\n    // AND gate with feedback from the complement of its corresponding flip-flop\n    assign and_out = x & ~q_and;\n\n    // OR gate with feedback from the complement of its corresponding flip-flop\n    assign or_out = x | ~q_or;\n\n    // Flip-flop assignments for storing values\n    always @(posedge clk) begin\n        q_xor <= xor_out;\n        q_and <= and_out;\n        q_or <= or_out;\n    end\n\n    // Three-input XNOR gate to produce output z\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Internal flip-flop outputs\n    reg q_xor, q_and, q_or;\n\n    // Internal signals for the second inputs of each gate\n    wire xor_second_input, and_second_input, or_second_input;\n\n    // Assigning the second inputs of the XOR, AND, and OR gates\n    assign xor_second_input = q_xor;\n    assign and_second_input = ~q_and;\n    assign or_second_input = ~q_or;\n\n    // Gate output declarations\n    wire xor_out, and_out, or_out;\n\n    // Gate connections\n    assign xor_out = x ^ xor_second_input;\n    assign and_out = x & and_second_input;\n    assign or_out = x | or_second_input;\n\n    // Flip-flops to hold the outputs of gates\n    always @(posedge clk) begin\n        q_xor <= xor_out;\n        q_and <= and_out;\n        q_or <= or_out;\n    end\n\n    // XNOR gate for final output\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Define the flip-flop outputs\n    reg Q_xor, Q_and, Q_or;\n\n    // Connect each gate to the x input and corresponding flip-flop outputs\n    wire xor_out = x ^ Q_xor;\n    wire and_out = x & ~Q_and;\n    wire or_out  = x | ~Q_or;\n\n    // Flip-flops to store the values of gates outputs\n    always @(posedge clk) begin\n        Q_xor <= xor_out;\n        Q_and <= and_out;\n        Q_or  <= or_out;\n    end\n\n    // XNOR gate combining all flip-flop outputs\n    assign z = ~(Q_xor ^ Q_and ^ Q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Define the wires to connect the gates to the flip-flops\n    wire xor_out, and_out, or_out;\n    wire ff_xor_out, ff_and_out, ff_or_out;\n\n    // D flip-flops\n    reg q_xor, q_and, q_or;\n\n    // Assign initial states to flip-flops\n    initial begin\n        q_xor = 0;\n        q_and = 0;\n        q_or = 0;\n    end\n\n    // XOR gate\n    xor(xor_gate, x, q_xor);\n    always @(posedge clk) begin\n        q_xor <= xor_gate;\n    end\n\n    // AND gate, with complemented flip-flop output\n    wire not_q_and;\n    not(not_q_and, q_and);\n    and(and_gate, x, not_q_and);\n    always @(posedge clk) begin\n        q_and <= and_gate;\n    end\n\n    // OR gate, with complemented flip-flop output\n    wire not_q_or;\n    not(not_q_or, q_or);\n    or(or_gate, x, not_q_or);\n    always @(posedge clk) begin\n        q_or <= or_gate;\n    end\n\n    // Three-input XNOR for the output\n    xnor(xnor_gate, q_xor, q_and, q_or);\n    assign z = xnor_gate;\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\nreg Q1, Q2, Q3;\n\n// Flip-flop outputs\nwire Q1_next, Q2_next, Q3_next;\n\n// XOR gate logic\nassign Q1_next = x ^ Q1;\n\n// AND gate logic, with complement of Q2\nassign Q2_next = x & ~Q2;\n\n// OR gate logic, with complement of Q3\nassign Q3_next = x | ~Q3;\n\n// XNOR gate combining all three flip-flop outputs\nassign z = ~(Q1 ^ Q2 ^ Q3);\n\n// D flip-flop instantiations\nalways @(posedge clk) begin\n    Q1 <= Q1_next;\n    Q2 <= Q2_next;\n    Q3 <= Q3_next;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Flip-flop outputs\n    wire q_xor, q_and, q_or;\n\n    // Flip-flop inputs calculated by gates\n    wire d_xor, d_and, d_or;\n\n    // Logic gates' outputs that connect to D flip-flop inputs\n    assign d_xor = x ^ q_xor;\n    assign d_and = x & ~q_and;\n    assign d_or = x | ~q_or;\n\n    // D flip-flops\n    always @(posedge clk) begin\n        q_xor <= d_xor;\n        q_and <= d_and;\n        q_or <= d_or;\n    end\n\n    // Output logic\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    // Declaring the flip-flop outputs\n    reg q_xor, q_and, q_or;\n\n    // Wires to hold the outputs of the gates before the flip-flops\n    wire xor_out, and_out, or_out;\n\n    // XOR gate where the second input is its corresponding flip-flop's output\n    assign xor_out = x ^ q_xor;\n\n    // AND gate where the second input is the complement of its corresponding flip-flop's output\n    assign and_out = x & ~q_and;\n\n    // OR gate where the second input is the complement of its corresponding flip-flop's output\n    assign or_out = x | ~q_or;\n\n    // Flip-flops to store the state of each gate output\n    always @(posedge clk) begin\n        q_xor <= xor_out;\n        q_and <= and_out;\n        q_or <= or_out;\n    end\n\n    // Three-input XNOR gate to produce the output z\n    assign z = ~(q_xor ^ q_and ^ q_or);\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    output z\n);\n\n    reg Q1, Q2, Q3;  // Register outputs for the flip-flops\n\n    // Initialize flip-flops to 0\n    initial begin\n        Q1 = 0;\n        Q2 = 0;\n        Q3 = 0;\n    end\n\n    wire XOR_out, AND_out, OR_out;  // Outputs from the gates\n    wire Q1_not, Q2_not, Q3_not;    // Complements of the flip-flop outputs\n\n    // Generate the complement outputs\n    assign Q1_not = ~Q1;\n    assign Q2_not = ~Q2;\n    assign Q3_not = ~Q3;\n\n    // Logic gates\n    assign XOR_out = x ^ Q1;\n    assign AND_out = x & Q2_not;\n    assign OR_out = x | Q3_not;\n\n    // Flip-flops to store the outputs of the gates\n    always @(posedge clk) begin\n        Q1 <= XOR_out;\n        Q2 <= AND_out;\n        Q3 <= OR_out;\n    end\n\n    // XNOR gate to produce the final output \n    assign z = ~(Q1 ^ Q2 ^ Q3);\n\nendmodule\n"]}
{"task_id": "circuit4", "gptgen_RTL": ["module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b) | (b & c) | (c & d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q\n);\n\nassign q = (b | c) & ~d;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    // Implementing the logic based on the simulation waveform analysis\n    assign q = (b | c) & (~a | d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (c | (b & ~a)) & ~d;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\nassign q = (c & ~d) | (b & ~d) | (b & c) | (a & c);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (c & ~d) | (b & ~d) | (a & c) | (a & b);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    // Implementing the combinational logic from the described waveforms\n    assign q = (c & ~d) | (b & ~a) | (a & c) | (b & c) | (a & b);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (c & ~d) | (b & ~a);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (c & ~d) | (b & ~a);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (c & ~d) | (b & ~a) | (a & c) | (b & d);\n\nendmodule\n"]}
{"task_id": "rule110", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\n    always @* begin\n        integer i;\n        for (i = 0; i < 512; i++) begin\n            case ({q[i+1], q[i], q[i-1]})\n                3'b111: next_q[i] = 0;\n                3'b110: next_q[i] = 1;\n                3'b101: next_q[i] = 1;\n                3'b100: next_q[i] = 0;\n                3'b011: next_q[i] = 1;\n                3'b010: next_q[i] = 1;\n                3'b001: next_q[i] = 1;\n                3'b000: next_q[i] = 0;\n            endcase\n        end\n\n        // Handle boundary cases\n        next_q[0] = (q[0] & ~q[1] & q[2]) | (~q[0] & q[1] & q[2]) | (~q[0] & q[1] & ~q[2]) | (~q[0] & ~q[1] & q[2]);\n        next_q[511] = (q[510] & ~q[511] & 0) | (~q[510] & q[511] & 0) | (~q[510] & q[511] & 0) | (~q[510] & ~q[511] & 0);\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\nwire [511:0] q_next;\n\n// Compute next state based on Rule 110\ngenvar i;\ngenerate\n    for (i = 0; i < 512; i = i + 1) begin : rule110\n        wire left, center, right;\n        assign left = (i == 0) ? 0 : q[i-1];\n        assign center = q[i];\n        assign right = (i == 511) ? 0 : q[i+1];\n        \n        // Implement rule 110\n        assign q_next[i] = (left & center & right) ? 0 :\n                           (left & center & ~right) ? 1 :\n                           (left & ~center & right) ? 1 :\n                           (left & ~center & ~right) ? 0 :\n                           (~left & center & right) ? 1 :\n                           (~left & center & ~right) ? 1 :\n                           (~left & ~center & right) ? 1 :\n                           (~left & ~center & ~right) ? 0 : 0;\n    end\nendgenerate\n\n// Load or update logic\nalways @(posedge clk) begin\n    if (load)\n        q <= data;\n    else\n        q <= q_next;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    \n    // Intermediate signal for next state computation\n    wire [511:0] next_q;\n    \n    // Rule 110 computation for each cell\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : cell_rule\n            wire left, center, right;\n            \n            // Boundary conditions\n            assign left = (i == 0) ? 0 : q[i-1];\n            assign center = q[i];\n            assign right = (i == 511) ? 0 : q[i+1];\n            \n            // Rule 110 logic\n            assign next_q[i] = (left & center & right) ? 0 :\n                               (left & center & ~right) ? 1 :\n                               (left & ~center & right) ? 1 :\n                               (left & ~center & ~right) ? 0 :\n                               (~left & center & right) ? 1 :\n                               (~left & center & ~right) ? 1 :\n                               (~left & ~center & right) ? 1 :\n                               (~left & ~center & ~right) ? 0 : 0;\n        end\n    endgenerate\n    \n    // State update logic\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load the state with data when load is high\n        else\n            q <= next_q; // Update the state with the next state\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n// Temporary register to store next state\nreg [511:0] next_state;\n\ninteger i;\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into q when load is high\n        q <= data;\n    end else begin\n        // Compute the next state for each cell\n        for (i = 0; i < 512; i++) begin\n            case ({q[i+1], q[i], i == 0 ? 0 : q[i-1]})\n                3'b111: next_state[i] = 0;\n                3'b110: next_state[i] = 1;\n                3'b101: next_state[i] = 1;\n                3'b100: next_state[i] = 0;\n                3'b011: next_state[i] = 1;\n                3'b010: next_state[i] = 1;\n                3'b001: next_state[i] = 1;\n                3'b000: next_state[i] = 0;\n            endcase\n        end\n        // Update q with the next state\n        q <= next_state;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            next_q[0] = q[1] ^ (q[0] | q[511]);  // Special case for cell 0, assuming q[-1] is 0\n            next_q[511] = q[0] ^ (q[511] | q[510]);  // Special case for cell 511, assuming q[512] is 0\n            // General case for cells 1 to 510\n            for (int i = 1; i < 511; i++) begin\n                next_q[i] = q[i-1] ^ (q[i] | q[i+1]);\n            end\n            q <= next_q;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    wire [511:0] next_state;\n\n    // Compute the next state based on Rule 110\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : rule110\n            wire left = (i == 0) ? 1'b0 : q[i-1];\n            wire center = q[i];\n            wire right = (i == 511) ? 1'b0 : q[i+1];\n\n            assign next_state[i] = (left & center & right) ? 1'b0 :\n                                   (left & center & ~right) ? 1'b1 :\n                                   (left & ~center & right) ? 1'b1 :\n                                   (left & ~center & ~right) ? 1'b0 :\n                                   (~left & center & right) ? 1'b1 :\n                                   (~left & center & ~right) ? 1'b1 :\n                                   (~left & ~center & right) ? 1'b1 :\n                                   (~left & ~center & ~right) ? 1'b0 : 1'b0;\n        end\n    endgenerate\n\n    // Load or update the state of the cells\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_state;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        integer i;\n        for (i = 0; i < 512; i++) begin\n            case ({q[i+1], q[i], i == 0 ? 0 : q[i-1]})\n                3'b111: q[i] <= 1'b0;\n                3'b110: q[i] <= 1'b1;\n                3'b101: q[i] <= 1'b1;\n                3'b100: q[i] <= 1'b0;\n                3'b011: q[i] <= 1'b1;\n                3'b010: q[i] <= 1'b1;\n                3'b001: q[i] <= 1'b1;\n                3'b000: q[i] <= 1'b0;\n            endcase\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to calculate the next state\n    wire [511:0] next_q;\n\n    // Rule 110 logic\n    genvar i;\n    generate\n        for (i = 0; i < 512; i = i + 1) begin : rule110\n            wire left, center, right;\n            \n            // Assign neighbors, handling edge cases\n            assign left = (i == 0) ? 0 : q[i-1];\n            assign center = q[i];\n            assign right = (i == 511) ? 0 : q[i+1];\n\n            // Rule 110 computation\n            assign next_q[i] = (left & center & right) ? 0 :\n                               (left & center & ~right) ? 1 :\n                               (left & ~center & right) ? 1 :\n                               (left & ~center & ~right) ? 0 :\n                               (~left & center & right) ? 1 :\n                               (~left & center & ~right) ? 1 :\n                               (~left & ~center & right) ? 1 :\n                               (~left & ~center & ~right) ? 0 : 0;\n        end\n    endgenerate\n\n    // Latch the calculated next state or load data on each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            next_q[0] = q[1] ^ (q[0] | q[511]);  // Handling boundary case for the first cell\n            next_q[511] = q[510] ^ (q[511] | q[0]);  // Handling boundary case for the last cell\n            \n            // Calculating the next state for all other cells\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : gen_rule110\n                    always @(*) begin\n                        next_q[i] = q[i-1] ^ (q[i] | q[i+1]);\n                    end\n                end\n            endgenerate\n\n            q <= next_q;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to hold next state\n    reg [511:0] next_state;\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when load is high\n            q <= data;\n        end else begin\n            // Update each cell according to Rule 110\n            for (i = 0; i < 512; i++) begin\n                case ({q[i+1], q[i], i == 0 ? 0 : q[i-1]})\n                    3'b111: next_state[i] = 1'b0;\n                    3'b110: next_state[i] = 1'b1;\n                    3'b101: next_state[i] = 1'b1;\n                    3'b100: next_state[i] = 1'b0;\n                    3'b011: next_state[i] = 1'b1;\n                    3'b010: next_state[i] = 1'b1;\n                    3'b001: next_state[i] = 1'b1;\n                    3'b000: next_state[i] = 1'b0;\n                    default: next_state[i] = 1'b0; // Default case should not occur\n                endcase\n            end\n            // Update the state of q with next state\n            q <= next_state;\n        end\n    end\n\nendmodule\n"]}
{"task_id": "circuit5", "gptgen_RTL": ["module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case(c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'bx; // For c=4,5,6,... this handles unspecified cases in the table, assuming 'x' as don't care\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @* begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'f; // for c = 4, 5, 6,...,f\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hf; // For c = 4, 5, 6, ..., f\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hf; // Assign 'f' for other values of 'c'\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n    \n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hf; // When c is 4 to f, q is f\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'h0: q = b;\n            4'h1: q = e;\n            4'h2: q = a;\n            4'h3: q = d;\n            default: q = 4'hf; // Output 'f' for all other values of c\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'bx; // For c from 4 to f (inclusive), q is x (undefined)\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] a,\n    input [3:0] b,\n    input [3:0] c,\n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case (c)\n        4'b0000: q = b;\n        4'b0001: q = e;\n        4'b0010: q = a;\n        4'b0011: q = d;\n        default: q = 4'b1111; // assuming 'f' is 4'b1111\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\nalways @(*) begin\n    case (c)\n        4'h0: q = b;\n        4'h1: q = e;\n        4'h2: q = a;\n        4'h3: q = d;\n        default: q = 4'hf; // For c = 4, 5, 6, ..., e, f\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] a, \n    input [3:0] b, \n    input [3:0] c, \n    input [3:0] d,\n    input [3:0] e,\n    output reg [3:0] q\n);\n\n    always @(*) begin\n        case (c)\n            4'd0: q = b;\n            4'd1: q = e;\n            4'd2: q = a;\n            4'd3: q = d;\n            default: q = 4'xf; // 'f' for undefined cases\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "bugs_mux2", "gptgen_RTL": ["module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(*) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(sel, a, b) begin\n        if (sel)\n            out = b;\n        else\n            out = a;\n    end\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(sel, a, b) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\n    always @(sel, a, b) begin\n        if (sel) \n            out = b;\n        else \n            out = a;\n    end\n\nendmodule\n", "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\nalways @(*) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    if (sel == 1'b0)\n        out = a;\n    else\n        out = b;\nend\n\nendmodule\n", "module top_module (\n    input sel,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out\n);\n\nalways @(*) begin\n    if (sel)\n        out = b;\n    else\n        out = a;\nend\n\nendmodule\n"]}
{"task_id": "mt2015_muxdff", "gptgen_RTL": ["module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= q_in;\n        end\n    end\nendmodule\n\nmodule full_module(\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n    wire q_1_xor_q_2 = q[1] ^ q[2];\n\n    top_module tm0(\n        .clk(clk),\n        .L(L),\n        .q_in(q_1_xor_q_2),\n        .r_in(r[0]),\n        .Q(q[0])\n    );\n\n    top_module tm1(\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),\n        .r_in(r[1]),\n        .Q(q[1])\n    );\n\n    top_module tm2(\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),\n        .r_in(r[2]),\n        .Q(q[2])\n    );\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= q_in;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\nendmodule\n\nmodule full_module(\n    input [2:0] r,\n    input L,\n    input clk,\n    output [2:0] q\n);\n    wire [2:0] q_next;\n\n    // Instantiate top_module for each bit\n    top_module ff0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1] ^ q[2]),  // q_next for q[0]\n        .r_in(r[0]),\n        .Q(q_next[0])\n    );\n\n    top_module ff1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),          // q_next for q[1]\n        .r_in(r[1]),\n        .Q(q_next[1])\n    );\n\n    top_module ff2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),          // q_next for q[2]\n        .r_in(r[2]),\n        .Q(q_next[2])\n    );\n\n    // Register output\n    always @(posedge clk) begin\n        q <= q_next;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (L) \n            Q <= r_in;\n        else \n            Q <= q_in;\n    end\n\nendmodule\n\nmodule full_module (\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n\n    wire [2:0] q_next;\n\n    top_module ff0 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[1] ^ q[2]),  // Corresponding to {q[1] ^ q[2], q[0], q[2]} in the original description\n        .r_in(r[0]),\n        .Q(q_next[0])\n    );\n\n    top_module ff1 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[0]),  // Corresponding to {q[1] ^ q[2], q[0], q[2]} in the original description\n        .r_in(r[1]),\n        .Q(q_next[1])\n    );\n\n    top_module ff2 (\n        .clk(clk),\n        .L(L),\n        .q_in(q[2]),  // Corresponding to {q[1] ^ q[2], q[0], q[2]} in the original description\n        .r_in(r[2]),\n        .Q(q_next[2])\n    );\n\n    always @(posedge clk) begin\n        q <= q_next;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L)\n        Q <= r_in;\n    else\n        Q <= q_in;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n// Flip-flop to hold state\nalways @(posedge clk) begin\n    if (L)\n        Q <= r_in;  // Load the input directly into the register\n    else\n        Q <= q_in;  // Load internal state into the register\nend\n\nendmodule\n\nmodule full_module(\n    input [2:0] r,\n    input L,\n    input clk,\n    output reg [2:0] q\n);\n\n// Instantiation of the submodule \"top_module\"\nwire [2:0] q_next;\n\n// Calculate the next state of q\nassign q_next[2] = q[1] ^ q[2]; // XOR operation for feedback\nassign q_next[1] = q[0];\nassign q_next[0] = q[2];\n\n// Instantiate three submodules for each bit of q\ntop_module bit2 (\n    .clk(clk),\n    .L(L),\n    .q_in(q_next[2]),\n    .r_in(r[2]),\n    .Q(q[2])\n);\n\ntop_module bit1 (\n    .clk(clk),\n    .L(L),\n    .q_in(q_next[1]),\n    .r_in(r[1]),\n    .Q(q[1])\n);\n\ntop_module bit0 (\n    .clk(clk),\n    .L(L),\n    .q_in(q_next[0]),\n    .r_in(r[0]),\n    .Q(q[0])\n);\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (L)\n            Q <= r_in;\n        else\n            Q <= q_in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input L,\n    input q_in,\n    input r_in,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= r_in;\n        end else begin\n            Q <= q_in;\n        end\n    end\n\nendmodule\n"]}
{"task_id": "edgecapture", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] in_prev;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        in_prev <= 32'b0;\n    end else begin\n        in_prev <= in;  // Store the current input to use in the next clock cycle\n        out <= (out | ((in_prev & ~in) & ~(out)));  // Capture the falling edge and update output\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0;\n        prev_in <= 32'b0;\n    end else begin\n        out <= (prev_in & ~in) | out; // Capture the transition and hold it until reset\n        prev_in <= in; // Store current input to compare in next cycle\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    // Register to hold the previous state of 'in'\n    reg [31:0] prev_in;\n\n    // Process block for edge detection and capturing\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset output and previous state on reset signal\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            // Loop through each bit of the input vector\n            for (int i = 0; i < 32; i++) begin\n                // Check for a falling edge (1 to 0 transition)\n                if (prev_in[i] && !in[i]) begin\n                    // Set the corresponding output bit if a falling edge is detected\n                    out[i] <= 1'b1;\n                end\n            end\n            // Update previous state of 'in' after checking edges\n            prev_in <= in;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    // Register to hold the previous state of 'in'\n    reg [31:0] previous_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // If reset is high, set 'out' to 0\n            out <= 32'b0;\n            // Also reset the previous_in to prevent false positives after reset\n            previous_in <= 32'b0;\n        end else begin\n            // Capture the falling edge from 1 to 0 for each bit\n            out <= (previous_in & ~in) | out;\n            // Update previous_in to current in for next comparison\n            previous_in <= in;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    reg [31:0] previous_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            previous_in <= 32'b0;\n        end else begin\n            // Capture a change from 1 to 0 across each bit of the input vector\n            out <= (previous_in & ~in) | out;  // Set output bits where a 1->0 transition occurs; retain previous set bits\n            previous_in <= in;  // Update stored previous input state\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    // Register to hold the previous value of the input vector\n    reg [31:0] previous_in;\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Clear the output on reset\n            out <= 32'b0;\n            previous_in <= 32'b0;\n        end else begin\n            for (i = 0; i < 32; i = i + 1) begin\n                // Check for transition from 1 to 0\n                if (previous_in[i] && !in[i]) begin\n                    out[i] <= 1'b1;\n                end\n            end\n            // Update the previous input\n            previous_in <= in;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    reg [31:0] previous_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 32'b0;\n            previous_in <= 32'b0;\n        end else begin\n            // For each bit, check if previous was 1 and current is 0\n            out <= (previous_in & ~in) | out;\n            previous_in <= in; // Store current input to previous\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in; // To store the previous state of the input\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'b0; // Reset the output when reset signal is high\n        prev_in <= 32'b0; // Also reset the previous input storage\n    end else begin\n        // Check each bit for the specified condition\n        out <= (prev_in & ~in) | out; // Set out bit to 1 if condition met or keep previous out\n        prev_in <= in; // Update previous input to current input\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\nreg [31:0] prev_in;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        out <= 32'd0;\n        prev_in <= 32'd0;\n    end else begin\n        prev_in <= in;\n        out <= out | ((prev_in & ~in) & ~out);\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input [31:0] in,\n    output reg [31:0] out\n);\n\n    // Register to hold the previous state of 'in'\n    reg [31:0] prev_in;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the output and the previous input state\n            out <= 32'b0;\n            prev_in <= 32'b0;\n        end else begin\n            // Loop through each bit to detect edge\n            integer i;\n            for (i = 0; i < 32; i = i + 1) begin\n                // Check if the previous state was 1 and current state is 0\n                if (prev_in[i] == 1'b1 && in[i] == 1'b0) begin\n                    out[i] <= 1'b1;  // Set the output bit\n                end\n            end\n            // Update previous input state\n            prev_in <= in;\n        end\n    end\n\nendmodule\n"]}
{"task_id": "dff8", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n"]}
{"task_id": "ece241_2014_q1c", "gptgen_RTL": ["module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b;\n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    assign s = a + b; \n    assign overflow = (a[7] & b[7] & ~s[7]) | (~a[7] & ~b[7] & s[7]);\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Signed addition\n    assign s = a + b;\n\n    // Check for overflow\n    // Overflow occurs if both inputs have the same sign and the sign of the sum is different\n    assign overflow = ((a[7] == b[7]) && (s[7] != a[7]));\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Intermediate signal for extended addition\n    wire [8:0] sum_extended;\n\n    // Perform the addition with an extra bit to capture any overflow\n    assign sum_extended = {a[7], a} + {b[7], b};\n\n    // Assign the lower 8 bits to the output sum\n    assign s = sum_extended[7:0];\n\n    // Check for overflow:\n    // Overflow occurs if the sign bits of the inputs are the same and different from the sign bit of the sum\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Intermediate sum of a and b (9 bits to account for carry)\n    wire [8:0] sum;\n\n    assign sum = {a[7], a} + {b[7], b};  // Include sign bit for overflow detection\n    assign s = sum[7:0];  // Assign the lowest 8 bits to output sum\n\n    // Overflow occurs when the sign bits of the inputs are the same but different from the result's sign bit\n    assign overflow = (a[7] ~^ b[7]) & (a[7] ^ sum[8]);\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Sum of a and b\n    assign s = a + b;\n\n    // Detecting overflow\n    // Overflow occurs if sign of a equals sign of b, but sign of s differs\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n\n    // Signed addition of 8-bit numbers\n    wire [8:0] sum_extended = {a[7], a} + {b[7], b};\n    assign s = sum_extended[7:0];\n\n    // Overflow occurs if the signs of the inputs are the same and the sign of the result is different\n    assign overflow = (a[7] == b[7]) && (s[7] != a[7]);\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Intermediate signal to hold the sum\n    wire [8:0] sum;\n\n    // Compute the sum of a and b, extended by one bit to detect overflow\n    assign sum = {a[7], a} + {b[7], b};\n\n    // The output sum is the lower 8 bits of the intermediate sum\n    assign s = sum[7:0];\n\n    // Overflow occurs if the sign bits (bit 8) of the inputs and the sum are not consistent\n    assign overflow = (a[7] == b[7]) && (sum[8] != a[7]);\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] s,\n    output overflow\n);\n    // Intermediate sum without considering carry\n    wire [8:0] sum = {a[7], a} + {b[7], b}; // Include sign bit for overflow detection\n\n    // Assign output sum\n    assign s = sum[7:0]; // Lower 8 bits are the actual sum of a and b\n\n    // Check for overflow\n    // Overflow occurs if the sign bits of the inputs are the same and different from the sign bit of the sum\n    assign overflow = (a[7] == b[7]) && (sum[8] != a[7]);\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] s,\n    output reg overflow\n);\n    // Temporary variable to hold the sum calculation\n    reg [8:0] sum_temp;\n\n    always @ (a or b) begin\n        sum_temp = {a[7], a} + {b[7], b};  // Perform addition with sign extension\n        s = sum_temp[7:0];  // Assign the lower 8 bits to s\n\n        // Check for overflow: overflow happens if the signs of the inputs are the same\n        // and the sign of the result is different from the signs of the inputs\n        overflow = ((a[7] == b[7]) && (sum_temp[8] != a[7]));\n    end\nendmodule\n"]}
{"task_id": "review2015_fsmonehot", "gptgen_RTL": ["module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n// State definition using one-hot encoding\nwire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\nassign S = state[0];\nassign S1 = state[1];\nassign S11 = state[2];\nassign S110 = state[3];\nassign B0 = state[4];\nassign B1 = state[5];\nassign B2 = state[6];\nassign B3 = state[7];\nassign Count = state[8];\nassign Wait = state[9];\n\n// Next-state logic\nassign S_next = (S && !d) || (S1 && !d) || (S11 && !d) || (S110 && !d) || (Wait && ack);\nassign S1_next = (S && d);\nassign S11_next = (S1 && d);\nassign S110_next = (S11 && !d);\nassign B0_next = (S110 && d);\nassign B1_next = B0;\nassign B2_next = B1;\nassign B3_next = B2;\nassign Count_next = (B3 || (Count && !done_counting));\nassign Wait_next = (Count && done_counting) || Wait;\n\n// Output logic\nassign shift_ena = B0 || B1 || B2 || B3;\nassign counting = Count;\nassign done = Wait;\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State Definitions (One-hot)\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign S     = state[0];\n    assign S1    = state[1];\n    assign S11   = state[2];\n    assign S110  = state[3];\n    assign B0    = state[4];\n    assign B1    = state[5];\n    assign B2    = state[6];\n    assign B3    = state[7];\n    assign Count = state[8];\n    assign Wait  = state[9];\n\n    // Next State Logic\n    assign S_next     = (S && ~d) || (S1 && ~d) || (S110 && ~d) || (B3 && ack);\n    assign S1_next    = (S && d);\n    assign S11_next   = (S1 && d);\n    assign S110_next  = (S11 && ~d);\n    assign B0_next    = (S110 && d);\n    assign B1_next    = B0;\n    assign B2_next    = B1;\n    assign B3_next    = B2;\n    assign Count_next = (B3 && ~done_counting) || (Count && ~done_counting);\n    assign Wait_next  = (Count && done_counting) || (Wait && ~ack);\n\n    // Output Logic\n    assign done       = Wait;\n    assign counting   = Count;\n    assign shift_ena  = B0 || B1 || B2 || B3;\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n\n    // Assigning states to each bit position\n    assign S = state[0];\n    assign S1 = state[1];\n    assign S11 = state[2];\n    assign S110 = state[3];\n    assign B0 = state[4];\n    assign B1 = state[5];\n    assign B2 = state[6];\n    assign B3 = state[7];\n    assign Count = state[8];\n    assign Wait = state[9];\n\n    // Next-state logic\n    assign S_next = (S && !d) || (S1 && !d) || (S110 && !d) || (B3 && ack);\n    assign S1_next = (S && d);\n    assign B3_next = (B2);\n    assign Count_next = (B3) || (Count && !done_counting);\n    assign Wait_next = (Count && done_counting) || (Wait && !ack);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 || B1 || B2 || B3;\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n\n    // Assign the state bits for clarity\n    assign S     = state[0];\n    assign S1    = state[1];\n    assign S11   = state[2];\n    assign S110  = state[3];\n    assign B0    = state[4];\n    assign B1    = state[5];\n    assign B2    = state[6];\n    assign B3    = state[7];\n    assign Count = state[8];\n    assign Wait  = state[9];\n\n    // Output logic equations\n    assign shift_ena = B0 | B1 | B2 | B3;\n    assign counting = Count;\n    assign done = Wait;\n\n    // Next state logic equations\n    assign B3_next = B3;\n    assign S_next = (S & ~d) | (S1 & ~d) | (S11 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = (S & d);\n    assign Count_next = (Count & ~done_counting) | B3;\n    assign Wait_next = (Count & done_counting);\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n\n    // Assign each state variable to correspond to each bit in the state vector\n    assign S     = state[0];\n    assign S1    = state[1];\n    assign S11   = state[2];\n    assign S110  = state[3];\n    assign B0    = state[4];\n    assign B1    = state[5];\n    assign B2    = state[6];\n    assign B3    = state[7];\n    assign Count = state[8];\n    assign Wait  = state[9];\n\n    // State transitions\n    assign S_next = (S && !d) || (S1 && !d) || (S110 && !d) || (B3 && !ack);\n    assign S1_next = (S && d);\n    assign Count_next = (B3 && d) || (Count && !done_counting);\n    assign Wait_next = (Count && done_counting) || (Wait && !ack);\n\n    // B3_next logic\n    assign B3_next = (B2 && d);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 || B1 || B2 || B3;\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output reg B3_next,\n    output reg S_next,\n    output reg S1_next,\n    output reg Count_next,\n    output reg Wait_next,\n    output reg done,\n    output reg counting,\n    output reg shift_ena\n);\n\n    // Assigning next state logic\n    always @(*) begin\n        // Default values for next states\n        B3_next = 0;\n        S_next = 0;\n        S1_next = 0;\n        Count_next = 0;\n        Wait_next = 0;\n\n        // State transitions\n        case (1'b1) // Use 1'b1 for unconditional matching in one-hot encoding\n            state[0]: begin // In state 'S'\n                if (d == 0) S_next = 1;\n                else if (d == 1) S1_next = 1;\n            end\n            state[1]: begin // In state 'S1'\n                if (d == 0) S_next = 1;\n                else if (d == 1) S1_next = 1;  // This should lead to S11, not S1. Adjust encoding if necessary.\n            end\n            state[2]: begin // In state 'S11'\n                if (d == 0) S_next = 1;\n                else if (d == 1) S1_next = 1;  // This should lead to S11, adjust encoding if necessary.\n            end\n            state[3]: begin // In state 'S110'\n                if (d == 0) S_next = 1;\n                else if (d == 1) S1_next = 1;  // This should lead to B0, adjust encoding if necessary.\n            end\n            state[4]: B3_next = 1; // B0 always transitions to B1 (next state B3)\n            state[5]: B3_next = 1; // B1\n            state[6]: B3_next = 1; // B2\n            state[7]: begin // B3\n                if (1) // unconditional\n                    Count_next = 1;\n            end\n            state[8]: begin // Count\n                if (!done_counting) Count_next = 1;\n                else Wait_next = 1;\n            end\n            state[9]: begin // Wait\n                if (!ack) Wait_next = 1;\n                else S_next = 1;\n            end\n        endcase\n    end\n\n    // Assigning output logic\n    always @(*) begin\n        // Default output values\n        done = 0;\n        counting = 0;\n        shift_ena = 0;\n\n        // Output logic based on current state\n        case (1'b1) // Simplified one-hot case matching\n            state[4]: shift_ena = 1; // B0\n            state[5]: shift_ena = 1; // B1\n            state[6]: shift_ena = 1; // B2\n            state[7]: shift_ena = 1; // B3\n            state[8]: counting = 1; // Count\n            state[9]: done = 1; // Wait\n        endcase\n    end\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // Assigning each bit of the state to individual state variables\n    wire S    = state[0];\n    wire S1   = state[1];\n    wire S11  = state[2];\n    wire S110 = state[3];\n    wire B0   = state[4];\n    wire B1   = state[5];\n    wire B2   = state[6];\n    wire B3   = state[7];\n    wire Count= state[8];\n    wire Wait = state[9];\n\n    // Next state logic\n    assign S_next = (S & ~d) | (S1 & ~d) | (S11 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = (S & d);\n    assign S11_next = (S1 & d);\n    assign S110_next = (S11 & ~d);\n    assign B0_next = (S110 & d);\n    assign B1_next = (B0);\n    assign B2_next = (B1);\n    assign B3_next = (B2);\n    assign Count_next = (B3) | (Count & !done_counting);\n    assign Wait_next = (Count & done_counting);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = (B0 | B1 | B2 | B3);\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // State definitions for clarity\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    assign S = state[0];\n    assign S1 = state[1];\n    assign S11 = state[2];\n    assign S110 = state[3];\n    assign B0 = state[4];\n    assign B1 = state[5];\n    assign B2 = state[6];\n    assign B3 = state[7];\n    assign Count = state[8];\n    assign Wait = state[9];\n\n    // Next state logic\n    assign S_next = (S & ~d) | (S1 & ~d) | (S110 & ~d) | (Wait & ack);\n    assign S1_next = (S & d);\n    assign B3_next = (B2);  // B2 always transitions to B3\n    assign Count_next = (Count & ~done_counting) | (B3);\n    assign Wait_next = (Count & done_counting);\n\n    // Output logic\n    assign done = Wait;\n    assign counting = Count;\n    assign shift_ena = B0 | B1 | B2 | B3;\n\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output reg B3_next,\n    output reg S_next,\n    output reg S1_next,\n    output reg Count_next,\n    output reg Wait_next,\n    output reg done,\n    output reg counting,\n    output reg shift_ena\n);\n\n    // State definitions for clarity and ease of reading\n    wire S, S1, S11, S110, B0, B1, B2, B3, Count, Wait;\n    \n    // Assign state wires based on the one-hot encoding\n    assign S = state[0];\n    assign S1 = state[1];\n    assign S11 = state[2];\n    assign S110 = state[3];\n    assign B0 = state[4];\n    assign B1 = state[5];\n    assign B2 = state[6];\n    assign B3 = state[7];\n    assign Count = state[8];\n    assign Wait = state[9];\n\n    // Output and next state logic\n    always @(*) begin\n        // Default disable all next states and outputs\n        B3_next = 0;\n        S_next = 0;\n        S1_next = 0;\n        Count_next = 0;\n        Wait_next = 0;\n        done = 0;\n        counting = 0;\n        shift_ena = 0;\n\n        // State transition logic\n        if (S) begin\n            if (!d) S_next = 1;\n            else S1_next = 1;\n        end\n        if (S1) begin\n            if (!d) S_next = 1;\n            else S11_next = 1;\n        end\n        if (S11) begin\n            if (!d) S110_next = 1;\n            else S11_next = 1;\n        end\n        if (S110) begin\n            if (!d) S_next = 1;\n            else B0_next = 1;\n        end\n        if (B0) begin\n            B1_next = 1;\n            shift_ena = 1;\n        end\n        if (B1) begin\n            B2_next = 1;\n            shift_ena = 1;\n        end\n        if (B2) begin\n            B3_next = 1;\n            shift_ena = 1;\n        end\n        if (B3) begin\n            Count_next = 1;\n            shift_ena = 1;\n        end\n        if (Count) begin\n            if (!done_counting) Count_next = 1;\n            else Wait_next = 1;\n            counting = 1;\n        end \n        if (Wait) begin\n            if (!ack) Wait_next = 1;\n            else S_next = 1;\n            done = 1;\n        end\n    end\nendmodule\n", "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n);\n\n    // Assign next state logic based on current state and input.\n    assign S_next = (state[9] & ack) | (state[0] & ~d) | (state[3] & ~d);\n    assign S1_next = (state[0] & d);\n    assign B3_next = state[7];\n    assign Count_next = (state[8] & ~done_counting);\n    assign Wait_next = (state[9] & ~ack) | (state[8] & done_counting);\n\n    // Output logic\n    assign done = state[9];\n    assign counting = state[8];\n    assign shift_ena = state[4] | state[5] | state[6] | state[7];\n\nendmodule\n"]}
{"task_id": "counter_2bc", "gptgen_RTL": ["module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output reg [1:0] state\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Asynchronous reset to 2'b01\n        state <= 2'b01;\n    end\n    else begin\n        if (train_valid) begin\n            if (train_taken) begin\n                // Increment state but saturate at 2'b11\n                if (state != 2'b11) begin\n                    state <= state + 1;\n                end\n            end else begin\n                // Decrement state but do not go below 2'b00\n                if (state != 2'b00) begin\n                    state <= state - 1;\n                end\n            end\n        end\n        // When train_valid is 0, retain the current state\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    // Define internal register to hold the state\n    reg [1:0] current_state;\n\n    // Assign the internal register to the output\n    assign state = current_state;\n\n    // Synchronous block for state update\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronously reset to 2'b01\n            current_state <= 2'b01;\n        end else begin\n            // Check if training is valid\n            if (train_valid) begin\n                if (train_taken) begin\n                    // Increment state up to a maximum of 3\n                    if (current_state < 2'b11) begin\n                        current_state <= current_state + 1;\n                    end\n                end else begin\n                    // Decrement state down to a minimum of 0\n                    if (current_state > 2'b00) begin\n                        current_state <= current_state - 1;\n                    end\n                end\n            end\n            // If train_valid is not high, retain the current state\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end \n        else if (train_valid) begin\n            if (train_taken && state != 2'b11) begin\n                state <= state + 1;\n            end\n            else if (!train_taken && state != 2'b00) begin\n                state <= state - 1;\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output reg [1:0] state\n);\n    // Initialize state to weakly not-taken (2'b01) on asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;\n        end\n        else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    // Increment state up to a maximum of 3\n                    if (state < 2'b11) begin\n                        state <= state + 1;\n                    end\n                end\n                else begin\n                    // Decrement state down to a minimum of 0\n                    if (state > 2'b00) begin\n                        state <= state - 1;\n                    end\n                end\n            end\n            // When train_valid is 0, keep the state unchanged\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\n// Counter definition\nalways_ff @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= 2'b01; // Asynchronously reset state to 01\n    else if (train_valid) begin\n        if (train_taken) begin\n            if (state < 2'b11)\n                state <= state + 1; // Increment state unless it is already at maximum (3)\n        end\n        else begin\n            if (state > 2'b00)\n                state <= state - 1; // Decrement state unless it is already at minimum (0)\n        end\n    end\n    // When train_valid is 0, retain the current state\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n\nalways_ff @(posedge clk, posedge areset) begin\n    if (areset) begin\n        state <= 2'b01;\n    end\n    else if (train_valid) begin\n        if (train_taken) begin\n            if (state != 2'b11) // check if state is less than 3\n                state <= state + 1;\n        end else begin\n            if (state != 2'b00) // check if state is greater than 0\n                state <= state - 1;\n        end\n    end\n    // when train_valid is 0, state remains unchanged\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01; // Reset state to 01\n        end else if (train_valid) begin\n            if (train_taken) begin\n                if (state != 2'b11) begin\n                    state <= state + 1; // Increment state if not at maximum\n                end\n            end else begin\n                if (state != 2'b00) begin\n                    state <= state - 1; // Decrement state if not at minimum\n                end\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output reg [1:0] state\n);\n    // Initial state\n    initial state = 2'b01;\n\n    // Asynchronous reset on positive edge of areset\n    always @(posedge areset or posedge clk) begin\n        if (areset) begin\n            state <= 2'b01;\n        end\n        else if (train_valid) begin\n            if (train_taken) begin\n                if (state < 2'b11) begin\n                    state <= state + 1'b1;  // Increment the counter, saturating at 3\n                end\n            end\n            else begin\n                if (state > 2'b00) begin\n                    state <= state - 1'b1;  // Decrement the counter, saturating at 0\n                end\n            end\n        end\n        // When train_valid is 0, keep the state unchanged\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output reg [1:0] state\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= 2'b01;  // Set the state to 2'b01 on asynchronous reset\n        end\n        else if (train_valid) begin\n            if (train_taken && state != 2'b11) begin\n                state <= state + 2'b01;  // Increment the state by 1, saturating at 3\n            end\n            else if (!train_taken && state != 2'b00) begin\n                state <= state - 2'b01;  // Decrement the state by 1, saturating at 0\n            end\n        end\n        // When train_valid is 0, state remains unchanged\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    // Define the maximum and minimum values for the saturating counter\n    localparam [1:0] MAX_COUNT = 2'b11;\n    localparam [1:0] MIN_COUNT = 2'b00;\n\n    // Register to store the current state\n    logic [1:0] current_state;\n\n    // Assign the current state to the output\n    assign state = current_state;\n\n    // Process for handling the counter logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronous reset to weakly not-taken (01)\n            current_state <= 2'b01;\n        end\n        else begin\n            if (train_valid) begin\n                if (train_taken) begin\n                    // Increment the counter up to a maximum of 3\n                    if (current_state != MAX_COUNT) begin\n                        current_state <= current_state + 1;\n                    end\n                end\n                else begin\n                    // Decrement the counter down to a minimum of 0\n                    if (current_state != MIN_COUNT) begin\n                        current_state <= current_state - 1;\n                    end\n                end\n            end\n            // If train_valid is not asserted, retain the current value\n        end\n    end\n\nendmodule\n"]}
{"task_id": "always_casez", "gptgen_RTL": ["module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'b???????1: pos = 3'd0;\n            8'b??????10: pos = 3'd1;\n            8'b?????100: pos = 3'd2;\n            8'b????1000: pos = 3'd3;\n            8'b???10000: pos = 3'd4;\n            8'b??100000: pos = 3'd5;\n            8'b?1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // Output 0 when no bits are high\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default:     pos = 3'd0; // Return 0 when no bits are 1\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'bzzzzzzz1: pos = 3'd0;\n            8'bzzzzzz10: pos = 3'd1;\n            8'bzzzzz100: pos = 3'd2;\n            8'bzzzz1000: pos = 3'd3;\n            8'bzzz10000: pos = 3'd4;\n            8'bzz100000: pos = 3'd5;\n            8'bz1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\nalways @(*) begin\n    casez (in)\n        8'b00000001: pos = 3'd0;\n        8'b0000001?: pos = 3'd1;\n        8'b000001??: pos = 3'd2;\n        8'b00001???: pos = 3'd3;\n        8'b0001????: pos = 3'd4;\n        8'b001?????: pos = 3'd5;\n        8'b01??????: pos = 3'd6;\n        8'b1???????: pos = 3'd7;\n        default: pos = 3'd0; // Output zero if no bits are high\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n    \n    always @(*) begin\n        casez (in)\n            8'bzzzzzzz1: pos = 3'd0;\n            8'bzzzzzz10: pos = 3'd1;\n            8'bzzzzz100: pos = 3'd2;\n            8'bzzzz1000: pos = 3'd3;\n            8'bzzz10000: pos = 3'd4;\n            8'bzz100000: pos = 3'd5;\n            8'bz1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // Output 0 if no bits are high\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casex (in)\n            8'bxxxxxxx1: pos = 3'd0;\n            8'bxxxxxx10: pos = 3'd1;\n            8'bxxxxx100: pos = 3'd2;\n            8'bxxxx1000: pos = 3'd3;\n            8'bxxx10000: pos = 3'd4;\n            8'bxx100000: pos = 3'd5;\n            8'bx1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'b00000001: pos = 3'd0;\n            8'b0000001?: pos = 3'd1;\n            8'b000001??: pos = 3'd2;\n            8'b00001???: pos = 3'd3;\n            8'b0001????: pos = 3'd4;\n            8'b001?????: pos = 3'd5;\n            8'b01??????: pos = 3'd6;\n            8'b1???????: pos = 3'd7;\n            default: pos = 3'd0; // when all bits are zero\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'bzzzzzzz1: pos = 3'd0;\n            8'bzzzzzz10: pos = 3'd1;\n            8'bzzzzz100: pos = 3'd2;\n            8'bzzzz1000: pos = 3'd3;\n            8'bzzz10000: pos = 3'd4;\n            8'bzz100000: pos = 3'd5;\n            8'bz1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // default case when all bits are 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            8'bzzzzzzz1: pos = 3'd0;\n            8'bzzzzzz10: pos = 3'd1;\n            8'bzzzzz100: pos = 3'd2;\n            8'bzzzz1000: pos = 3'd3;\n            8'bzzz10000: pos = 3'd4;\n            8'bzz100000: pos = 3'd5;\n            8'bz1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // output zero if no bits are high\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output reg [2:0] pos\n);\n\n    always @(in) begin\n        casex (in)\n            8'bxxxxxxx1: pos = 3'd0;\n            8'bxxxxxx10: pos = 3'd1;\n            8'bxxxxx100: pos = 3'd2;\n            8'bxxxx1000: pos = 3'd3;\n            8'bxxx10000: pos = 3'd4;\n            8'bxx100000: pos = 3'd5;\n            8'bx1000000: pos = 3'd6;\n            8'b10000000: pos = 3'd7;\n            default: pos = 3'd0; // Output zero if no bits are high.\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "history_shift", "gptgen_RTL": ["module top_module(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output reg [31:0] predict_history,\n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end\n    else if (train_mispredicted) begin\n        predict_history <= {train_history[30:0], train_taken};\n    end\n    else if (predict_valid) begin\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    // Flop to store the current history\n    logic [31:0] history_reg;\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronously reset the history register to zero\n            history_reg <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // If a branch misprediction occurred, reset history to the corrected state\n            history_reg <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            // Shift in the new prediction at the LSB, moving the rest up\n            history_reg <= {history_reg[30:0], predict_taken};\n        end\n    end\n\n    // Output the current state of the history register\n    assign predict_history = history_reg;\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n\n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'd0;\n        end else if (train_mispredicted) begin\n            // Load the train history and concatenate the actual result of the branch\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            // Shift in predict_taken from the LSB side\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n\n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        predict_history <= 32'b0;\n    end else if (train_mispredicted) begin\n        // Rollback the history to state before misprediction and append actual outcome\n        predict_history <= {train_history[30:0], train_taken};\n    end else if (predict_valid) begin\n        // Shift the history register and input the new branch outcome at LSB\n        predict_history <= {predict_history[30:0], predict_taken};\n    end\nend\n\nendmodule\n", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n\n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    // Initialize the 32-bit register to hold the branch history\n    logic [31:0] history_register;\n\n    // Asynchronous reset and updating logic\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Reset the history register when asynchronous reset is asserted\n            history_register <= 32'b0;\n        end\n        else if (train_mispredicted) begin\n            // If there is a branch misprediction, load the history_register\n            // with the value before the mispredicted branch and the actual outcome\n            history_register <= {train_history[30:0], train_taken};\n        end\n        else if (predict_valid) begin\n            // If a prediction is made, shift the history_register left\n            // and insert the new prediction result at the LSB (least significant bit)\n            history_register <= {history_register[30:0], predict_taken};\n        end\n    end\n\n    // Drive the output with the current value of the history register\n    assign predict_history = history_register;\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end \n        else if (train_mispredicted) begin\n            predict_history <= {train_history[30:0], train_taken};\n        end \n        else if (predict_valid) begin\n            predict_history <= {predict_history[30:0], predict_taken};\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n\n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n\n    always_ff @(posedge clk or posedge areset) begin\n        if (areset) begin\n            predict_history <= 32'b0;\n        end else if (train_mispredicted) begin\n            predict_history <= (train_history << 1) | train_taken;\n        end else if (predict_valid) begin\n            predict_history <= (predict_history << 1) | predict_taken;\n        end\n    end\n\nendmodule\n"]}
{"task_id": "wire_decl", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    wire and1_output;\n    wire and2_output;\n\n    // First layer of AND gates\n    and and1(and1_output, a, b);\n    and and2(and2_output, c, d);\n\n    // Second layer with OR gate\n    or or1(out, and1_output, and2_output);\n\n    // Inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: AND gates\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n\n    // Second layer: OR gate\n    or or1(out, and1_out, and2_out);\n\n    // Inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    // Intermediate wires\n    wire and1_out;\n    wire and2_out;\n\n    // First layer of logic gates (AND gates)\n    and and_gate1(and1_out, a, b);\n    and and_gate2(and2_out, c, d);\n\n    // Second layer of logic gates (OR gate)\n    or or_gate(out, and1_out, and2_out);\n\n    // NOT gate for the inverted output\n    not not_gate(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    wire and1_out, and2_out;\n\n    // First layer of AND gates\n    and and_gate1(and1_out, a, b);\n    and and_gate2(and2_out, c, d);\n\n    // Second layer OR gate\n    or or_gate(out, and1_out, and2_out);\n\n    // NOT gate to invert 'out'\n    not not_gate(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n );\n\n    wire and1_out;\n    wire and2_out;\n\n    // First layer of AND gates\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n\n    // Second layer OR gate\n    or or1(out, and1_out, and2_out);\n\n    // NOT gate for inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    wire and1_out;\n    wire and2_out;\n\n    // First layer of AND gates\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n\n    // Second layer: OR gate\n    or or1(out, and1_out, and2_out);\n\n    // NOT gate for inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    // Intermediate wires\n    wire and1_output;\n    wire and2_output;\n\n    // First layer: AND gates\n    and and1(and1_output, a, b);\n    and and2(and2_output, c, d);\n\n    // Second layer: OR gate\n    or or1(out, and1_output, and2_output);\n\n    // NOT gate for inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    wire and1_out;\n    wire and2_out;\n\n    // First layer of AND gates\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n\n    // Second layer OR gate\n    or or1(out, and1_out, and2_out);\n\n    // Inverted output\n    not not1(out_n, out);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n// Declare intermediate wires\nwire and1_out, and2_out;\n\n// First layer: AND gates\nand and1(and1_out, a, b);      // Output of AND gate 1 is and1_out, inputs are a and b\nand and2(and2_out, c, d);      // Output of AND gate 2 is and2_out, inputs are c and d\n\n// Second layer: OR gate\nor or1(out, and1_out, and2_out);  // Output of OR gate is directly 'out', inputs are outputs of both AND gates\n\n// NOT gate for inverted output\nnot not1(out_n, out);           // Output of NOT gate is out_n, input is 'out'\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out,\n    output out_n\n);\n\n    // Declare intermediate wires\n    wire and1_out;\n    wire and2_out;\n\n    // First layer: AND gates\n    and and1(and1_out, a, b);\n    and and2(and2_out, c, d);\n\n    // Second layer: OR gate\n    or or1(out, and1_out, and2_out);\n\n    // Invert output 'out' to create 'out_n'\n    not not1(out_n, out);\n\nendmodule\n"]}
{"task_id": "dff", "gptgen_RTL": ["module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\n    always @(posedge clk) begin\n        q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;  // D flip-flop logic; captures input 'd' at the rising edge of 'clk'\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\n// D flip-flop implementation\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    q <= d;\nend\n\nendmodule\n"]}
{"task_id": "thermostat", "gptgen_RTL": ["module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    if (mode == 1) begin // Heating mode\n        if (too_cold == 1) begin\n            heater = 1;\n            fan = 1;\n        end else begin\n            heater = 0;\n            fan = fan_on; // Only turn on fan if explicitly requested\n        end\n        aircon = 0; // Ensure air conditioner is off in heating mode\n    end else begin // Cooling mode\n        if (too_hot == 1) begin\n            aircon = 1;\n            fan = 1;\n        end else begin\n            aircon = 0;\n            fan = fan_on; // Only turn on fan if explicitly requested\n        end\n        heater = 0; // Ensure heater is off in cooling mode\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    // Default values for outputs\n    heater = 0;\n    aircon = 0;\n    fan = 0;\n\n    // Control logic based on mode\n    if (mode == 1) begin // Heating mode\n        if (too_cold) begin\n            heater = 1; // Turn on the heater\n            fan = 1;    // Turn on the fan when heater is on\n        end\n    end else begin // Cooling mode\n        if (too_hot) begin\n            aircon = 1; // Turn on the air conditioner\n            fan = 1;    // Turn on the fan when air conditioner is on\n        end\n    end\n\n    // User can manually turn on the fan\n    if (fan_on) begin\n        fan = 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    assign heater = mode & too_cold;\n    assign aircon = ~mode & too_hot;\n    assign fan = fan_on | heater | aircon;\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    // Initialize outputs\n    heater = 0;\n    aircon = 0;\n    fan = 0;\n\n    // Control logic\n    if (mode == 1) begin\n        // Heating mode\n        if (too_cold) begin\n            heater = 1;\n            fan = 1;\n        end\n    end else begin\n        // Cooling mode\n        if (too_hot) begin\n            aircon = 1;\n            fan = 1;\n        end\n    end\n\n    // Check if the fan needs to be manually turned on\n    if (fan_on) begin\n        fan = 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n\n    // Heater control: On when mode is heating (1) and it's too cold.\n    assign heater = mode & too_cold;\n\n    // Air conditioner control: On when mode is cooling (0) and it's too hot.\n    assign aircon = ~mode & too_hot;\n\n    // Fan control: On when either the heater or air conditioner is on, or when fan_on is explicitly set.\n    assign fan = heater | aircon | fan_on;\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output heater,\n    output aircon,\n    output fan\n);\n    // Heater control logic\n    assign heater = mode & too_cold; // Heater on when mode is heating and it's too cold\n\n    // Air conditioner control logic\n    assign aircon = ~mode & too_hot; // Air conditioner on when mode is cooling and it's too hot\n\n    // Fan control logic\n    assign fan = (heater | aircon | fan_on); // Fan on if heater or aircon is on, or if manually turned on by fan_on signal\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold,\n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    // Initialize outputs to zero\n    heater = 0;\n    aircon = 0;\n    fan = 0;\n\n    // Control heating\n    if (mode == 1 && too_cold == 1) begin\n        heater = 1;\n        fan = 1; // Turn on fan with heater\n    end\n\n    // Control cooling\n    if (mode == 0 && too_hot == 1) begin\n        aircon = 1;\n        fan = 1; // Turn on fan with air conditioner\n    end\n\n    // Manual fan control\n    if (fan_on == 1) begin\n        fan = 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    // Initialize outputs\n    heater = 0;\n    aircon = 0;\n    fan = 0;\n    \n    // Heating mode\n    if (mode == 1) begin\n        if (too_cold) begin\n            heater = 1; // Turn on heater if it's too cold\n            fan = 1;    // Turn on fan when heater is on\n        end\n    end\n    // Cooling mode\n    else begin\n        if (too_hot) begin\n            aircon = 1; // Turn on air conditioner if it's too hot\n            fan = 1;    // Turn on fan when air conditioner is on\n        end\n    end\n    \n    // Check if fan needs to be turned on manually\n    if (fan_on) begin\n        fan = 1; // Turn on fan if user requests it\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\nalways @(*) begin\n    // Initialize outputs\n    heater = 0;\n    aircon = 0;\n    fan = 0;\n\n    // Control logic for heating mode\n    if (mode == 1) begin\n        if (too_cold == 1) begin\n            heater = 1;  // Turn on heater\n            fan = 1;     // Turn on fan to circulate warm air\n        end\n    end\n    // Control logic for cooling mode\n    else begin\n        if (too_hot == 1) begin\n            aircon = 1;  // Turn on air conditioner\n            fan = 1;     // Turn on fan to circulate cool air\n        end\n    end\n\n    // If the user manually requests the fan\n    if (fan_on == 1) begin\n        fan = 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input mode,\n    input too_cold, \n    input too_hot,\n    input fan_on,\n    output reg heater,\n    output reg aircon,\n    output reg fan\n);\n\n    always @(*) begin\n        // Default off states\n        heater = 0;\n        aircon = 0;\n        fan = 0;\n\n        // Control logic for heater and air conditioner\n        if (mode == 1) begin  // Heating mode\n            if (too_cold == 1) begin\n                heater = 1;\n                fan = 1;  // Turn on fan when heater is on\n            end\n        end else begin  // Cooling mode\n            if (too_hot == 1) begin\n                aircon = 1;\n                fan = 1;  // Turn on fan when air conditioner is on\n            end\n        end\n        \n        // Additional control for fan\n        if (fan_on == 1) begin\n            fan = 1;  // User request to turn on the fan\n        end\n    end\n\nendmodule\n"]}
{"task_id": "ece241_2013_q2", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum-of-Products (SOP) form\n    assign out_sop = (~a & ~b & ~c & d) |  // corresponds to 1 (0001)\n                     (~a & b & c & d)   |  // corresponds to 7 (0111)\n                     (a & b & c & d);      // corresponds to 15 (1111)\n\n    // Product-of-Sums (POS) form\n    assign out_pos = (~a | ~b | ~c | d) &  // complements of 0 (0000)\n                     (~a | b | c | d) &   // complements of 2 (0010)\n                     (a | b | c | d);     // complements of 8 (1000), 11 (1011), 12(1100), 14 (1110)\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n// Sum of Products (SOP) form for the given conditions\n// 2 -> 0010, 7 -> 0111, 15 -> 1111\nassign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n// Product of Sums (POS) form for the given conditions\n// Convert the SOP to POS using De Morgan's Theorems:\n// ~(~out_sop) = ~((~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d))\n// Apply De Morgan's Theorem:\n// (~a | ~b | ~c | d) & (~a | b | ~c | ~d) & (a | ~b | ~c | ~d) & (a | b | ~c | d)\nassign out_pos = (~a | ~b | ~c | d) & (~a | b | ~c | ~d) & (a | ~b | ~c | ~d) & (a | b | ~c | d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) form for 2, 7, 15\n    // 2 -> 0010, 7 -> 0111, 15 -> 1111\n    assign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product of Sums (POS) form for 0, 1, 4, 5, 6, 9, 10, 13, 14\n    // 0 -> 0000, 1 -> 0001, 4 -> 0100, 5 -> 0101, 6 -> 0110, 9 -> 1001, 10 -> 1010, 13 -> 1101, 14 -> 1110\n    assign out_pos = (a | b | ~c | d) & (a | ~b | c | d) & (~a | b | c | ~d) & \n                     (~a | ~b | ~c | d) & (~a | ~b | c | ~d) & (a | b | ~c | ~d) & \n                     (~a | b | ~c | d) & (a | ~b | c | ~d) & (a | b | c | d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum-of-Products (SOP) implementation\n    assign out_sop = (~a & ~b & c & ~d) |      // for 2  (0010)\n                     (~a & b & c & d) |        // for 7  (0111)\n                     (a & b & c & d);          // for 15 (1111)\n\n    // Product-of-Sums (POS) implementation\n    assign out_pos = (a | b | ~c | d) &        // for not 0 (0000)\n                     (a | ~b | c | d) &        // for not 1 (0001)\n                     (a | b | c | ~d) &        // for not 4 (0100)\n                     (a | b | ~c | d) &        // for not 5 (0101)\n                     (a | ~b | c | d) &        // for not 6 (0110)\n                     (~a | b | c | d) &        // for not 9 (1001)\n                     (~a | b | ~c | d) &       // for not 10 (1010)\n                     (a | ~b | c | ~d) &       // for not 13 (1101)\n                     (a | b | c | ~d);         // for not 14 (1110)\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) form\n    assign out_sop = (~a & ~b & c & ~d) |  // 2: 0010\n                     (~a & b & c & d)   |  // 7: 0111\n                     (a & b & c & d);      // 15: 1111\n\n    // Product of Sums (POS) form\n    assign out_pos = (~a | ~b | c | ~d) &  \n                     (~a | b | c | d)   &\n                     (a | b | c | d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) form\n    assign out_sop = (~a & ~b & c & ~d) | // 2 in binary: 0010\n                     (~a & b & c & d) |   // 7 in binary: 0111\n                     (a & b & c & d);     // 15 in binary: 1111\n\n    // Product of Sums (POS) form\n    assign out_pos = (~a | b | c | d) & \n                     (a | ~b | c | d) &\n                     (a | b | ~c | d) & \n                     (a | b | c | ~d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) calculation\n    // SOP for outputs 2, 7, 15\n    // Binary representations: 2 -> 0010, 7 -> 0111, 15 -> 1111\n    assign out_sop = (~a & ~b & c & ~d) | (~a & b & c & d) | (a & b & c & d);\n\n    // Product of Sums (POS) calculation\n    // POS for outputs 0, 1, 4, 5, 6, 9, 10, 13, 14\n    // Binary representations: \n    // 0 -> 0000, 1 -> 0001, 4 -> 0100, 5 -> 0101, 6 -> 0110, 9 -> 1001, 10 -> 1010, 13 -> 1101, 14 -> 1110\n    assign out_pos = ~((~a | ~b | ~c | ~d) & (~a | ~b | ~c | d) & (~a | b | ~c | ~d) &\n                       (~a | b | ~c | d) & (~a | b | c | ~d) & (a | ~b | ~c | d) &\n                       (a | ~b | c | ~d) & (a | b | ~c | d) & (a | b | c | ~d));\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) form\n    assign out_sop = (~a & ~b & ~c & d) |       // 1\n                     (~a & b & c & d) |         // 7\n                     (a & b & c & d);           // 15\n\n    // Product of Sums (POS) form\n    assign out_pos = (~a | ~b | ~c | d) &       // 1\n                     (~a | b | c | d) &         // 7\n                     (a | b | c | d);           // 15\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n    // Sum of Products (SOP) for 2, 7, 15\n    // 2: 0010, 7: 0111, 15: 1111\n    assign out_sop = (~a & ~b &  c & ~d) |  // 2\n                     (~a &  b &  c &  d) |  // 7\n                     ( a &  b &  c &  d);   // 15\n\n    // Product of Sums (POS) for the complement of 0, 1, 4, 5, 6, 9, 10, 13, 14\n    // 0: 0000, 1: 0001, 4: 0100, 5: 0101, 6: 0110, 9: 1001, 10: 1010, 13: 1101, 14: 1110\n    assign out_pos = (a | b | c | d) &        // covers 0\n                     (a | b | c | ~d) &       // covers 1\n                     (a | ~b | c | d) &       // covers 4\n                     (a | ~b | c | ~d) &      // covers 5\n                     (a | ~b | ~c | d) &      // covers 6\n                     (~a | b | c | ~d) &      // covers 9\n                     (~a | b | ~c | d) &      // covers 10\n                     (~a | ~b | c | ~d) &     // covers 13\n                     (~a | ~b | ~c | d);      // covers 14\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out_sop,\n    output out_pos\n);\n\n// Sum of Products (SOP) implementation\nassign out_sop = (~a & ~b & c & ~d) |  // for input 2: 0010\n                 (~a & b & c & d)  |    // for input 7: 0111\n                 (a & b & c & d);       // for input 15: 1111\n\n// Product of Sums (POS) implementation\nassign out_pos = (~a | ~b | c | ~d) &\n                 (~a | b | c | d) &\n                 (a | b | c | d);\n\nendmodule\n"]}
{"task_id": "circuit3", "gptgen_RTL": ["module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a & b) | (a & c) | (a & d) | (b & c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (c & d) | (a & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (a & c & d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output q\n);\n\n    assign q = (b & d) | (a & d) | (a & c);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & (c ^ d)) | (a & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & c) | (a & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (a & d) | (a & c);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (a && d) || (b && c) || (b && d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (a & c) | (a & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    input c, \n    input d,\n    output q\n);\n\n    assign q = (b & d) | (c & d) | (a & d);\n\nendmodule\n"]}
{"task_id": "7420", "gptgen_RTL": ["module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n// Implementing the first 4-input NAND gate\nassign p1y = ~(p1a & p1b & p1c & p1d);\n\n// Implementing the second 4-input NAND gate\nassign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n    // NAND gate for the first set of inputs\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // NAND gate for the second set of inputs\n    assign p2y = ~(p2a & p2b & p2c & p2d);\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the NAND gates\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d, \n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\n    // Implementing the first 4-input NAND gate\n    assign p1y = ~(p1a & p1b & p1c & p1d);\n\n    // Implementing the second 4-input NAND gate\n    assign p2y = ~(p2a & p2b & p2c & p2d);\n\nendmodule\n"]}
{"task_id": "popcount255", "gptgen_RTL": ["module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 8'b0; // Initialize output to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Increment output for each '1' in input\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 0;  // Initialize output\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];  // Sum up all the '1's in the input vector\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    out = 0;\n    for (i = 0; i < 255; i = i + 1) begin\n        out = out + in[i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @ (in) begin\n        out = 0; // Initialize output\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Count the number of 1's\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n    \n    always @(*) begin\n        out = 0;\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [254:0] in,\n    output reg [7:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        out = 8'b0; // Initialize the output to 0\n        for (i = 0; i < 255; i = i + 1) begin\n            out = out + in[i]; // Increment out for each '1' found in input vector\n        end\n    end\n\nendmodule\n"]}
{"task_id": "gatesv", "gptgen_RTL": ["module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Calculate out_both\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // Calculate out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Calculate out_different\n    assign out_different[3] = in[3] ^ in[0];  // Wrap around case\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Output out_both\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // Output out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Output out_different\n    assign out_different[3] = in[3] ^ in[0]; // Wraps around\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Calculate out_both\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Calculate out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // Calculate out_different\n    assign out_different[3] = in[3] ^ in[0]; // Wrap around as in[3]'s left neighbor is in[0]\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Output: out_both\n    // Each bit should indicate whether both the corresponding input bit and its neighbour to the left are '1'.\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Output: out_any\n    // Each bit should indicate whether any of the corresponding input bit and its neighbour to the right are '1'.\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Output: out_different\n    // Each bit should indicate whether the corresponding input bit is different from its neighbour to the left.\n    // Treating the vector as wrapping around, so in[3]'s neighbour to the left is in[0].\n    assign out_different[3] = in[3] ^ in[0];\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // (1) out_both logic.\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // (2) out_any logic.\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // (3) out_different logic.\n    assign out_different[3] = in[3] ^ in[0]; // wrap-around\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Output for out_both - checks if both current and left neighbour bits are 1\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // Output for out_any - checks if any of current or right neighbour bits are 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Output for out_different - checks if current and left neighbour bits are different\n    assign out_different[3] = in[3] ^ in[0]; // Wraps around, comparing in[3] with in[0]\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // out_both calculation: Check if both neighboring bits are 1\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // out_any calculation: Check if any of the neighboring bits is 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // out_different calculation: Check if neighboring bits are different\n    assign out_different[3] = in[3] ^ in[0];  // Wrap around case\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n\n    // Compute out_both - each bit indicates if the corresponding bit and its left neighbor are both 1\n    assign out_both[2] = in[2] & in[3];\n    assign out_both[1] = in[1] & in[2];\n    assign out_both[0] = in[0] & in[1];\n\n    // Compute out_any - each bit indicates if any (one or both) of the corresponding bit or its right neighbor is 1\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Compute out_different - each bit indicates if the corresponding bit is different from its left neighbor\n    assign out_different[3] = in[3] ^ in[0]; // Wrap around for in[3]\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Output out_both\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // Output out_any\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n\n    // Output out_different\n    assign out_different[3] = in[3] ^ in[0];  // Wrapping around\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output [2:0] out_both,\n    output [3:1] out_any,\n    output [3:0] out_different\n);\n    // Output 'out_both' (i.e., in[i] and in[i+1] are both 1)\n    assign out_both[2] = in[3] & in[2];\n    assign out_both[1] = in[2] & in[1];\n    assign out_both[0] = in[1] & in[0];\n\n    // Output 'out_any' (i.e., in[i] or in[i-1] are 1)\n    assign out_any[3] = in[3] | in[2];\n    assign out_any[2] = in[2] | in[1];\n    assign out_any[1] = in[1] | in[0];\n    \n    // Output 'out_different' (i.e., in[i] is different from in[i+1])\n    assign out_different[3] = in[3] ^ in[0]; // Wrap around to in[0]\n    assign out_different[2] = in[2] ^ in[3];\n    assign out_different[1] = in[1] ^ in[2];\n    assign out_different[0] = in[0] ^ in[1];\nendmodule\n"]}
{"task_id": "circuit6", "gptgen_RTL": ["module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'b000: q = 16'h1232;\n        3'b001: q = 16'haee0;\n        3'b010: q = 16'h27d4;\n        3'b011: q = 16'h5a0e;\n        3'b100: q = 16'h2066;\n        3'b101: q = 16'h64ce;\n        3'b110: q = 16'hc526;\n        3'b111: q = 16'h2f19;\n        default: q = 16'hxxxx;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\nalways @(*) begin\n    case (a)\n        3'd0: q = 16'h1232;\n        3'd1: q = 16'haee0;\n        3'd2: q = 16'h27d4;\n        3'd3: q = 16'h5a0e;\n        3'd4: q = 16'h2066;\n        3'd5: q = 16'h64ce;\n        3'd6: q = 16'hc526;\n        3'd7: q = 16'h2f19;\n        default: q = 16'h0000; // Default case to handle undefined inputs\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'hxxxx;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'd0: q = 16'h1232;\n            3'd1: q = 16'haee0;\n            3'd2: q = 16'h27d4;\n            3'd3: q = 16'h5a0e;\n            3'd4: q = 16'h2066;\n            3'd5: q = 16'h64ce;\n            3'd6: q = 16'hc526;\n            3'd7: q = 16'h2f19;\n            default: q = 16'hxxxx; // Undefined behavior\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'hxxxx;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @* begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000; // Default case to handle undefined inputs\n        endcase\n    end\n    \nendmodule\n", "module top_module (\n    input [2:0] a,\n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'h0000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'hx;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'hxxxx; // for undefined inputs\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] a, \n    output reg [15:0] q\n);\n\n    always @(*) begin\n        case (a)\n            3'b000: q = 16'h1232;\n            3'b001: q = 16'haee0;\n            3'b010: q = 16'h27d4;\n            3'b011: q = 16'h5a0e;\n            3'b100: q = 16'h2066;\n            3'b101: q = 16'h64ce;\n            3'b110: q = 16'hc526;\n            3'b111: q = 16'h2f19;\n            default: q = 16'hxxxx;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "countslow", "gptgen_RTL": ["module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000; // Reset the counter to 0\n        end\n        else if (slowena) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000; // Reset to 0 after reaching 9\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd0; // Reset the counter to 0 when reset is high\n    end\n    else if (slowena) begin\n        if (q == 4'd9) begin\n            q <= 4'd0; // Reset the counter to 0 after reaching 9\n        end else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n// Decade counter logic\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000; // Reset the counter to 0\n    end\n    else if (slowena) begin\n        if (q == 4'b1001) begin\n            q <= 4'b0000; // Reset to 0 after reaching 9\n        end\n        else begin\n            q <= q + 1; // Increment the counter\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;  // Reset counter to 0\n    else if (slowena) begin\n        if (q == 4'b1001)  // If counter is at 9\n            q <= 4'b0000;  // Reset to 0\n        else\n            q <= q + 1;  // Increment counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'b0000;  // Reset the counter to 0\n        end\n        else if (slowena) begin\n            if (q == 4'b1001) begin\n                q <= 4'b0000;  // Reset the counter when it reaches 9\n            end else begin\n                q <= q + 1;  // Increment the counter\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    // Counter behavior implementation\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Reset the counter to 0 when reset is high\n        end\n        else if (slowena) begin\n            if (q == 4'd9)\n                q <= 4'd0; // Reset to 0 when the count reaches 9\n            else\n                q <= q + 4'd1; // Increment counter by 1\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000; // Reset the counter to 0\n    else if (slowena) begin\n        if (q == 4'b1001)\n            q <= 4'b0000; // Reset to 0 when the counter reaches 9\n        else\n            q <= q + 1; // Increment the counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n// Counter logic\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd0;\n    end\n    else if (slowena) begin\n        if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\n    // Implementing the decade counter\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 4'd0; // Reset the counter to 0\n        end\n        else if (slowena) begin\n            if (q == 4'd9) begin\n                q <= 4'd0; // Reset to 0 after reaching 9\n            end else begin\n                q <= q + 1; // Increment the counter\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input slowena,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000; // Reset the counter to 0\n    else if (slowena) begin\n        if (q == 4'b1001)\n            q <= 4'b0000; // Reset to 0 after reaching 9\n        else\n            q <= q + 1; // Increment the counter\n    end\nend\n\nendmodule\n"]}
{"task_id": "m2014_q4f", "gptgen_RTL": ["module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Implementing the AND gate with in2 bubbled (inverted before ANDing)\n    assign out = in1 & ~in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Logic for AND gate with a bubbled second input\n    assign out = in1 & ~in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Inverting in2 to simulate the bubble before the AND gate\n    wire not_in2;\n    assign not_in2 = ~in2;\n\n    // AND gate with bubbled input in2\n    assign out = in1 & not_in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Applying a bubble to in2 implies inverting in2 before the AND gate\n    wire not_in2;\n    assign not_in2 = ~in2;\n\n    // AND gate with in1 and inverted in2\n    assign out = in1 & not_in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Inverting in2, as it has a bubble (inverted input)\n    wire not_in2;\n    assign not_in2 = ~in2;\n\n    // AND gate with in1 and inverted in2\n    assign out = in1 & not_in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Negate in2 before feeding it to the AND gate\n    wire not_in2;\n    assign not_in2 = ~in2;\n\n    // AND gate with in1 and the negated in2\n    assign out = in1 & not_in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = in1 & ~in2;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Using an inverted signal for in2 with a bubble\n    wire in2_bubbled;\n    assign in2_bubbled = ~in2;\n\n    // AND gate with in1 and the inverted in2\n    assign out = in1 & in2_bubbled;\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    // Implementing the NOT gate to create a bubble on in2\n    wire in2_negated;\n    assign in2_negated = ~in2;\n\n    // AND gate with one input negated\n    assign out = in1 & in2_negated;\n\nendmodule\n"]}
{"task_id": "fsm1", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;  // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B;  // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n            default: out = 1'b1;  // Safe default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State declaration\n    typedef enum {STATE_A, STATE_B} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= STATE_B; // Asynchronously reset to state B\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = in ? STATE_A : STATE_B;\n            STATE_B: next_state = in ? STATE_B : STATE_A;\n            default: next_state = STATE_B; // Default case for safety\n        endcase\n    end\n\n    // Output logic based on the state\n    always @(*) begin\n        case (current_state)\n            STATE_A: out = 0;\n            STATE_B: out = 1;\n            default: out = 1; // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // State Register\n    reg state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= B;       // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;  // If in state A, stay in A if in==1, else go to B\n            B: next_state = in ? B : A;  // If in state B, stay in B if in==1, else go to A\n            default: next_state = B;     // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;  // Output 0 when in state A\n            B: out = 1'b1;  // Output 1 when in state B\n            default: out = 1'b1; // Safe default output\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // State variables\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= B; // Asynchronous reset to state B\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B; // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n            default: out = 1'b1; // Default in case of unexpected state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // Define state encoding\n    parameter A = 1'b0, B = 1'b1;\n\n    // Register to hold current state\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) \n            state <= B; // Asynchronously reset to state B\n        else \n            state <= next_state; // Move to next state on clock edge\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B; // State A transitions\n            B: next_state = in ? B : A; // State B transitions\n            default: next_state = B; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B; // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B; // Default to B in case of any spurious states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    parameter A = 1'b0, B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B; // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B; // default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n            default: out = 1'b1; // default case for safety\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    localparam A = 1'b0;\n    localparam B = 1'b1;\n\n    // Current state variable\n    reg state;\n    reg next_state;\n\n    // Asynchronous reset and state transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;  // Reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = (in == 1'b0) ? B : A;  // A transitions\n            B: next_state = (in == 1'b0) ? A : B;  // B transitions\n            default: next_state = B;  // Default case safety\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n            default: out = 1'b1;  // Safe default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State Encoding\n    localparam [1:0] A = 2'b00,\n                     B = 2'b01;\n\n    // State Register\n    reg [1:0] state, next_state;\n\n    // State Transition Logic\n    always @ (posedge clk or posedge areset) begin\n        if (areset)\n            state <= B;  // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @ (*) begin\n        case (state)\n            A: next_state = in ? A : B;\n            B: next_state = in ? B : A;\n            default: next_state = B; // Default to B\n        endcase\n    end\n\n    // Output Logic\n    always @ (*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    parameter A = 1'b0, B = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= B; // Asynchronously reset to state B\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = (in == 1'b1) ? A : B;\n            B: next_state = (in == 1'b1) ? B : A;\n            default: next_state = B;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            A: out = 1'b0;\n            B: out = 1'b1;\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "dualedge", "gptgen_RTL": ["module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if(clk != last_clk) begin\n        q <= d;\n    end\n    last_clk <= clk;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if (clk != last_clk) begin // Detect a change in the clock\n        q <= d;\n    end\n    last_clk <= clk; // Update last clock value\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if (clk != last_clk) begin\n        q <= d;\n    end\n    last_clk <= clk;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg q_next;\n\nalways @(posedge clk) begin\n    q_next <= d;\nend\n\nalways @(negedge clk) begin\n    q <= q_next;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if (clk != last_clk) begin\n        q <= d;\n    end\n    last_clk <= clk;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg q_next;\n\n// Detect edge by XORing delayed clock with current clock (captures both edges: rising and falling)\nalways @(clk) begin\n    q_next <= d;\nend\n\n// Update the output flip-flop on both edges of the clock\nalways @(clk) begin\n    q <= q_next;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg toggle;\n\nalways @(posedge clk or negedge clk) begin\n    toggle <= ~toggle;\nend\n\nalways @(posedge toggle) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg toggle;\n\nalways @(posedge clk or negedge clk) begin\n    toggle <= ~toggle;\nend\n\nalways @(posedge toggle) begin\n    q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if (clk != last_clk) begin\n        q <= d;\n        last_clk <= clk;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input d,\n    output reg q\n);\n\nreg last_clk;\n\nalways @(posedge clk or negedge clk) begin\n    if (clk != last_clk) begin\n        q <= d;\n        last_clk <= clk;\n    end\nend\n\nendmodule\n"]}
{"task_id": "xnorgate", "gptgen_RTL": ["module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b); // XNOR operation\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a,\n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    output out\n);\n\nassign out = ~(a ^ b);\n\nendmodule\n"]}
{"task_id": "mt2015_q4", "gptgen_RTL": ["module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Instantiating submodules for Module A and Module B\nwire a1_out, a2_out, b1_out, b2_out;\n\n// Module A implements the boolean function z = (x^y) & x\nmodule_a a1(.x(x), .y(y), .z(a1_out));\nmodule_a a2(.x(x), .y(y), .z(a2_out));\n\n// Module B implements the function derived from the waveform\nmodule_b b1(.x(x), .y(y), .z(b1_out));\nmodule_b b2(.x(x), .y(y), .z(b2_out));\n\n// Logic for combining outputs of A and B submodules\nwire or_output, and_output;\n\n// OR gate combining the output of the first A and B submodules\nor or_gate(or_output, a1_out, b1_out);\n\n// AND gate combining the output of the second A and B submodules\nand and_gate(and_output, a2_out, b2_out);\n\n// XOR gate for the top module output\nxor xor_gate(z, or_output, and_output);\n\nendmodule\n\n// Definition of module A\nmodule module_a(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of module B based on the described waveform analysis\nmodule module_b(\n    input x,\n    input y,\n    output z\n);\n    assign z = (y & ~x) | (~x & ~y) | (x & y);\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Declaration of wires for intermediate connections\nwire z_a1, z_b1, z_a2, z_b2;\nwire or_output, and_output;\n\n// Instantiation of Module A for the first pair\nA a1(\n    .x(x),\n    .y(y),\n    .z(z_a1)\n);\n\n// Instantiation of Module B for the first pair\nB b1(\n    .x(x),\n    .y(y),\n    .z(z_b1)\n);\n\n// Instantiation of Module A for the second pair\nA a2(\n    .x(x),\n    .y(y),\n    .z(z_a2)\n);\n\n// Instantiation of Module B for the second pair\nB b2(\n    .x(x),\n    .y(y),\n    .z(z_b2)\n);\n\n// OR gate for the first pair outputs\nor or_gate(\n    or_output,\n    z_a1,\n    z_b1\n);\n\n// AND gate for the second pair outputs\nand and_gate(\n    and_output,\n    z_a2,\n    z_b2\n);\n\n// XOR gate for final output\nxor xor_gate(\n    z,\n    or_output,\n    and_output\n);\n\n// Module A definition\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B definition\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & ~y) | (~x & y) | (x & y); // Implementation according to given truth table\nendmodule\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_output, and_output;\n\n    // Instance of submodule A\n    A submodule_A1(.x(x), .y(y), .z(z_a1));\n    A submodule_A2(.x(x), .y(y), .z(z_a2));\n\n    // Instance of submodule B\n    B submodule_B1(.x(x), .y(y), .z(z_b1));\n    B submodule_B2(.x(x), .y(y), .z(z_b2));\n\n    // OR gate for the first pair (A1, B1)\n    or or_gate(or_output, z_a1, z_b1);\n\n    // AND gate for the second pair (A2, B2)\n    and and_gate(and_output, z_a2, z_b2);\n\n    // XOR gate for final output\n    xor xor_gate(z, or_output, and_output);\n\nendmodule\n\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    // Implementing the behavior observed in the simulation waveform\n    assign z = (x & y) | (!x & !y);\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\nwire z_A1, z_A2, z_B1, z_B2;\nwire or_output, and_output;\n\n// Instantiating the first submodule A\nA submodule_A1(\n    .x(x),\n    .y(y),\n    .z(z_A1)\n);\n\n// Instantiating the second submodule A\nA submodule_A2(\n    .x(x),\n    .y(y),\n    .z(z_A2)\n);\n\n// Instantiating the first submodule B\nB submodule_B1(\n    .x(x),\n    .y(y),\n    .z(z_B1)\n);\n\n// Instantiating the second submodule B\nB submodule_B2(\n    .x(x),\n    .y(y),\n    .z(z_B2)\n);\n\n// OR gate\nor or_gate(or_output, z_A1, z_B1);\n\n// AND gate\nand and_gate(and_output, z_A2, z_B2);\n\n// XOR gate\nxor xor_gate(z, or_output, and_output);\n\nendmodule\n\n// Definition of submodule A\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of submodule B\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = ~(x ^ y);\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Instantiating submodules\nwire z_a1, z_a2, z_b1, z_b2;\n\n// Module A definition\nmodule_a a1 (.x(x), .y(y), .z(z_a1));\nmodule_a a2 (.x(x), .y(y), .z(z_a2));\n\n// Module B definition based on given waveform\nmodule_b b1 (.x(x), .y(y), .z(z_b1));\nmodule_b b2 (.x(x), .y(y), .z(z_b2));\n\n// Intermediate wires for OR and AND outputs\nwire or_output, and_output;\n\n// OR and AND gates\nassign or_output = z_a1 | z_b1;\nassign and_output = z_a2 & z_b2;\n\n// XOR gate for final output\nassign z = or_output ^ and_output;\n\n// Module A implementation\nmodule module_a(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B implementation based on the waveform analysis\nmodule module_b(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x & ~y) | (~x & y) | (x & y);\nendmodule\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n    wire z_a1, z_b1, z_a2, z_b2;\n    wire or_out, and_out;\n\n    // Instantiation of first A submodule\n    A a1 (\n        .x(x),\n        .y(y),\n        .z(z_a1)\n    );\n\n    // Instantiation of first B submodule\n    B b1 (\n        .x(x),\n        .y(y),\n        .z(z_b1)\n    );\n\n    // Instantiation of second A submodule\n    A a2 (\n        .x(x),\n        .y(y),\n        .z(z_a2)\n    );\n\n    // Instantiation of second B submodule\n    B b2 (\n        .x(x),\n        .y(y),\n        .z(z_b2)\n    );\n\n    // OR gate\n    or or_gate(\n        or_out,\n        z_a1,\n        z_b1\n    );\n\n    // AND gate\n    and and_gate(\n        and_out,\n        z_a2,\n        z_b2\n    );\n\n    // XOR gate\n    xor xor_gate(\n        z,\n        or_out,\n        and_out\n    );\n\nendmodule\n\n// Definition of submodule A\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of submodule B\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    // Implementing the behavior observed in the waveform\n    assign z = (x & ~y) | (~x & y) | (x & y);\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Instantiate the submodules of A\nwire z_A1, z_A2;\nmodule_A submod_A1 (.x(x), .y(y), .z(z_A1));\nmodule_A submod_A2 (.x(x), .y(y), .z(z_A2));\n\n// Instantiate the submodules of B\nwire z_B1, z_B2;\nmodule_B submod_B1 (.x(x), .y(y), .z(z_B1));\nmodule_B submod_B2 (.x(x), .y(y), .z(z_B2));\n\n// Logic for the OR and AND gates\nwire or_output, and_output;\nor  or_gate(or_output, z_A1, z_B1);\nand and_gate(and_output, z_A2, z_B2);\n\n// Final XOR gate to produce output z\nxor xor_gate(z, or_output, and_output);\n\nendmodule\n\n// Definition of module A\nmodule module_A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of module B based on the given waveform\nmodule module_B(\n    input x,\n    input y,\n    output reg z\n);\n    always @(*) begin\n        if (x == 0 && y == 0) z = 1;\n        else if (x == 1 && y == 0) z = 0;\n        else if (x == 0 && y == 1) z = 0;\n        else if (x == 1 && y == 1) z = 1;\n    end\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n    // Signals for submodule outputs\n    wire z_A1, z_B1, z_A2, z_B2;\n    wire or_output, and_output;\n\n    // Instantiate the first A submodule\n    A A1 (\n        .x(x),\n        .y(y),\n        .z(z_A1)\n    );\n\n    // Instantiate the first B submodule\n    B B1 (\n        .x(x),\n        .y(y),\n        .z(z_B1)\n    );\n\n    // Instantiate the second A submodule\n    A A2 (\n        .x(x),\n        .y(y),\n        .z(z_A2)\n    );\n\n    // Instantiate the second B submodule\n    B B2 (\n        .x(x),\n        .y(y),\n        .z(z_B2)\n    );\n\n    // OR gate combining outputs of the first A and B submodule\n    or or1(or_output, z_A1, z_B1);\n\n    // AND gate combining outputs of the second A and B submodule\n    and and1(and_output, z_A2, z_B2);\n\n    // XOR gate for final output z\n    xor xor1(z, or_output, and_output);\n\nendmodule\n\n// Definition of module A\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Definition of module B\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    // Implementing the function based on the waveform truth table\n    assign z = (x & y) | (~x & ~y);\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n\n// Instantiation of A modules\nwire z_a1, z_a2;\nA a1 (.x(x), .y(y), .z(z_a1));\nA a2 (.x(x), .y(y), .z(z_a2));\n\n// Instantiation of B modules\nwire z_b1, z_b2;\nB b1 (.x(x), .y(y), .z(z_b1));\nB b2 (.x(x), .y(y), .z(z_b2));\n\n// Intermediate wires for OR and AND gates\nwire or_output, and_output;\n\n// OR and AND gates logic\nassign or_output = z_a1 | z_b1;\nassign and_output = z_a2 & z_b2;\n\n// XOR gate to produce final output\nassign z = or_output ^ and_output;\n\n// Module A Definition\nmodule A(\n    input x,\n    input y,\n    output z\n);\nassign z = (x ^ y) & x;\nendmodule\n\n// Module B Definition\nmodule B(\n    input x,\n    input y,\n    output z\n);\n// Implementing function based on the described waveform\nassign z = (~x & ~y) | (x & y);\nendmodule\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output z\n);\n    wire z_A1, z_B1, z_A2, z_B2;\n    wire or_out, and_out;\n\n    // Instantiating first A submodule\n    A A1 (\n        .x(x),\n        .y(y),\n        .z(z_A1)\n    );\n\n    // Instantiating first B submodule\n    B B1 (\n        .x(x),\n        .y(y),\n        .z(z_B1)\n    );\n\n    // Instantiating second A submodule\n    A A2 (\n        .x(x),\n        .y(y),\n        .z(z_A2)\n    );\n\n    // Instantiating second B submodule\n    B B2 (\n        .x(x),\n        .y(y),\n        .z(z_B2)\n    );\n\n    // OR gate for the outputs of the first A and B submodules\n    or or_gate(or_out, z_A1, z_B1);\n\n    // AND gate for the outputs of the second A and B submodules\n    and and_gate(and_out, z_A2, z_B2);\n\n    // XOR gate for the outputs of the OR and AND gates\n    xor xor_gate(z, or_out, and_out);\n\nendmodule\n\n// Module A implements the boolean function z = (x^y) & x\nmodule A(\n    input x,\n    input y,\n    output z\n);\n    assign z = (x ^ y) & x;\nendmodule\n\n// Module B implements the boolean function according to the given waveform\nmodule B(\n    input x,\n    input y,\n    output z\n);\n    assign z = ~(x ^ y);\nendmodule\n"]}
{"task_id": "rotate100", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into q when load signal is active\n        q <= data;\n    end\n    else begin\n        case (ena)\n            2'b01: // Rotate right\n                q <= {q[0], q[99:1]};\n            2'b10: // Rotate left\n                q <= {q[98:0], q[99]};\n            default: // 2'b00 and 2'b11 - Do not rotate\n                q <= q;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load data into q when load signal is active high\n        q <= data;\n    end\n    else begin\n        case (ena)\n            2'b01: begin\n                // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin\n                // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            default: begin\n                // No rotation\n                q <= q;\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load data into q\n            q <= data;\n        end\n        else begin\n            case (ena)\n                2'b01: begin\n                    // Rotate right\n                    q <= {q[0], q[99:1]};\n                end\n                2'b10: begin\n                    // Rotate left\n                    q <= {q[98:0], q[99]};\n                end\n                default: begin\n                    // No rotation\n                    q <= q;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load the data into the register\n        end\n        else begin\n            case (ena)\n                2'b01: q <= {q[0], q[99:1]};  // Rotate right\n                2'b10: q <= {q[98:0], q[99]}; // Rotate left\n                default: q <= q;              // Hold the value when ena is 2'b00 or 2'b11\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into the register\n            q <= data;\n        end\n        else begin\n            case (ena)\n                2'b01: // Rotate right\n                    q <= {q[0], q[99:1]};\n                2'b10: // Rotate left\n                    q <= {q[98:0], q[99]};\n                default: // No rotation\n                    q <= q;\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load data into q when load signal is high\n        q <= data;\n    end\n    else begin\n        case (ena)\n            2'b01: begin // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            default: begin // No rotation\n                q <= q;\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Synchronously load data into the shift register\n        q <= data;\n    end else begin\n        case(ena)\n            2'b01: // Rotate right\n                q <= {q[0], q[99:1]};\n            2'b10: // Rotate left\n                q <= {q[98:0], q[99]};\n            default: // No rotation\n                q <= q;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into q when load signal is asserted\n        q <= data;\n    end else begin\n        case (ena)\n            2'b01: begin\n                // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin\n                // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            default: begin\n                // Do not rotate\n                q <= q;\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into the register q when load signal is asserted\n        q <= data;\n    end\n    else begin\n        case (ena)\n            2'b01: begin\n                // Rotate right\n                q <= {q[0], q[99:1]};\n            end\n            2'b10: begin\n                // Rotate left\n                q <= {q[98:0], q[99]};\n            end\n            default: begin\n                // Retain the current state (do not rotate)\n                q <= q;\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [1:0] ena,\n    input [99:0] data,\n    output reg [99:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into q when load signal is high\n        q <= data;\n    end else if (ena == 2'b01) begin\n        // Rotate right by one bit\n        q <= {q[0], q[99:1]};\n    end else if (ena == 2'b10) begin\n        // Rotate left by one bit\n        q <= {q[98:0], q[99]};\n    end\n    // When ena is 2'b00 or 2'b11, do nothing (no rotation)\nend\n\nendmodule\n"]}
{"task_id": "review2015_count1k", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 0; // Reset the counter to 0 when reset is high\n    else if (q == 999)\n        q <= 0; // Reset the counter when it reaches 999\n    else\n        q <= q + 1; // Increment the counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0; // Synchronous reset to 0\n        else if (q == 10'd999)\n            q <= 10'd0; // Wrap around after reaching 999\n        else\n            q <= q + 10'd1; // Increment counter\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\n    // Counter logic\n    always @(posedge clk) begin\n        if (reset)\n            q <= 10'd0; // Reset the counter to 0, synchronous to the clock\n        else if (q == 10'd999)\n            q <= 10'd0; // Reset the counter after reaching 999\n        else\n            q <= q + 10'd1; // Increment the counter\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 0;\n        else if (q == 999)\n            q <= 0;\n        else\n            q <= q + 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 0;  // Reset the counter to 0 when reset is active high\n    else if (q == 999)\n        q <= 0;  // Reset the counter to 0 when it reaches 999\n    else\n        q <= q + 1;  // Increment the counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 0;\n        else if (q == 999)\n            q <= 0;\n        else\n            q <= q + 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 0;\n    else if (q == 999)\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n    // Counter that counts from 0 to 999\n    always @(posedge clk) begin\n        if (reset)\n            q <= 0; // Synchronous reset to 0\n        else if (q == 999)\n            q <= 0; // Reset counter when it reaches 999\n        else\n            q <= q + 1; // Increment counter\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 10'd0;\n    else if (q == 10'd999)\n        q <= 10'd0;\n    else\n        q <= q + 10'd1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [9:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 0;\n    else if (q == 999)\n        q <= 0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n"]}
{"task_id": "fsm_onehot", "gptgen_RTL": ["module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2\n);\n\n    always @(*) begin\n        // Default outputs\n        out1 = 0;\n        out2 = 0;\n        \n        // Default next_state\n        next_state = 10'b0;\n        \n        // State transition logic\n        case (1'b1) // Using priority case structure\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001;\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001;\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001;\n            state[4]: next_state = in ? 10'b0000100000 : 10'b0000000001;\n            state[5]: next_state = in ? 10'b0001000000 : 10'b1000000000;\n            state[6]: next_state = in ? 10'b0010000000 : 10'b0100000000;\n            state[7]: next_state = in ? 10'b0010000000 : 10'b0000000001;\n            state[8]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n            state[9]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n        endcase\n\n        // Output logic based on state\n        case (1'b1)\n            state[7]: begin\n                out1 = 0;\n                out2 = 1;\n            end\n            state[8]: begin\n                out1 = 1;\n                out2 = 0;\n            end\n            state[9]: begin\n                out1 = 1;\n                out2 = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // Define next_state logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | \n                           (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) |\n                           (state[8] & ~in) | (state[9] & ~in);\n\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n\n    assign next_state[2] = (state[1] & in);\n\n    assign next_state[3] = (state[2] & in);\n\n    assign next_state[4] = (state[3] & in);\n\n    assign next_state[5] = (state[4] & in);\n\n    assign next_state[6] = (state[5] & in);\n\n    assign next_state[7] = (state[6] & in) | (state[7] & in);\n\n    assign next_state[8] = (state[5] & ~in);\n\n    assign next_state[9] = (state[6] & ~in);\n\n    // Define output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[9];\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2);\n\n    // Decode next state logic based on current state and input\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in) | (state[7] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Decode outputs based on current state\n    assign out1 = (state[8] | state[9]);\n    assign out2 = state[9];\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // Next state logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) |\n                           (state[4] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in) | (state[8] & in) | (state[9] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in) | (state[7] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Output logic\n    assign out1 = (state[8] | state[9]);\n    assign out2 = (state[7] | state[9]);\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // Next state logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) | (state[4] & ~in) | \n                           (state[5] & ~in) | (state[7] & ~in) | (state[8] & ~in) | (state[9] & ~in);\n    assign next_state[1] = (state[0] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2\n);\n\n    always @(*) begin\n        // Default outputs\n        out1 = 0;\n        out2 = 0;\n        \n        // Default next state\n        next_state = 10'b0000000000;\n        \n        // State transition logic\n        case (1'b1) // Synthesize as priority encoder\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001;\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001;\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001;\n            state[4]: next_state = in ? 10'b0010000000 : 10'b0000000001;\n            state[5]: next_state = in ? 10'b0100000000 : 10'b0001000000;\n            state[6]: next_state = in ? 10'b1000000000 : 10'b0000100000;\n            state[7]: next_state = in ? 10'b1000000000 : 10'b0000000001;\n            state[8]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n            state[9]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n        endcase\n\n        // Output logic based on current state\n        if (state[7]) begin\n            out2 = 1;\n        end else if (state[8]) begin\n            out1 = 1;\n        end else if (state[9]) begin\n            out1 = 1;\n            out2 = 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // Define next state logic\n    assign next_state[0] = (state[0] & ~in) |\n                           (state[1] & ~in) |\n                           (state[2] & ~in) |\n                           (state[3] & ~in) |\n                           (state[4] & ~in) |\n                           (state[5] & ~in) |\n                           (state[6] & ~in) |\n                           (state[7] & ~in) |\n                           (state[8] & ~in) |\n                           (state[9] & ~in);\n\n    assign next_state[1] = (state[0] & in) |\n                           (state[8] & in) |\n                           (state[9] & in);\n\n    assign next_state[2] = (state[1] & in);\n\n    assign next_state[3] = (state[2] & in);\n\n    assign next_state[4] = (state[3] & in);\n\n    assign next_state[5] = (state[4] & in);\n\n    assign next_state[6] = (state[5] & in);\n\n    assign next_state[7] = (state[6] & in) |\n                           (state[7] & in);\n\n    assign next_state[8] = (state[5] & ~in);\n\n    assign next_state[9] = (state[6] & ~in);\n    \n    // Define output logic\n    assign out1 = state[8] | state[9];\n    assign out2 = state[7] | state[9];\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n\n    // Define the next state logic\n    assign next_state[0] = (state[0] & ~in) | (state[1] & ~in) | (state[2] & ~in) | (state[3] & ~in) |\n                           (state[4] & ~in) | (state[5] & ~in) | (state[7] & ~in) | (state[8] & ~in) |\n                           (state[9] & ~in);\n    assign next_state[1] = (state[0] & in);\n    assign next_state[2] = (state[1] & in);\n    assign next_state[3] = (state[2] & in);\n    assign next_state[4] = (state[3] & in);\n    assign next_state[5] = (state[4] & in);\n    assign next_state[6] = (state[5] & in);\n    assign next_state[7] = (state[6] & in);\n    assign next_state[8] = (state[5] & ~in);\n    assign next_state[9] = (state[6] & ~in);\n\n    // Define the output logic\n    assign out1 = (state[8] | state[9]);\n    assign out2 = (state[7] | state[9]);\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output [9:0] next_state,\n    output out1,\n    output out2\n);\n    // Define next state logic\n    assign next_state[0] = (!in & (state[0] | state[1] | state[2] | state[3] | state[4] | state[5] | state[6] | state[7] | state[8] | state[9])) |\n                           (in & (state[8] | state[9]));\n    assign next_state[1] = (in & state[0]) | (in & state[8]);\n    assign next_state[2] = (in & state[1]);\n    assign next_state[3] = (in & state[2]);\n    assign next_state[4] = (in & state[3]);\n    assign next_state[5] = (in & state[4]);\n    assign next_state[6] = (in & state[5]);\n    assign next_state[7] = (!in & state[6]) | (in & state[6]);\n    assign next_state[8] = (!in & state[5]);\n    assign next_state[9] = (!in & state[6]) | (in & state[6]);\n\n    // Define output logic\n    assign out1 = (state[8] | state[9]);\n    assign out2 = (state[7] | state[9]);\n\nendmodule\n", "module top_module (\n    input in,\n    input [9:0] state,\n    output reg [9:0] next_state,\n    output reg out1,\n    output reg out2\n);\n\n    always @(*) begin\n        // Default outputs\n        out1 = 0;\n        out2 = 0;\n        next_state = 10'b0000000000; // reset next_state\n\n        case (1'b1) // synthesized priority encoder\n            state[0]: next_state = in ? 10'b0000000010 : 10'b0000000001;\n            state[1]: next_state = in ? 10'b0000000100 : 10'b0000000001;\n            state[2]: next_state = in ? 10'b0000001000 : 10'b0000000001;\n            state[3]: next_state = in ? 10'b0000010000 : 10'b0000000001;\n            state[4]: next_state = in ? 10'b0010000000 : 10'b0000000001;\n            state[5]: if (in) next_state = 10'b0000100000; else next_state = 10'b1000000000;\n            state[6]: if (in) next_state = 10'b0001000000; else next_state = 10'b0100000000;\n            state[7]: if (in) next_state = 10'b0001000000; else next_state = 10'b0000000001;\n            state[8]: if (in) next_state = 10'b0000000010; else next_state = 10'b0000000001;\n            state[9]: if (in) next_state = 10'b0000000010; else next_state = 10'b0000000001;\n        endcase\n        \n        // Set output based on the current state\n        case (1'b1)\n            state[8]: out1 = 1;\n            state[9]: begin\n                out1 = 1;\n                out2 = 1;\n            end\n            state[7]: out2 = 1;\n        endcase\n    end \n\nendmodule\n"]}
{"task_id": "ece241_2013_q7", "gptgen_RTL": ["module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;        // No change\n        2'b01: Q <= 0;        // Reset\n        2'b10: Q <= 1;        // Set\n        2'b11: Q <= ~Q;       // Toggle\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;           // When J=0, K=0, Q remains the same\n        2'b01: Q <= 0;           // When J=0, K=1, Q resets to 0\n        2'b10: Q <= 1;           // When J=1, K=0, Q sets to 1\n        2'b11: Q <= ~Q;          // When J=1, K=1, Q toggles\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;         // When J=0 and K=0, Q remains the same\n        2'b01: Q <= 1'b0;      // When J=0 and K=1, Q resets to 0\n        2'b10: Q <= 1'b1;      // When J=1 and K=0, Q sets to 1\n        2'b11: Q <= ~Q;        // When J=1 and K=1, Q toggles\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;            // When J=0 and K=0, Q remains the same\n        2'b01: Q <= 0;            // When J=0 and K=1, Q resets to 0\n        2'b10: Q <= 1;            // When J=1 and K=0, Q sets to 1\n        2'b11: Q <= ~Q;           // When J=1 and K=1, Q toggles\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;     // When J=0 and K=0, Q remains the same\n            2'b01: Q <= 0;     // When J=0 and K=1, Q resets to 0\n            2'b10: Q <= 1;     // When J=1 and K=0, Q sets to 1\n            2'b11: Q <= ~Q;    // When J=1 and K=1, Q toggles\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;       // When J=0 and K=0, Q remains the same\n            2'b01: Q <= 0;       // When J=0 and K=1, Q resets to 0\n            2'b10: Q <= 1;       // When J=1 and K=0, Q sets to 1\n            2'b11: Q <= ~Q;      // When J=1 and K=1, Q toggles\n        endcase\n    end\n    \nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;    // When J=0 and K=0, Q remains the same\n        2'b01: Q <= 0;    // When J=0 and K=1, Q resets to 0\n        2'b10: Q <= 1;    // When J=1 and K=0, Q sets to 1\n        2'b11: Q <= ~Q;   // When J=1 and K=1, Q toggles\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\n    always @(posedge clk) begin\n        case ({j, k})\n            2'b00: Q <= Q;          // When J=0 and K=0, Q remains the same\n            2'b01: Q <= 1'b0;       // When J=0 and K=1, Q resets to 0\n            2'b10: Q <= 1'b1;       // When J=1 and K=0, Q sets to 1\n            2'b11: Q <= ~Q;         // When J=1 and K=1, Q toggles\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;          // J=0, K=0: Hold state\n        2'b01: Q <= 1'b0;       // J=0, K=1: Reset\n        2'b10: Q <= 1'b1;       // J=1, K=0: Set\n        2'b11: Q <= ~Q;         // J=1, K=1: Toggle\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    case ({j, k})\n        2'b00: Q <= Q;        // No change\n        2'b01: Q <= 1'b0;     // Reset\n        2'b10: Q <= 1'b1;     // Set\n        2'b11: Q <= ~Q;       // Toggle\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "popcount3", "gptgen_RTL": ["module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Use bitwise reduction to calculate the number of '1's in the input vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of '1's in the 3-bit input vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of '1's in the 3-bit input vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of '1's in the 3-bit input\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Assign the sum of ones in the input vector to the output\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Counting the number of '1's in the 3-bit input vector\n    assign out = in[2] + in[1] + in[0];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    assign out = in[2] + in[1] + in[0];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of '1's in the 3-bit input\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Use a combination of bitwise operations and addition to count the number of '1's in the input vector\n    assign out = in[2] + in[1] + in[0];\n\nendmodule\n", "module top_module (\n    input [2:0] in,\n    output [1:0] out\n);\n\n    // Count the number of 1's in the input vector\n    assign out = in[0] + in[1] + in[2];\n\nendmodule\n"]}
{"task_id": "vector5", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~a ^ a;\n    assign out[23] = ~a ^ b;\n    assign out[22] = ~a ^ c;\n    assign out[21] = ~a ^ d;\n    assign out[20] = ~a ^ e;\n    \n    assign out[19] = ~b ^ a;\n    assign out[18] = ~b ^ b;\n    assign out[17] = ~b ^ c;\n    assign out[16] = ~b ^ d;\n    assign out[15] = ~b ^ e;\n    \n    assign out[14] = ~c ^ a;\n    assign out[13] = ~c ^ b;\n    assign out[12] = ~c ^ c;\n    assign out[11] = ~c ^ d;\n    assign out[10] = ~c ^ e;\n    \n    assign out[9]  = ~d ^ a;\n    assign out[8]  = ~d ^ b;\n    assign out[7]  = ~d ^ c;\n    assign out[6]  = ~d ^ d;\n    assign out[5]  = ~d ^ e;\n    \n    assign out[4]  = ~e ^ a;\n    assign out[3]  = ~e ^ b;\n    assign out[2]  = ~e ^ c;\n    assign out[1]  = ~e ^ d;\n    assign out[0]  = ~e ^ e;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    // Pairwise comparisons for each combination and their inverted versions\n    assign out[24] = a ~^ a;\n    assign out[23] = a ~^ b;\n    assign out[22] = a ~^ c;\n    assign out[21] = a ~^ d;\n    assign out[20] = a ~^ e;\n    assign out[19] = b ~^ a;\n    assign out[18] = b ~^ b;\n    assign out[17] = b ~^ c;\n    assign out[16] = b ~^ d;\n    assign out[15] = b ~^ e;\n    assign out[14] = c ~^ a;\n    assign out[13] = c ~^ b;\n    assign out[12] = c ~^ c;\n    assign out[11] = c ~^ d;\n    assign out[10] = c ~^ e;\n    assign out[9]  = d ~^ a;\n    assign out[8]  = d ~^ b;\n    assign out[7]  = d ~^ c;\n    assign out[6]  = d ~^ d;\n    assign out[5]  = d ~^ e;\n    assign out[4]  = e ~^ a;\n    assign out[3]  = e ~^ b;\n    assign out[2]  = e ~^ c;\n    assign out[1]  = e ~^ d;\n    assign out[0]  = e ~^ e;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n// Compute all pairwise comparisons\nassign out[24] = ~(a ^ a);\nassign out[23] = ~(a ^ b);\nassign out[22] = ~(a ^ c);\nassign out[21] = ~(a ^ d);\nassign out[20] = ~(a ^ e);\nassign out[19] = ~(b ^ a);\nassign out[18] = ~(b ^ b);\nassign out[17] = ~(b ^ c);\nassign out[16] = ~(b ^ d);\nassign out[15] = ~(b ^ e);\nassign out[14] = ~(c ^ a);\nassign out[13] = ~(c ^ b);\nassign out[12] = ~(c ^ c);\nassign out[11] = ~(c ^ d);\nassign out[10] = ~(c ^ e);\nassign out[9] = ~(d ^ a);\nassign out[8] = ~(d ^ b);\nassign out[7] = ~(d ^ c);\nassign out[6] = ~(d ^ d);\nassign out[5] = ~(d ^ e);\nassign out[4] = ~(e ^ a);\nassign out[3] = ~(e ^ b);\nassign out[2] = ~(e ^ c);\nassign out[1] = ~(e ^ d);\nassign out[0] = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9] = ~(d ^ a);\n    assign out[8] = ~(d ^ b);\n    assign out[7] = ~(d ^ c);\n    assign out[6] = ~(d ^ d);\n    assign out[5] = ~(d ^ e);\n    assign out[4] = ~(e ^ a);\n    assign out[3] = ~(e ^ b);\n    assign out[2] = ~(e ^ c);\n    assign out[1] = ~(e ^ d);\n    assign out[0] = ~(e ^ e);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    input e,\n    output [24:0] out\n);\n    // Assigning the outputs by comparing each bit with every other bit\n    assign out[24] = ~(a ^ a);\n    assign out[23] = ~(a ^ b);\n    assign out[22] = ~(a ^ c);\n    assign out[21] = ~(a ^ d);\n    assign out[20] = ~(a ^ e);\n    assign out[19] = ~(b ^ a);\n    assign out[18] = ~(b ^ b);\n    assign out[17] = ~(b ^ c);\n    assign out[16] = ~(b ^ d);\n    assign out[15] = ~(b ^ e);\n    assign out[14] = ~(c ^ a);\n    assign out[13] = ~(c ^ b);\n    assign out[12] = ~(c ^ c);\n    assign out[11] = ~(c ^ d);\n    assign out[10] = ~(c ^ e);\n    assign out[9]  = ~(d ^ a);\n    assign out[8]  = ~(d ^ b);\n    assign out[7]  = ~(d ^ c);\n    assign out[6]  = ~(d ^ d);\n    assign out[5]  = ~(d ^ e);\n    assign out[4]  = ~(e ^ a);\n    assign out[3]  = ~(e ^ b);\n    assign out[2]  = ~(e ^ c);\n    assign out[1]  = ~(e ^ d);\n    assign out[0]  = ~(e ^ e);\n\nendmodule\n"]}
{"task_id": "lemmings1", "gptgen_RTL": ["module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n    // State Encoding\n    localparam WALK_LEFT = 1'b0;\n    localparam WALK_RIGHT = 1'b1;\n\n    // State Register\n    reg state, next_state;\n\n    // State Transition Logic (Moore Machine)\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;  // Reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: \n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            WALK_RIGHT: \n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            default: \n                next_state = WALK_LEFT;  // Default case to handle unforeseen situations\n        endcase\n    end\n\n    // Output Logic based on the current state\n    always @(state) begin\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State Declarations\n    localparam WALK_LEFT = 1'b0;\n    localparam WALK_RIGHT = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Default case to handle unforeseen states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(state)\n            WALK_LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n            default: begin\n                walk_left = 1'b1; // Default to walking left\n                walk_right = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // Define states\n    typedef enum {WALK_LEFT, WALK_RIGHT} state_t;\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= WALK_LEFT;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and bumps\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Default case to handle unforeseen states\n        endcase\n    end\n\n    // Output logic corresponding to the state\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n        endcase\n    end\n    \nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State Encoding\n    localparam WALK_LEFT = 1'b0,\n               WALK_RIGHT = 1'b1;\n\n    // State Variable\n    reg state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT; // Reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT;\n        endcase\n    end\n\n    // Output Logic\n    always @(state) begin\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n    // Define states\n    parameter WALK_LEFT = 1'b0, WALK_RIGHT = 1'b1;\n    \n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= WALK_LEFT;  // Reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT;  // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin\n                walk_left = 1;  // Default output\n                walk_right = 0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    parameter WALK_LEFT = 1'b0;\n    parameter WALK_RIGHT = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State updating logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= WALK_LEFT;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Default state, should not occur\n        endcase\n    end\n\n    // Output logic based on the state\n    always @(state) begin\n        case(state)\n            WALK_LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    localparam WALK_LEFT = 1'b0;\n    localparam WALK_RIGHT = 1'b1;\n\n    // Current state and next state variable\n    reg current_state;\n    reg next_state;\n\n    // State transition logic: sequential block\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= WALK_LEFT; // Reset to walking left\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic: combinational block based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n\n            default: next_state = WALK_LEFT; // Defaulting to WALK_LEFT on undefined states\n        endcase\n    end\n\n    // Output logic based on the current state\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n\n            WALK_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n\n            default: begin\n                walk_left = 1'b1; // Default state is walking left if state is unknown\n                walk_right = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // Define states\n    parameter LEFT = 1'b0, RIGHT = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= LEFT; // Asynchronously reset to walking left\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            LEFT: begin\n                if (bump_left)\n                    next_state = RIGHT;\n                else\n                    next_state = LEFT;\n            end\n            RIGHT: begin\n                if (bump_right)\n                    next_state = LEFT;\n                else\n                    next_state = RIGHT;\n            end\n            default: next_state = LEFT; // Default case\n        endcase\n    end\n\n    // Output logic based on the state (Moore machine)\n    always @(state) begin\n        case (state)\n            LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // Define state encoding\n    localparam WALK_LEFT = 1'b0,\n               WALK_RIGHT = 1'b1;\n\n    // State variable\n    reg state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            // Asynchronously reset to walking left\n            state <= WALK_LEFT;\n        end\n        else begin\n            case (state)\n                WALK_LEFT: begin\n                    if (bump_left)\n                        state <= WALK_RIGHT;\n                end\n                WALK_RIGHT: begin\n                    if (bump_right)\n                        state <= WALK_LEFT;\n                end\n            endcase\n        end\n    end\n\n    // Output logic based on current state\n    always @(state) begin\n        case (state)\n            WALK_LEFT: begin\n                walk_left = 1'b1;\n                walk_right = 1'b0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 1'b0;\n                walk_right = 1'b1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input areset,\n    input bump_left,\n    input bump_right,\n    output reg walk_left,\n    output reg walk_right\n);\n\n    // State encoding\n    localparam WALK_LEFT = 1'b0;\n    localparam WALK_RIGHT = 1'b1;\n\n    // Current state and next state variables\n    reg current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            current_state <= WALK_LEFT; // Reset to walking left\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic using Moore state machine model\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                if (bump_left)\n                    next_state = WALK_RIGHT;\n                else\n                    next_state = WALK_LEFT;\n            end\n            WALK_RIGHT: begin\n                if (bump_right)\n                    next_state = WALK_LEFT;\n                else\n                    next_state = WALK_RIGHT;\n            end\n            default: next_state = WALK_LEFT; // Default state\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            WALK_LEFT: begin\n                walk_left = 1;\n                walk_right = 0;\n            end\n            WALK_RIGHT: begin\n                walk_left = 0;\n                walk_right = 1;\n            end\n            default: begin // Default output\n                walk_left = 1;\n                walk_right = 0;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "circuit1", "gptgen_RTL": ["module top_module (\n    input a, \n    input b, \n    output q\n);\n\nassign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\nassign q = a & b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output q\n);\n\nassign q = a & b; // AND gate functionality, q is 1 only when both a and b are 1.\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output q\n);\n\n    assign q = a & b; // AND operation\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\n    assign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\nassign q = a & b;\n\nendmodule\n", "module top_module (\n    input a, \n    input b, \n    output q\n);\n\nassign q = a & b;\n\nendmodule\n"]}
{"task_id": "2014_q3c", "gptgen_RTL": ["module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n    always @ (posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    \n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'bx;\n                z <= 1'bx;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= x ? 1'b1 : 1'b0;\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    // Next state logic for Y[0]\n    always @(posedge clk) begin\n        case (y)\n            3'b000: Y0 <= (x == 0) ? 1'b0 : 1'b1;\n            3'b001: Y0 <= (x == 0) ? 1'b1 : 1'b0;\n            3'b010: Y0 <= (x == 0) ? 1'b0 : 1'b1;\n            3'b011: Y0 <= (x == 0) ? 1'b1 : 1'b0;\n            3'b100: Y0 <= (x == 0) ? 1'b1 : 1'b0;\n            default: Y0 <= 1'b0;\n        endcase\n    end\n\n    // Output logic for z\n    always @(posedge clk) begin\n        case (y)\n            3'b000: z <= 1'b0;\n            3'b001: z <= 1'b0;\n            3'b010: z <= 1'b0;\n            3'b011: z <= (x == 0) ? 1'b1 : 1'b0;\n            3'b100: z <= (x == 0) ? 1'b1 : 1'b1;\n            default: z <= 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= x ? 1'b1 : 1'b0;  // Next state Y[0] when x=0 is 0, when x=1 is 1\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;  // Next state Y[0] when x=0 is 1, when x=1 is 0\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= x ? 1'b1 : 1'b0;  // Next state Y[0] when x=0 is 0, when x=1 is 1\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;  // Next state Y[0] when x=0 is 1, when x=1 is 0\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;  // Next state Y[0] when x=0 is 1, when x=1 is 0\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    \n    always @(posedge clk) begin\n        case (y)\n            3'b000: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            3'b001: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b0;\n            end\n            3'b010: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n            3'b011: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            3'b100: begin\n                Y0 <= x ? 1'b0 : 1'b1;\n                z <= 1'b1;\n            end\n            default: begin\n                Y0 <= 1'b0;\n                z <= 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\nalways @(posedge clk) begin\n    // Determine the next state for Y0 based on current state y and input x\n    case(y)\n        3'b000: Y0 <= x ? 1'b1 : 1'b0;\n        3'b001: Y0 <= x ? 1'b0 : 1'b1;\n        3'b010: Y0 <= x ? 1'b1 : 1'b0;\n        3'b011: Y0 <= x ? 1'b0 : 1'b1;\n        3'b100: Y0 <= x ? 1'b0 : 1'b1;\n        default: Y0 <= 1'b0;\n    endcase\n    \n    // Determine the output z based on current state y and input x\n    case(y)\n        3'b000: z <= 1'b0;\n        3'b001: z <= 1'b0;\n        3'b010: z <= 1'b0;\n        3'b011: z <= 1'b1;\n        3'b100: z <= 1'b1;\n        default: z <= 1'b0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n\nalways @(posedge clk) begin\n    case (y)\n        3'b000: begin\n            Y0 <= x ? 1'b1 : 1'b0;\n            z <= 1'b0;\n        end\n        3'b001: begin\n            Y0 <= x ? 1'b0 : 1'b1;\n            z <= 1'b0;\n        end\n        3'b010: begin\n            Y0 <= x ? 1'b1 : 1'b0;\n            z <= 1'b0;\n        end\n        3'b011: begin\n            Y0 <= x ? 1'b0 : 1'b1;\n            z <= 1'b1;\n        end\n        3'b100: begin\n            Y0 <= x ? 1'b0 : 1'b1;\n            z <= 1'b1;\n        end\n        default: begin\n            Y0 <= 1'b0;\n            z <= 1'b0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input x,\n    input [2:0] y,\n    output reg Y0,\n    output reg z\n);\n    // State encoding\n    localparam [2:0] S0 = 3'b000,\n                     S1 = 3'b001,\n                     S2 = 3'b010,\n                     S3 = 3'b011,\n                     S4 = 3'b100;\n\n    always @(posedge clk) begin\n        // Determine next state Y0 and output z based on current state y and input x\n        case (y)\n            S0: begin\n                Y0 <= 1'b0;  // Next state Y[0] when x=0 is 0\n                z <= 1'b0;   // Output z when in state 000\n            end\n            S1: begin\n                if (x) Y0 <= 1'b1;  // Next state Y[0] when x=1 is 1 (100)\n                else Y0 <= 1'b0;    // Next state Y[0] when x=0 is 0 (001)\n                z <= 1'b0;          // Output z when in state 001\n            end\n            S2: begin\n                if (x) Y0 <= 1'b0;  // Next state Y[0] when x=1 is 0 (001)\n                else Y0 <= 1'b1;    // Next state Y[0] when x=0 is 1 (010)\n                z <= 1'b0;          // Output z when in state 010\n            end\n            S3: begin\n                if (x) Y0 <= 1'b0;  // Next state Y[0] when x=1 is 0 (010)\n                else Y0 <= 1'b0;    // Next state Y[0] when x=0 is 0 (001)\n                z <= 1'b1;          // Output z when in state 011\n            end\n            S4: begin\n                if (x) Y0 <= 1'b1;  // Next state Y[0] when x=1 is 1 (100)\n                else Y0 <= 1'b1;    // Next state Y[0] when x=0 is 1 (011)\n                z <= 1'b1;          // Output z when in state 100\n            end\n            default: begin\n                Y0 <= 1'b0;  // Default case for safety\n                z <= 1'b0;\n            end\n        endcase\n    end\nendmodule\n"]}
{"task_id": "wire4", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n// Assignments as per the connections described\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n// Assigning inputs directly to outputs as per the connections described\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\n// Assigning inputs to outputs as per the specified connections\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    output w,\n    output x,\n    output y,\n    output z\n);\n\nassign w = a;\nassign x = b;\nassign y = b;\nassign z = c;\n\nendmodule\n"]}
{"task_id": "always_case", "gptgen_RTL": ["module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case (sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    \n    always @(*) begin\n        case (sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n    always @(*) begin\n        case(sel)\n            3'b000: out = data0;\n            3'b001: out = data1;\n            3'b010: out = data2;\n            3'b011: out = data3;\n            3'b100: out = data4;\n            3'b101: out = data5;\n            default: out = 4'b0000;  // For sel values not between 0 to 5, output should be 0\n        endcase\n    end\nendmodule\n", "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\nalways @(*) begin\n    case(sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            3'd0: out = data0;\n            3'd1: out = data1;\n            3'd2: out = data2;\n            3'd3: out = data3;\n            3'd4: out = data4;\n            3'd5: out = data5;\n            default: out = 4'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [2:0] sel,\n    input [3:0] data0,\n    input [3:0] data1,\n    input [3:0] data2,\n    input [3:0] data3,\n    input [3:0] data4,\n    input [3:0] data5,\n    output reg [3:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        3'b000: out = data0;\n        3'b001: out = data1;\n        3'b010: out = data2;\n        3'b011: out = data3;\n        3'b100: out = data4;\n        3'b101: out = data5;\n        default: out = 4'b0000;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "timer", "gptgen_RTL": ["module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter;  // Declare a 10-bit counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the value from the input data\n            counter <= data;\n            tc <= 0; // Reset the terminal count signal\n        end else if (counter > 0) begin\n            // Decrement the counter if not already at zero\n            counter <= counter - 1;\n            // Check if the counter has reached zero\n            if (counter == 1) tc <= 1;\n        end\n        // If counter is zero, ensure it stays at zero and set tc high\n        if (counter == 0) begin\n            tc <= 1; // Set terminal count high when counter reaches zero\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;  // Load the counter with the input data\n        end\n        else if (counter > 0) begin\n            counter <= counter - 1;  // Decrement the counter\n        end\n\n        // Set the terminal count signal when counter reaches 0\n        tc <= (counter == 0) ? 1'b1 : 1'b0;\n    end\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter; // Internal counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the input data when load signal is high\n            counter <= data;\n            tc <= 0; // Reset terminal count signal\n        end\n        else if (!load && counter > 0) begin\n            // Decrement the counter if load is low and counter is not zero\n            counter <= counter - 1;\n            // Check if counter reaches zero\n            if (counter == 1) begin // Check one because counter will be decremented this cycle\n                tc <= 1; // Set terminal count signal\n            end\n        end\n        \n        // Handle the condition when counter reaches zero\n        if (counter == 0) begin\n            tc <= 1; // Ensure terminal count remains high when counter is zero\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [9:0] data,\n    output reg tc\n);\n\n    reg [9:0] counter;  // Internal counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the input data when load signal is asserted\n            counter <= data;\n            tc <= 0;  // Reset the terminal count signal\n        end else if (counter > 0) begin\n            // Decrement the counter if it's greater than 0\n            counter <= counter - 1;\n        end\n\n        // Set the terminal count signal when counter reaches zero\n        if (counter == 0) begin\n            tc <= 1;\n        end else begin\n            tc <= 0;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [9:0] data,\n    output reg tc\n);\n    reg [9:0] counter;  // 10-bit internal counter\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the incoming data when load signal is high\n            counter <= data;\n            tc <= 0;  // Reset terminal count signal\n        end else if (counter > 0) begin\n            // Decrement the counter if it is greater than 0\n            counter <= counter - 1;\n            tc <= (counter == 1);  // Set tc high when counter reaches 1 and will be 0 at next clock\n        end else begin\n            // Keep terminal count high if counter is already 0\n            tc <= (counter == 0);\n        end\n    end\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            counter <= data;  // Load the counter with the input data\n            tc <= 0;          // Reset tc when new data is loaded\n        end else if (counter > 0) begin\n            counter <= counter - 1;  // Decrement the counter\n            tc <= 0;                 // Ensure tc is 0 while counting\n        end\n        \n        if (counter == 0)\n            tc <= 1;  // Set tc when counter reaches 0\n    end\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    // Declare counter register\n    reg [9:0] counter;\n\n    // Update counter and tc every clock cycle\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with input data when load is high\n            counter <= data;\n            tc <= 0; // Reset terminal count signal when loading new value\n        end else if (counter > 0) begin\n            // Decrement counter if load is not asserted and counter is not zero\n            counter <= counter - 1'b1;\n            tc <= 0; // Ensure tc remains low while counter is not zero\n        end\n        \n        // Set terminal count high when counter reaches zero\n        if (counter == 0) begin\n            tc <= 1'b1;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] count;  // Internal counter\n\n    // Sequential logic for the counter\n    always @(posedge clk) begin\n        if (load) begin\n            count <= data;      // Load the counter with new data when load is asserted\n            tc <= 0;            // Reset terminal count signal on load\n        end\n        else if (count > 0) begin\n            count <= count - 1; // Decrement the counter\n            tc <= 0;            // Ensure terminal count is not asserted while counting\n        end\n        \n        // Check if the counter has reached zero\n        if (count == 0) begin\n            tc <= 1;            // Assert terminal count signal when count is zero\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] counter;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the counter with the data provided when load signal is high\n            counter <= data;\n            tc <= 0; // Reset the terminal count signal when new data is loaded\n        end\n        else if (counter > 0) begin\n            // Decrement the counter when load signal is low\n            counter <= counter - 1;\n        end\n\n        // Set the terminal count signal when counter reaches zero\n        if (counter == 0)\n            tc <= 1;\n        else\n            tc <= 0;\n    end\n\nendmodule\n", "module top_module(\n    input clk, \n    input load, \n    input [9:0] data, \n    output reg tc\n);\n    reg [9:0] count;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the count value when load is asserted\n            count <= data;\n            tc <= 0; // Reset terminal count signal when loading new value\n        end\n        else if (count > 0) begin\n            // Decrement the counter if it's greater than 0 and load is not asserted\n            count <= count - 1;\n            tc <= 0; // Ensure tc remains low while counting\n        end\n        \n        // Check if the counter has reached zero\n        if (count == 0) begin\n            tc <= 1; // Assert terminal count signal when counter reaches zero\n        end\n    end\n\nendmodule\n"]}
{"task_id": "dff8r", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b00000000; // Set all DFF outputs to 0\n    else\n        q <= d; // Load d into q on the rising edge of clk if reset is not high\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b0;  // Set all bits of q to 0 when reset is active high\n    else\n        q <= d;     // Load data into q on the rising edge of clk when reset is not active\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b00000000;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b00000000; // Set all flip-flops to 0 on reset\n        else\n            q <= d; // Load the data into the flip-flops on clock edge\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (reset)\n            q <= 8'b0; // Reset all flip-flops to 0\n        else\n            q <= d; // Load d into q on clock edge\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else begin\n            q <= d;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "edgedetect2", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in ^ prev_in) & ~prev_in; // Detect 0 to 1 transitions\n        prev_in <= in; // Update previous input state\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    anyedge <= (in ^ prev_in) & ~prev_in; // Detects rising edge from previous state\n    prev_in <= in; // Update previous input state\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // Previous state of input to detect edges\n    reg [7:0] prev_in;\n\n    // Detect edge on a per-bit basis\n    always @(posedge clk) begin\n        // Check every bit for changes\n        anyedge <= (prev_in ^ in) & ~prev_in;  // Detect rising edge: current is 1, previous was 0\n        prev_in <= in;  // Update previous input state\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] prev_in;\n\n    // On each clock cycle, check for edges on each bit\n    always @(posedge clk) begin\n        anyedge <= (prev_in ^ in) & ~prev_in;  // Detect 0 to 1 transitions\n        prev_in <= in;  // Update previous input\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] in_prev;\n\n    always @(posedge clk) begin\n        anyedge <= (in_prev ^ in) & ~in_prev; // Detects 0 to 1 transition\n        in_prev <= in;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    reg [7:0] previous_in;\n\n    always @(posedge clk) begin\n        anyedge <= (in ^ previous_in) & in; // Detect 0 to 1 transitions\n        previous_in <= in; // Update previous input state\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    // Previous state of the input to detect edges\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Loop over each bit to detect edges\n        integer i;\n        for (i = 0; i < 8; i = i + 1) begin\n            // Check if there was a transition from 0 to 1\n            if (prev_in[i] == 0 && in[i] == 1)\n                anyedge[i] <= 1;\n            else\n                anyedge[i] <= 0;\n        end\n\n        // Update the previous input state\n        prev_in <= in;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n    // Previous state of the input to detect edges\n    reg [7:0] prev_in;\n\n    // Detect edges on a positive clock edge\n    always @(posedge clk) begin\n        anyedge <= (in ^ prev_in) & in; // Detects any edge on each bit\n        prev_in <= in; // Update previous input\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // Previous cycle input storage\n    reg [7:0] prev_in;\n\n    // Initialize the previous input value\n    initial begin\n        prev_in = 8'b0;\n    end\n\n    always @(posedge clk) begin\n        // Loop through each bit to detect edges\n        integer i;\n        for (i = 0; i < 8; i = i + 1) begin\n            // Check for a positive edge (0 to 1 transition)\n            if (prev_in[i] == 0 && in[i] == 1) begin\n                anyedge[i] <= 1;\n            end else begin\n                anyedge[i] <= 0;\n            end\n        end\n\n        // Update previous input to current input\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] anyedge\n);\n\n    // Register to hold the previous state of the input\n    reg [7:0] prev_in;\n\n    // Initial block to set initial values\n    initial begin\n        prev_in = 8'b0;\n        anyedge = 8'b0;\n    end\n\n    // Always block to detect edges\n    always @(posedge clk) begin\n        // Loop through each bit to detect edges\n        integer i;\n        for (i = 0; i < 8; i = i + 1) begin\n            // Check for edge from 0 to 1\n            if (!prev_in[i] && in[i]) begin\n                anyedge[i] <= 1'b1;\n            end else begin\n                anyedge[i] <= 1'b0;\n            end\n        end\n        // Update previous input\n        prev_in <= in;\n    end\n\nendmodule\n"]}
{"task_id": "circuit9", "gptgen_RTL": ["module top_module (\n    input clk,\n    input a,\n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 4;\n        end else begin\n            if (q == 6) begin\n                q <= 0;\n            end else begin\n                q <= q + 1;\n            end\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a,\n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a == 1'b0) begin\n            q <= q + 1;\n        end\n        else if (q != 4) begin\n            q <= 4;\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    // Initialization of state\n    initial q = 3'b000;\n\n    // Process defining the behavior of state change on clock edge\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 4;  // When 'a' is 1, set 'q' to 4\n        end else begin\n            if (q == 6) begin\n                q <= 0;  // Reset to 0 if 'q' reaches 6\n            end else begin\n                q <= q + 1;  // Otherwise, increment 'q'\n            end\n        end\n    end\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a == 1)\n            q <= 4;  // Output remains constant at 4 when 'a' is 1\n        else\n            q <= (q + 1) % 7;  // Cycles through 0-6 when 'a' is 0\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput a,\n\toutput reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'b100; // Set q to 4 when 'a' is 1\n        end else begin\n            if (q == 3'b110) // q is 6\n                q <= 3'b000; // Reset q to 0\n            else\n                q <= q + 1; // Increment q\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 3'b100;  // When 'a' is high, q is set to 4.\n        end else begin\n            q <= q + 1;   // When 'a' is low, increment q.\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\n    always @(posedge clk) begin\n        if (a) begin\n            q <= 4;\n        end else begin\n            q <= (q + 1) % 8;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\nalways @(posedge clk) begin\n    if (a == 1'b0) begin\n        q <= q + 1;\n    end\n    else if (a == 1'b1) begin\n        q <= 4;\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n    always @(posedge clk) begin\n        if (a)\n            q <= 3'b100; // If 'a' is high, set 'q' to 4 (binary 100).\n        else\n            q <= q + 1; // If 'a' is low, increment 'q'.\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input a, \n    output reg [2:0] q\n);\n\nalways @(posedge clk) begin\n    if (a == 1) begin\n        q <= 4;\n    end else begin\n        if (q == 6) begin\n            q <= 0;\n        end else begin\n            q <= q + 1;\n        end\n    end\nend\n\nendmodule\n"]}
{"task_id": "lfsr5", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset LFSR to 1\n        end else begin\n            q <= {q[3], q[2], q[1] ^ q[4], q[0] ^ q[4], q[4]}; // Shift and apply taps\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 5'b00001;  // Reset to 1 (binary 00001)\n        end else begin\n            q <= {q[3], q[2], q[1], q[0], q[4] ^ q[2]};  // Feedback from tap positions 5 and 3\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 5'b00001; // Reset to 1, represented in 5-bit binary\n    else begin\n        q[4] <= q[3] ^ q[0]; // Feedback from tap positions 5 and 3 (index 4 and 2)\n        q[3] <= q[2];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4]; // Shift the register\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 5'b00001;  // Reset LFSR output to 1\n    else begin\n        q[4] <= q[3] ^ q[0];  // XOR tap at position 5 and 3 (0-based indexing)\n        q[3] <= q[2];\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];  // Feedback the output of the XOR into the lowest bit\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 5'b00001; // Reset state, output set to 1\n    else begin\n        q[4] <= q[0] ^ q[2]; // Feedback from tap at position 5 and 3 (q[4] and q[2])\n        q[3] <= q[4];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n// Taps on bit positions 5 and 3, but Verilog uses 0-indexing\n// Tap positions according to 0-index are 4 and 2\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 5'b00001;  // Reset state per problem statement is 1\n    end else begin\n        q[4] <= q[3] ^ q[1]; // New bit 5 is XOR of bits 4 and 2 (0-indexed)\n        q[3] <= q[2];        // Shift left operation\n        q[2] <= q[1];\n        q[1] <= q[0];\n        q[0] <= q[4];        // Feedback from the newly computed bit 5\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    wire feedback;\n\n    // XOR tap positions 5 and 3 (q[4] and q[2])\n    assign feedback = q[4] ^ q[2];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 5'b00001; // Reset the LFSR to 1 (binary 00001)\n        end else begin\n            q <= {q[3:0], feedback}; // Shift left and introduce feedback in LSB\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n// Initialize the LFSR with a non-zero value (all zeroes is not part of the cycle in a maximal-length LFSR)\ninitial q = 5'b00001;\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset LFSR to the value of 1\n        q <= 5'b00001;\n    end else begin\n        // Compute the next state of the LFSR\n        q[4] <= q[0] ^ q[2]; // Tap at position 5 (q[4]) and 3 (q[2])\n        q[3] <= q[4];        // Shift left\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1];\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 5'b00001;  // Set initial state to 1\n    end\n    else begin\n        // Galois LFSR with taps at bit positions 5 and 3\n        // Feedback is calculated as the XOR of tap positions.\n        // Note: Verilog bit indices are 0-based.\n        q[4] <= q[0];\n        q[3] <= q[4] ^ q[0];\n        q[2] <= q[3];\n        q[1] <= q[2];\n        q[0] <= q[1] ^ q[0];\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [4:0] q\n);\n\n    wire feedback;\n\n    // XOR tap positions 5 and 3 (corresponding to q[4] and q[2] in 0-indexed array)\n    assign feedback = q[4] ^ q[2];\n\n    always @(posedge clk) begin\n        if (reset) begin\n            // Reset the LFSR output to 00001\n            q <= 5'b00001;\n        end else begin\n            // Shift left all the bits\n            q <= {q[3:0], feedback};\n        end\n    end\n\nendmodule\n"]}
{"task_id": "bugs_addsubz", "gptgen_RTL": ["module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        if (out == 0)\n            result_is_zero = 1'b1;\n        else\n            result_is_zero = 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Corrected the condition to properly detect if out is zero\n        result_is_zero = (out == 0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Correctly comparing all bits to check if result is zero\n        result_is_zero = (out == 0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Corrected checking of the output for zero condition\n        result_is_zero = (out == 8'b0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'd0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        result_is_zero = (out == 8'b0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Correct way to check if 'out' is zero.\n        result_is_zero = (out == 0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Correct the condition to check if the output is zero\n        if (out == 0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Use correct condition to set the result_is_zero flag\n        if (out == 0)\n            result_is_zero = 1;\n        else\n            result_is_zero = 0;\n    end\n\nendmodule\n", "module top_module (\n    input do_sub,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] out,\n    output reg result_is_zero\n);\n\n    always @(*) begin\n        case (do_sub)\n            0: out = a + b;\n            1: out = a - b;\n        endcase\n\n        // Correctly set result_is_zero based on the output value\n        result_is_zero = (out == 8'd0) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n"]}
{"task_id": "bugs_case", "gptgen_RTL": ["module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        // Initialize the outputs\n        out = 4'b0000;\n        valid = 1'b0;\n\n        // Check for each scancode and set the corresponding outputs\n        case (code)\n            8'h45: begin\n                out = 4'b0000;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'b0001;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'b0010;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'b0011;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'b0100;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'b0101;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'b0110;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'b0111;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'b1000;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'b1001;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'b0000;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\nalways @(*) begin\n    valid = 1'b1; // Assume valid unless proven otherwise\n    case (code)\n        8'h45: out = 4'd0;\n        8'h16: out = 4'd1;\n        8'h1e: out = 4'd2;\n        8'h26: out = 4'd3;\n        8'h25: out = 4'd4;\n        8'h2e: out = 4'd5;\n        8'h36: out = 4'd6;\n        8'h3d: out = 4'd7;\n        8'h3e: out = 4'd8;\n        8'h46: out = 4'd9;\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\nalways @(*) begin\n    // Default output values\n    out = 4'd0;  // default key output value\n    valid = 1'b0;  // default valid output value\n\n    // Decode the input code\n    case (code)\n        8'h45: begin\n            out = 4'd0;\n            valid = 1'b1;\n        end\n        8'h16: begin\n            out = 4'd1;\n            valid = 1'b1;\n        end\n        8'h1e: begin\n            out = 4'd2;\n            valid = 1'b1;\n        end\n        8'h26: begin\n            out = 4'd3;\n            valid = 1'b1;\n        end\n        8'h25: begin\n            out = 4'd4;\n            valid = 1'b1;\n        end\n        8'h2e: begin\n            out = 4'd5;\n            valid = 1'b1;\n        end\n        8'h36: begin\n            out = 4'd6;\n            valid = 1'b1;\n        end\n        8'h3d: begin\n            out = 4'd7;\n            valid = 1'b1;\n        end\n        8'h3e: begin\n            out = 4'd8;\n            valid = 1'b1;\n        end\n        8'h46: begin\n            out = 4'd9;\n            valid = 1'b1;\n        end\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n    always @(*) begin\n        case(code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\nalways @(*) begin\n    valid = 1'b1; // Assume the input is valid initially\n    case (code)\n        8'h45: out = 4'd0;\n        8'h16: out = 4'd1;\n        8'h1e: out = 4'd2;\n        8'h26: out = 4'd3;\n        8'h25: out = 4'd4;\n        8'h2e: out = 4'd5;\n        8'h36: out = 4'd6;\n        8'h3d: out = 4'd7;\n        8'h3e: out = 4'd8;\n        8'h46: out = 4'd9;\n        default: begin\n            out = 4'd0;\n            valid = 1'b0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        // Initialize output to indicate invalid input by default\n        out = 4'b0000;\n        valid = 1'b0;\n\n        // Check for each scancode and assign corresponding output\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1E: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2E: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3D: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3E: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [7:0] code,\n    output reg [3:0] out,\n    output reg valid\n);\n\n    always @(*) begin\n        case (code)\n            8'h45: begin\n                out = 4'd0;\n                valid = 1'b1;\n            end\n            8'h16: begin\n                out = 4'd1;\n                valid = 1'b1;\n            end\n            8'h1e: begin\n                out = 4'd2;\n                valid = 1'b1;\n            end\n            8'h26: begin\n                out = 4'd3;\n                valid = 1'b1;\n            end\n            8'h25: begin\n                out = 4'd4;\n                valid = 1'b1;\n            end\n            8'h2e: begin\n                out = 4'd5;\n                valid = 1'b1;\n            end\n            8'h36: begin\n                out = 4'd6;\n                valid = 1'b1;\n            end\n            8'h3d: begin\n                out = 4'd7;\n                valid = 1'b1;\n            end\n            8'h3e: begin\n                out = 4'd8;\n                valid = 1'b1;\n            end\n            8'h46: begin\n                out = 4'd9;\n                valid = 1'b1;\n            end\n            default: begin\n                out = 4'd0;\n                valid = 1'b0;\n            end\n        endcase\n    end\nendmodule\n"]}
{"task_id": "vectorr", "gptgen_RTL": ["module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n    assign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\n// Reversing bit order of the 8-bit input\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [7:0] out\n);\n\nassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\n\nendmodule\n"]}
{"task_id": "kmap3", "gptgen_RTL": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000, 4'b0001: out = 1'bx; // Don't care\n            4'b0010, 4'b0011: out = 0;\n            4'b0100, 4'b0101: out = 1;\n            4'b0110, 4'b0111: out = 1;\n            4'b1000, 4'b1001: out = 0;\n            4'b1010, 4'b1011: out = 0;\n            4'b1100, 4'b1101: out = 0;\n            4'b1110, 4'b1111: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1;  // Addressing don't-care (d) as 1 for optimization\n            4'b0001: out = 0;\n            4'b0010: out = 1;\n            4'b0011: out = 1;\n            4'b0100: out = 0;\n            4'b0101: out = 0;\n            4'b0110: out = 0;  // Addressing don't-care (d) as 0 for simplicity\n            4'b0111: out = 0;  // Addressing don't-care (d) as 0 for simplicity\n            4'b1000: out = 0;\n            4'b1001: out = 1;\n            4'b1010: out = 1;\n            4'b1011: out = 1;\n            4'b1100: out = 0;\n            4'b1101: out = 1;\n            4'b1110: out = 1;\n            4'b1111: out = 1;\n            default: out = 0;  // Fallback for undefined cases\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000, 4'b0001: out = 1'b0; // ab=00, cd=00\n            4'b0010, 4'b0011: out = 1'b1; // ab=00, cd=01\n            4'b0100, 4'b0101: out = 1'b0; // ab=00, cd=10\n            4'b0110, 4'b0111: out = 1'b0; // ab=00, cd=11\n            4'b1000, 4'b1001: out = 1'b0; // ab=01, cd=00\n            4'b1010, 4'b1011: out = 1'b0; // ab=01, cd=01\n            4'b1100, 4'b1101: out = 1'b1; // ab=01, cd=10\n            4'b1110, 4'b1111: out = 1'b1; // ab=01, cd=11\n            4'b0002, 4'b0003: out = 1'b1; // ab=10, cd=00\n            4'b0012, 4'b0013: out = 1'b1; // ab=10, cd=01\n            4'b0102, 4'b0103: out = 1'b1; // ab=10, cd=10\n            4'b0112, 4'b0113: out = 1'b1; // ab=10, cd=11\n            4'b1002, 4'b1003: out = 1'b1; // ab=11, cd=00\n            4'b1012, 4'b1013: out = 1'b1; // ab=11, cd=01\n            4'b1102, 4'b1103: out = 1'b1; // ab=11, cd=10\n            4'b1112, 4'b1113: out = 1'b1; // ab=11, cd=11\n            default: out = 1'bx; // Should not happen, using x to denote unknown\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'b1; // abcd = 0000 -> d (choose 1)\n            4'b0001: out = 1'b0; // abcd = 0001 -> 0\n            4'b0010: out = 1'b1; // abcd = 0010 -> 1\n            4'b0011: out = 1'b1; // abcd = 0011 -> 1\n            4'b0100: out = 1'b0; // abcd = 0100 -> 0\n            4'b0101: out = 1'b0; // abcd = 0101 -> 0\n            4'b0110: out = 1'b1; // abcd = 0110 -> d (choose 1)\n            4'b0111: out = 1'b1; // abcd = 0111 -> d (choose 1)\n            4'b1000: out = 1'b0; // abcd = 1000 -> 0\n            4'b1001: out = 1'b1; // abcd = 1001 -> 1\n            4'b1010: out = 1'b1; // abcd = 1010 -> 1\n            4'b1011: out = 1'b1; // abcd = 1011 -> 1\n            4'b1100: out = 1'b0; // abcd = 1100 -> 0\n            4'b1101: out = 1'b1; // abcd = 1101 -> 1\n            4'b1110: out = 1'b1; // abcd = 1110 -> 1\n            4'b1111: out = 1'b1; // abcd = 1111 -> 1\n            default: out = 1'b0; // default case to handle any other combination\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'bx;  // d\n            4'b0001: out = 1'b0;\n            4'b0010: out = 1'b1;\n            4'b0011: out = 1'b1;\n            4'b0100: out = 1'b0;\n            4'b0101: out = 1'b0;\n            4'b0110: out = 1'bx;  // d\n            4'b0111: out = 1'bx;  // d\n            4'b1000: out = 1'b0;\n            4'b1001: out = 1'b1;\n            4'b1010: out = 1'b1;\n            4'b1011: out = 1'b1;\n            4'b1100: out = 1'b0;\n            4'b1101: out = 1'b1;\n            4'b1110: out = 1'b1;\n            4'b1111: out = 1'b1;\n            default: out = 1'bx;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: out = 1'b1; // ab = 00, cd = 00\n            4'b0100, 4'b0101: out = 1'b0;                   // ab = 01, cd = 00\n            4'b0110, 4'b0111: out = 1'b1;                   // ab = 01, cd others\n            4'b1000, 4'b1001, 4'b1010, 4'b1011: out = 1'b0; // ab = 10, cd = 01\n            4'b1100: out = 1'b0;                            // ab = 11, cd = 00\n            4'b1101, 4'b1110, 4'b1111: out = 1'b1;          // ab = 11, cd others\n            default: out = 1'b0;                            // Default case for don't care handling\n        endcase\n    end\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 0; // abcd = 0000 -> d (choose 0 for simplicity)\n            4'b0001: out = 0; // abcd = 0001 -> 0\n            4'b0010: out = 1; // abcd = 0010 -> 1\n            4'b0011: out = 1; // abcd = 0011 -> 1\n            4'b0100: out = 0; // abcd = 0100 -> 0\n            4'b0101: out = 0; // abcd = 0101 -> 0\n            4'b0110: out = 0; // abcd = 0110 -> d (choose 0 for simplicity)\n            4'b0111: out = 0; // abcd = 0111 -> d (choose 0 for simplicity)\n            4'b1000: out = 0; // abcd = 1000 -> 0\n            4'b1001: out = 1; // abcd = 1001 -> 1\n            4'b1010: out = 1; // abcd = 1010 -> 1\n            4'b1011: out = 1; // abcd = 1011 -> 1\n            4'b1100: out = 0; // abcd = 1100 -> 0\n            4'b1101: out = 1; // abcd = 1101 -> 1\n            4'b1110: out = 1; // abcd = 1110 -> 1\n            4'b1111: out = 1; // abcd = 1111 -> 1\n            default: out = 0;  // Default case to handle don't-care situations explicitly\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 1'bx; // Don't care\n            4'b0001: out = 0;\n            4'b0010: out = 1;\n            4'b0011: out = 1;\n            4'b0100: out = 0;\n            4'b0101: out = 0;\n            4'b0110: out = 1'bx; // Don't care\n            4'b0111: out = 1'bx; // Don't care\n            4'b1000: out = 0;\n            4'b1001: out = 1;\n            4'b1010: out = 1;\n            4'b1011: out = 1;\n            4'b1100: out = 0;\n            4'b1101: out = 1;\n            4'b1110: out = 1;\n            4'b1111: out = 1;\n            default: out = 1'bx; // Default case for safety, though all cases are handled\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000: out = 0; // cd=00, ab=00\n            4'b0001: out = 0; // cd=00, ab=01\n            4'b0010: out = 1; // cd=00, ab=10\n            4'b0011: out = 1; // cd=00, ab=11\n            4'b0100: out = 0; // cd=01, ab=00\n            4'b0101: out = 0; // cd=01, ab=01\n            4'b0110: out = 0; // cd=01, ab=10\n            4'b0111: out = 0; // cd=01, ab=11\n            4'b1000: out = 0; // cd=10, ab=00\n            4'b1001: out = 1; // cd=10, ab=01\n            4'b1010: out = 1; // cd=10, ab=10\n            4'b1011: out = 1; // cd=10, ab=11\n            4'b1100: out = 0; // cd=11, ab=00\n            4'b1101: out = 1; // cd=11, ab=01\n            4'b1110: out = 1; // cd=11, ab=10\n            4'b1111: out = 1; // cd=11, ab=11\n            default: out = 0; // Default case to handle any unspecified combinations\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case ({a, b, c, d})\n            4'b0000, 4'b0001: out = 1'b0; // abcd = 0000, 0001 (don't care, can be 0 or 1)\n            4'b0010: out = 1'b1; // abcd = 0010\n            4'b0011: out = 1'b1; // abcd = 0011\n            4'b0100, 4'b0101: out = 1'b0; // abcd = 0100, 0101\n            4'b0110, 4'b0111: out = 1'bx; // abcd = 0110, 0111 (don't care, can be 0 or 1)\n            4'b1000, 4'b1001: out = 1'b1; // abcd = 1000, 1001\n            4'b1010, 4'b1011: out = 1'b1; // abcd = 1010, 1011\n            4'b1100, 4'b1101: out = 1'b1; // abcd = 1100, 1101\n            4'b1110, 4'b1111: out = 1'b1; // abcd = 1110, 1111\n            default: out = 1'bx; // Cover all unspecified cases\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "count15", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0000; // Reset the counter to 0 when reset is high\n    end else begin\n        if (q == 4'b1111) begin\n            q <= 4'b0000; // Reset the counter to 0 if it reaches 15\n        end else begin\n            q <= q + 1; // Otherwise, increment the counter\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else if (q == 4'b1111)\n        q <= 4'b0000;\n    else\n        q <= q + 1'b1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;  // Reset counter to 0 when reset is high\n    else\n        q <= q + 4'b0001;  // Increment counter by 1\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else\n        q <= q + 1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1111)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1111)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else\n        q <= (q == 4'b1111) ? 4'b0000 : q + 1'b1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else\n            q <= (q == 4'b1111) ? 4'b0000 : q + 1'b1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;\n    else\n        q <= (q == 4'b1111) ? 4'b0000 : q + 1;\nend\n\nendmodule\n"]}
{"task_id": "always_if", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n// Using assign statement for combinational logic\nassign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n// Using always block with procedural if statement\nalways @(*) begin\n    if (sel_b1 && sel_b2)\n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n// Using continuous assignment statement\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// Using procedural assignment inside an always block\nalways @(*) begin\n    if (sel_b1 & sel_b2)\n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using always block for procedural conditional logic\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using continuous assignment statement\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using procedural block with if statement\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n// Using assign statement for combinational logic\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// Using always block for procedural approach\nalways @ (a, b, sel_b1, sel_b2) begin\n    if (sel_b1 & sel_b2)\n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using continuous assignment with a conditional operator\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using procedural statements within an always block\n    always @(*) begin\n        if (sel_b1 && sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using a continuous assignment statement\n    assign out_assign = (sel_b1 && sel_b2) ? b : a;\n\n    // Using a procedural block with an if statement\n    always @(*) begin\n        if (sel_b1 && sel_b2) out_always = b;\n        else out_always = a;\n    end\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n// Using continuous assignment with a conditional operator\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// Using procedural assignment within an always block\nalways @(*) begin\n    if (sel_b1 & sel_b2) \n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n// Using assign statement\nassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n// Using procedural if statement inside an always block\nalways @(*) begin\n    if (sel_b1 & sel_b2)\n        out_always = b;\n    else\n        out_always = a;\nend\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel_b1,\n    input sel_b2,\n    output out_assign,\n    output reg out_always\n);\n\n    // Using assign statement for combinational logic\n    assign out_assign = (sel_b1 & sel_b2) ? b : a;\n\n    // Using always block for procedural assignment\n    always @(*) begin\n        if (sel_b1 & sel_b2)\n            out_always = b;\n        else\n            out_always = a;\n    end\n\nendmodule\n"]}
{"task_id": "kmap1", "gptgen_RTL": ["module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    // Implementing the logic from the Karnaugh map\n    assign out = (b & c) | (~b & c) | (a & b) | (a & ~b);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (b & c) | (a & ~b & ~c) | (a & b & ~c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n// Implementing the function using the Karnaugh map provided\nassign out = (b & c) | (a & ~b & c) | (a & b & ~c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (b & c) | a;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    // Implementing the logic from the Karnaugh map\n    assign out = (b & c) | (a & ~b & c) | (a & b & ~c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n// According to the Karnaugh map provided, \n// the resulting simplified Boolean expression is:\n// out = b or c\n\nassign out = b | c;\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (b & c) | (a & ~b & c) | (a & b & ~c) | (a & b & c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (b & c) | (a & ~b & c) | (a & b & ~c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n    assign out = (~a & b) | (b & c) | (a & c);\n\nendmodule\n", "module top_module(\n    input a, \n    input b,\n    input c,\n    output out\n);\n\n// The Karnaugh map simplifies the Boolean expression to:\n// out = ~a & b | ~a & c | a & b & c | a & ~b & c | a & b & ~c\n// which can be further simplified using Boolean algebra:\nassign out = b | (a & c);\n\nendmodule\n"]}
{"task_id": "2013_q2afsm", "gptgen_RTL": ["module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        STATE_A,\n        STATE_B,\n        STATE_C,\n        STATE_D\n    } state_t;\n\n    // State variables\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_D: begin\n                // Assuming STATE_D will behave similarly to STATE_C and STATE_B\n                if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output when no grant is given\n        case (current_state)\n            STATE_B: g[1] = r[1]; // Grant to device 1\n            STATE_C: g[2] = r[2]; // Grant to device 2\n            STATE_D: g[3] = r[3]; // Grant to device 3\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State declaration\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    // State variables\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_D: begin\n                if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (!resetn)\n            g <= 3'b000;\n        else\n            case (current_state)\n                STATE_A: g <= 3'b000;\n                STATE_B: g <= 3'b100;\n                STATE_C: g <= 3'b010;\n                STATE_D: g <= 3'b001;\n                default: g <= 3'b000;\n            endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n\n            STATE_D: begin\n                // Assuming D behaves similarly to C and B for single request handling\n                if (r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output\n        case (current_state)\n            STATE_B: g[1] = 1; // Grant to device 1\n            STATE_C: g[2] = 1; // Grant to device 2\n            STATE_D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State declaration using parameters\n    parameter A = 3'b000,\n              B = 3'b001,\n              C = 3'b010,\n              D = 3'b011;\n\n    // State and next state variables\n    reg [2:0] state, next_state;\n\n    // Synchronous reset and state transition\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A;  // Reset to state A\n        else\n            state <= next_state;  // State transitions\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case(state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;  // Stay in A if no requests\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;  // Stay in B if request from device 1\n                else\n                    next_state = A;  // Return to A if request from device 1 ceases\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;  // Stay in C if request from device 2\n                else\n                    next_state = A;  // Return to A if request from device 2 ceases\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;  // Stay in D if request from device 3\n                else\n                    next_state = A;  // Return to A if request from device 3 ceases\n            end\n            default: next_state = A;  // Default case to handle undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000;  // Default output\n        case(state)\n            A: g = 3'b000;  // No grants in A\n            B: g[1] = 1;  // Grant to device 1 in state B\n            C: g[2] = 1;  // Grant to device 2 in state C\n            D: g[3] = 1;  // Grant to device 3 in state D\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    localparam [1:0] \n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11;\n\n    // Current state and next state variables\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn) // active low reset\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else if (r[2] == 1)\n                    next_state = C;\n                else if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2] == 1)\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic for grants\n    always @(*) begin\n        g = 3'b000; // Default to no grants\n        case (current_state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011;\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= A; // Synchronous reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else if (r[2] == 1)\n                    next_state = C;\n                else if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2] == 1)\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                // Assuming missing logic for state D transitions based on given problem description\n                // Assuming it behaves similarly to C but for r[3]\n                if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A; // Default case to handle unforeseen states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output is no grants\n        case (current_state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n            default: g = 3'b000; // No grants if in state A or unforeseen state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // Define the states\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B = 2'b01,\n        STATE_C = 2'b10,\n        STATE_D = 2'b11\n    } state_t;\n\n    // State variable declaration\n    reg [1:0] current_state, next_state;\n\n    // State register (synchronous reset)\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(current_state)\n            STATE_A: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else if (r[2])\n                    next_state = STATE_C;\n                else if (!r[2] && !r[1] && r[3])\n                    next_state = STATE_D;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B: begin\n                if (r[1])\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_C: begin\n                if (r[2])\n                    next_state = STATE_C;\n                else\n                    next_state = STATE_A;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(current_state or r) begin\n        g = 3'b000; // default to all grants off\n        case(current_state)\n            STATE_A: g = 3'b000;\n            STATE_B: g[1] = 1;   // Grant to device 1\n            STATE_C: g[2] = 1;   // Grant to device 2\n            STATE_D: g[3] = 1;   // Grant to device 3\n            default: g = 3'b000;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= A; // Synchronous reset\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output\n        case(state)\n            B: g[1] = 1; // Grant to device 1\n            C: g[2] = 1; // Grant to device 2\n            D: g[3] = 1; // Grant to device 3\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    parameter A = 3'b000;\n    parameter B = 3'b001;\n    parameter C = 3'b010;\n    parameter D = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else if (r[2] == 1)\n                    next_state = C;\n                else if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1] == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2] == 1)\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3] == 1)\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g[1] = (current_state == B);\n        g[2] = (current_state == C);\n        g[3] = (current_state == D);\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input [3:1] r,\n    output reg [3:1] g\n);\n\n    // State encoding\n    parameter A = 3'b000,\n              B = 3'b001,\n              C = 3'b010,\n              D = 3'b011;\n\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            A: begin\n                if (r[1])\n                    next_state = B;\n                else if (r[2])\n                    next_state = C;\n                else if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            B: begin\n                if (r[1])\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            C: begin\n                if (r[2])\n                    next_state = C;\n                else\n                    next_state = A;\n            end\n            D: begin\n                if (r[3])\n                    next_state = D;\n                else\n                    next_state = A;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        g = 3'b000; // Default output\n        case (current_state)\n            A: g = 3'b000;\n            B: g[1] = 1;   // Grant to device 1\n            C: g[2] = 1;   // Grant to device 2\n            D: g[3] = 1;   // Grant to device 3\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "count10", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 0;  // Reset the counter to 0 if reset is high\n    else if (q == 9)\n        q <= 0;  // Reset the counter to 0 when it reaches 10\n    else\n        q <= q + 1;  // Increment the counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000;\n        else if (q == 4'b1001)\n            q <= 4'b0000;\n        else\n            q <= q + 1'b1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // Reset the counter to 0 when reset is high\n        else if (q == 4'b1001)\n            q <= 4'b0000; // Roll over to 0 when counter reaches 9\n        else\n            q <= q + 1; // Increment the counter\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000;  // Reset the counter to 0\n    else if (q == 4'b1001)\n        q <= 4'b0000;  // Reset to 0 when counter reaches 9\n    else\n        q <= q + 1;    // Increment the counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000; // Reset the counter to 0\n    else if (q == 4'b1001)\n        q <= 4'b0000; // Reset to 0 when the counter hits 9\n    else\n        q <= q + 1; // Increment the counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd0;\n    else if (q == 4'd9)\n        q <= 4'd0;\n    else\n        q <= q + 1;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0000; // When reset is high, reset counter to 0\n        else if (q == 4'b1001)\n            q <= 4'b0000; // Reset counter when it reaches 9\n        else\n            q <= q + 1; // Increment counter\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'd0;\n        else if (q == 4'd9)\n            q <= 4'd0;\n        else\n            q <= q + 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0000; // Reset the counter to 0\n    else if (q == 4'b1001)\n        q <= 4'b0000; // Reset the counter when it reaches 9\n    else\n        q <= q + 1; // Increment the counter\nend\n\nendmodule\n"]}
{"task_id": "fsm_ps2", "gptgen_RTL": ["module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n    // Define states for the FSM\n    localparam WAIT_FOR_START = 1'b0,\n               RECEIVE_MSG = 1'b1;\n\n    // State variable\n    reg state;\n    reg [1:0] byte_count; // To keep track of the number of bytes received\n\n    // FSM implementation\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_FOR_START;\n            byte_count <= 2'b00;\n            done <= 1'b0;\n        end\n        else begin\n            case (state)\n                WAIT_FOR_START: begin\n                    done <= 1'b0; // Make sure done is low in the waiting state\n                    if (in[3] == 1'b1) begin\n                        // Detected the start of a new message\n                        state <= RECEIVE_MSG;\n                        byte_count <= 2'b01; // First byte received\n                    end\n                end\n                RECEIVE_MSG: begin\n                    if (byte_count == 2'b11) begin\n                        // The third byte has been received\n                        done <= 1'b1;\n                        byte_count <= 2'b00; // Reset byte count\n                        state <= WAIT_FOR_START; // Return to waiting for the next message\n                    end\n                    else begin\n                        done <= 1'b0; // Not done until the third byte is received\n                        byte_count <= byte_count + 2'b01; // Update byte count\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n    // State declaration\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // State variable\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1) \n                    next_state = BYTE1;\n                else \n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            done <= 0;\n        end else begin\n            if (state == BYTE3) \n                done <= 1;\n            else \n                done <= 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // FSM state variable\n    reg [1:0] state, next_state;\n\n    // Synchronous state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                // Transition to BYTE1 if in[3] is 1, indicating start of new message\n                if (in[3])\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                // Second byte of the message\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                // Third byte of the message\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                // Transition back to IDLE to await new message\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic for 'done' signal\n    always @(posedge clk) begin\n        if (reset)\n            done <= 0;\n        else if (state == BYTE3)\n            done <= 1;  // Indicate done when the third byte has been received\n        else\n            done <= 0;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State definition\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // State variable\n    reg [1:0] state, next_state;\n\n    // FSM sequential logic for state transition\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // FSM combinational logic for next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                if (in[3] == 1'b1)\n                    next_state = BYTE1;  // New message starts immediately\n                else\n                    next_state = IDLE;   // Return to IDLE to look for new message start\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            done <= 1'b0;\n        else if (state == BYTE3)\n            done <= 1'b1;\n        else\n            done <= 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State definitions\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            done <= 0;\n        end else if (state == BYTE3) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State encoding\n    localparam IDLE = 2'b00,\n               BYTE1 = 2'b01,\n               BYTE2 = 2'b10,\n               BYTE3 = 2'b11;\n    \n    // State register\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: \n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n\n            BYTE1: \n                next_state = BYTE2;\n\n            BYTE2: \n                next_state = BYTE3;\n\n            BYTE3: \n                next_state = IDLE;\n\n            default: \n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic: done signal\n    always @(posedge clk) begin\n        if (reset)\n            done <= 1'b0;\n        else if (state == BYTE3)\n            done <= 1'b1;\n        else\n            done <= 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State declaration\n    localparam IDLE = 2'b00, BYTE1 = 2'b01, BYTE2 = 2'b10, BYTE3 = 2'b11;\n    reg [1:0] state, next_state;\n\n    // State transitions\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE: begin\n                if (in[3] == 1'b1) begin\n                    next_state = BYTE1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            done <= 1'b0;\n        end else if (state == BYTE3) begin\n            done <= 1'b1;\n        end else begin\n            done <= 1'b0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State declaration\n    localparam IDLE = 0,\n               BYTE1 = 1,\n               BYTE2 = 2,\n               BYTE3 = 3;\n\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            IDLE: begin\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            end\n            BYTE1: begin\n                next_state = BYTE2;\n            end\n            BYTE2: begin\n                next_state = BYTE3;\n            end\n            BYTE3: begin\n                next_state = IDLE;\n            end\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            done <= 0;\n        end else begin\n            if (current_state == BYTE3)\n                done <= 1;\n            else\n                done <= 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n    // State Declaration\n    parameter IDLE = 0, BYTE1 = 1, BYTE2 = 2, BYTE3 = 3;\n    reg [1:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            IDLE:\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            BYTE1:\n                next_state = BYTE2;\n            BYTE2:\n                next_state = BYTE3;\n            BYTE3:\n                if (in[3] == 1)\n                    next_state = BYTE1;\n                else\n                    next_state = IDLE;\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            done <= 0;\n        else if (state == BYTE3)\n            done <= 1;\n        else\n            done <= 0;\n    end\n    \nendmodule\n", "module top_module (\n    input clk,\n    input [7:0] in,\n    input reset,\n    output reg done\n);\n\n    // State definitions\n    reg [1:0] state;\n    localparam WAIT_FIRST_BYTE = 2'b00,\n               BYTE1_RECEIVED = 2'b01,\n               BYTE2_RECEIVED = 2'b10;\n\n    // FSM logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= WAIT_FIRST_BYTE;\n            done <= 1'b0;\n        end\n        else begin\n            case(state)\n                WAIT_FIRST_BYTE: begin\n                    if (in[3]) begin  // Check if the first bit of the byte is 1\n                        state <= BYTE1_RECEIVED;\n                        done <= 1'b0;\n                    end\n                end\n                BYTE1_RECEIVED: begin\n                    state <= BYTE2_RECEIVED;\n                    done <= 1'b0;\n                end\n                BYTE2_RECEIVED: begin\n                    state <= WAIT_FIRST_BYTE;\n                    done <= 1'b1;  // Signal the receipt of a complete message\n                end\n                default: begin\n                    state <= WAIT_FIRST_BYTE;\n                    done <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n"]}
{"task_id": "mux2to1", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\n    assign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input sel,\n    output out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n"]}
{"task_id": "gates4", "gptgen_RTL": ["module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Implementing the 4-input AND gate\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n\n    // Implementing the 4-input OR gate\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n\n    // Implementing the 4-input XOR gate\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\nassign out_and = in[0] & in[1] & in[2] & in[3];\nassign out_or = in[0] | in[1] | in[2] | in[3];\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    // Implementing the 4-input AND gate\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n\n    // Implementing the 4-input OR gate\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n\n    // Implementing the 4-input XOR gate\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n// Implementing the 4-input AND gate\nassign out_and = in[0] & in[1] & in[2] & in[3];\n\n// Implementing the 4-input OR gate\nassign out_or = in[0] | in[1] | in[2] | in[3];\n\n// Implementing the 4-input XOR gate\nassign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output out_and,\n    output out_or,\n    output out_xor\n);\n\n    assign out_and = in[0] & in[1] & in[2] & in[3];\n    assign out_or = in[0] | in[1] | in[2] | in[3];\n    assign out_xor = in[0] ^ in[1] ^ in[2] ^ in[3];\n\nendmodule\n"]}
{"task_id": "2014_q3bfsm", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    reg [2:0] current_state, next_state;\n\n    // State Encoding\n    localparam  S0 = 3'b000,\n                S1 = 3'b001,\n                S2 = 3'b010,\n                S3 = 3'b011,\n                S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0; // Reset to state 000\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] state, next_state;\n\n    // State assignments\n    localparam [2:0] S0 = 3'b000,\n                     S1 = 3'b001,\n                     S2 = 3'b010,\n                     S3 = 3'b011,\n                     S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            S0: next_state = (x == 0) ? S0 : S1;\n            S1: next_state = (x == 0) ? S1 : S4;\n            S2: next_state = (x == 0) ? S2 : S1;\n            S3: next_state = (x == 0) ? S1 : S2;\n            S4: next_state = (x == 0) ? S3 : S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State declaration\n    reg [2:0] current_state, next_state;\n\n    // State encoding\n    localparam  S0 = 3'b000,\n                S1 = 3'b001,\n                S2 = 3'b010,\n                S3 = 3'b011,\n                S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0; // Synchronous reset\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0; // Default case to handle undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0; // Default case to ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // State encoding\n    reg [2:0] current_state, next_state;\n\n    // State declaration\n    localparam S0 = 3'b000;\n    localparam S1 = 3'b001;\n    localparam S2 = 3'b010;\n    localparam S3 = 3'b011;\n    localparam S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0; // Synchronous reset to state S0\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    reg [2:0] current_state, next_state;\n\n    // State encoding\n    localparam S0 = 3'b000;\n    localparam S1 = 3'b001;\n    localparam S2 = 3'b010;\n    localparam S3 = 3'b011;\n    localparam S4 = 3'b100;\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0; // Synchronous reset to state 000\n        else\n            current_state <= next_state;\n    end\n\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                next_state = x ? S1 : S0;\n                z = 0;\n            end\n            S1: begin\n                next_state = x ? S4 : S1;\n                z = 0;\n            end\n            S2: begin\n                next_state = x ? S1 : S2;\n                z = 0;\n            end\n            S3: begin\n                next_state = x ? S2 : S1;\n                z = 1;\n            end\n            S4: begin\n                next_state = x ? S4 : S3;\n                z = 1;\n            end\n            default: begin\n                next_state = S0;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam  S0 = 3'b000,\n                S1 = 3'b001,\n                S2 = 3'b010,\n                S3 = 3'b011,\n                S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (state)\n            S0: next_state = (x == 0) ? S0 : S1;\n            S1: next_state = (x == 0) ? S1 : S4;\n            S2: next_state = (x == 0) ? S2 : S1;\n            S3: next_state = (x == 0) ? S1 : S2;\n            S4: next_state = (x == 0) ? S3 : S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // State declaration\n    reg [2:0] current_state, next_state;\n\n    // State encoding\n    localparam S0 = 3'b000;\n    localparam S1 = 3'b001;\n    localparam S2 = 3'b010;\n    localparam S3 = 3'b011;\n    localparam S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;  // Synchronous reset to state S0\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            S0: next_state = x ? S1 : S0;\n            S1: next_state = x ? S4 : S1;\n            S2: next_state = x ? S1 : S2;\n            S3: next_state = x ? S2 : S1;\n            S4: next_state = x ? S4 : S3;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    // Define state encoding\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam  S0 = 3'b000,\n                S1 = 3'b001,\n                S2 = 3'b010,\n                S3 = 3'b011,\n                S4 = 3'b100;\n\n    // Synchronous reset and state transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= S0; // Reset to state 000\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state and output logic based on current state and input x\n    always @(*) begin\n        case(state)\n            S0: begin\n                if (x == 0) next_state = S0;\n                else next_state = S1;\n                z = 0;\n            end\n            S1: begin\n                if (x == 0) next_state = S1;\n                else next_state = S4;\n                z = 0;\n            end\n            S2: begin\n                if (x == 0) next_state = S2;\n                else next_state = S1;\n                z = 0;\n            end\n            S3: begin\n                if (x == 0) next_state = S1;\n                else next_state = S2;\n                z = 1;\n            end\n            S4: begin\n                if (x == 0) next_state = S3;\n                else next_state = S4;\n                z = 1;\n            end\n            default: begin\n                next_state = S0;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n    // State encoding\n    reg [2:0] current_state, next_state;\n\n    // State definitions\n    localparam S0 = 3'b000;\n    localparam S1 = 3'b001;\n    localparam S2 = 3'b010;\n    localparam S3 = 3'b011;\n    localparam S4 = 3'b100;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            current_state <= S0; // Reset to state 000\n        else \n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input x\n    always @(*) begin\n        case (current_state)\n            S0: next_state = (x == 0) ? S0 : S1;\n            S1: next_state = (x == 0) ? S1 : S4;\n            S2: next_state = (x == 0) ? S2 : S1;\n            S3: next_state = (x == 0) ? S1 : S2;\n            S4: next_state = (x == 0) ? S3 : S4;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S0: z = 0;\n            S1: z = 0;\n            S2: z = 0;\n            S3: z = 1;\n            S4: z = 1;\n            default: z = 0;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input x,\n    output reg z\n);\n\n    reg [2:0] current_state, next_state;\n\n    // State Encoding\n    localparam  S0 = 3'b000,\n                S1 = 3'b001,\n                S2 = 3'b010,\n                S3 = 3'b011,\n                S4 = 3'b100;\n\n    // Next state logic and output logic\n    always @(current_state or x) begin\n        case (current_state)\n            S0: begin\n                next_state = x ? S1 : S0;\n                z = 0;\n            end\n            S1: begin\n                next_state = x ? S4 : S1;\n                z = 0;\n            end\n            S2: begin\n                next_state = x ? S1 : S2;\n                z = 0;\n            end\n            S3: begin\n                next_state = x ? S2 : S1;\n                z = 1;\n            end\n            S4: begin\n                next_state = x ? S4 : S3;\n                z = 1;\n            end\n            default: begin\n                next_state = S0;\n                z = 0;\n            end\n        endcase\n    end\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S0;\n        else\n            current_state <= next_state;\n    end\n\nendmodule\n"]}
{"task_id": "2013_q2bfsm", "gptgen_RTL": ["module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // Define the states\n    localparam STATE_A = 3'b000,\n               STATE_F_ON = 3'b001,\n               STATE_MONITOR_X = 3'b010,\n               STATE_G_ON = 3'b011,\n               STATE_MONITOR_Y = 3'b100,\n               STATE_G_PERMANENT = 3'b101,\n               STATE_G_OFF = 3'b110;\n\n    // State register\n    reg [2:0] current_state, next_state;\n\n    // Registers to monitor the sequence of x and the count of y\n    reg [2:0] x_history;\n    reg [1:0] y_count;\n\n    // State transition logic\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_F_ON;\n            end\n            STATE_F_ON: begin\n                next_state = STATE_MONITOR_X;\n            end\n            STATE_MONITOR_X: begin\n                if (x_history == 3'b101)\n                    next_state = STATE_G_ON;\n                else\n                    next_state = STATE_MONITOR_X;\n            end\n            STATE_G_ON: begin\n                next_state = STATE_MONITOR_Y;\n            end\n            STATE_MONITOR_Y: begin\n                if (y_count >= 2)\n                    next_state = STATE_G_OFF;\n                else if (y == 1)\n                    next_state = STATE_G_PERMANENT;\n                else\n                    next_state = STATE_MONITOR_Y;\n            end\n            STATE_G_PERMANENT: begin\n                next_state = STATE_G_PERMANENT;\n            end\n            STATE_G_OFF: begin\n                next_state = STATE_G_OFF;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        end\n    end\n\n    // Output logic and history/count tracking\n    always @(posedge clk or negedge resetn) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n            x_history <= 3'b000;\n            y_count <= 0;\n        end\n        else begin\n            case (current_state)\n                STATE_F_ON: begin\n                    f <= 1;\n                end\n                STATE_MONITOR_X: begin\n                    f <= 0;\n                    x_history <= {x_history[1:0], x};\n                end\n                STATE_G_ON: begin\n                    g <= 1;\n                    y_count <= 0; // Reset y count on entering this state\n                end\n                STATE_MONITOR_Y: begin\n                    y_count <= y_count + 1;\n                end\n                STATE_G_PERMANENT: begin\n                    g <= 1;\n                end\n                STATE_G_OFF: begin\n                    g <= 0;\n                end\n                default: begin\n                    f <= 0;\n                    g <= 0;\n                    x_history <= 3'b000;\n                    y_count <= 0;\n                end\n            end\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // Define the states\n    typedef enum int {\n        STATE_A,        // Initial state\n        STATE_F_HIGH,   // State where f is set high for one cycle\n        STATE_MONITOR_X, // Monitoring x for the sequence 1, 0, 1\n        STATE_G_HIGH,   // g is set high\n        STATE_MONITOR_Y, // Monitoring y for at most two cycles\n        STATE_G_PERMANENT // g is set permanently high\n    } state_t;\n\n    // FSM state variable\n    reg [2:0] current_state, next_state;\n\n    // Variables to track the sequence for X and Y\n    reg [2:0] x_sequence;\n    reg [1:0] y_count;\n\n    // State register\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_F_HIGH;\n            end\n            STATE_F_HIGH: begin\n                next_state = STATE_MONITOR_X;\n            end\n            STATE_MONITOR_X: begin\n                if (x_sequence == 3'b101)\n                    next_state = STATE_G_HIGH;\n                else\n                    next_state = STATE_MONITOR_X;\n            end\n            STATE_G_HIGH: begin\n                next_state = STATE_MONITOR_Y;\n            end\n            STATE_MONITOR_Y: begin\n                if (y_count >= 2 && y == 0)\n                    next_state = STATE_A; // Reset to STATE_A or any other final state\n                else if (y == 1)\n                    next_state = STATE_G_PERMANENT;\n                else\n                    next_state = STATE_MONITOR_Y;\n            end\n            STATE_G_PERMANENT: begin\n                next_state = STATE_G_PERMANENT;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n            x_sequence <= 0;\n            y_count <= 0;\n        end else begin\n            case (current_state)\n                STATE_F_HIGH: begin\n                    f <= 1;\n                end\n                STATE_MONITOR_X: begin\n                    f <= 0;\n                    x_sequence <= {x_sequence[1:0], x}; // Shift register logic\n                end\n                STATE_G_HIGH: begin\n                    g <= 1;\n                    y_count <= 0; // Reset y counter in this state\n                end\n                STATE_MONITOR_Y: begin\n                    y_count <= y_count + 1;\n                end\n                STATE_G_PERMANENT: begin\n                    g <= 1;\n                end\n                default: begin\n                    f <= 0;\n                    g <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State Declaration\n    typedef enum int {\n        STATE_A,         // Initial state\n        STATE_F_SET,     // State where f is set to 1\n        X_MONITOR,       // Monitor x for sequence 1, 0, 1\n        G_SET,           // Set g to 1\n        Y_MONITOR,       // Monitor y for the value 1 within two cycles\n        G_MAINTAIN,      // Maintain g = 1 permanently\n        G_RESET          // Reset g to 0 permanently\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Registers to track input patterns and counts\n    reg [2:0] x_sequence; // To track the last three values of x\n    reg [1:0] y_count;    // To count y values after setting g\n\n    // State transition and output logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            current_state <= STATE_A;\n            x_sequence <= 3'b000;\n            y_count <= 2'b00;\n        end else begin\n            current_state <= next_state;\n            if (current_state == X_MONITOR) begin\n                x_sequence <= {x_sequence[1:0], x}; // Shift register for x input sequence\n            end\n            if (current_state == Y_MONITOR) begin\n                y_count <= y_count + 1'b1; // Increment y counter\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_F_SET;\n            end\n            STATE_F_SET: begin\n                next_state = X_MONITOR;\n            end\n            X_MONITOR: begin\n                if (x_sequence == 3'b101) begin\n                    next_state = G_SET;\n                end else begin\n                    next_state = X_MONITOR;\n                end\n            end\n            G_SET: begin\n                next_state = Y_MONITOR;\n            end\n            Y_MONITOR: begin\n                if (y == 1 || y_count >= 2) begin\n                    next_state = (y == 1) ? G_MAINTAIN : G_RESET;\n                end else begin\n                    next_state = Y_MONITOR;\n                end\n            end\n            G_MAINTAIN: begin\n                next_state = G_MAINTAIN;\n            end\n            G_RESET: begin\n                next_state = G_RESET;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        case (current_state)\n            STATE_F_SET: begin\n                f <= 1;\n            end\n            X_MONITOR: begin\n                f <= 0;\n            end\n            G_SET: begin\n                g <= 1;\n            end\n            Y_MONITOR: begin\n                g <= 1;\n            end\n            G_MAINTAIN: begin\n                g <= 1;\n            end\n            G_RESET: begin\n                g <= 0;\n            end\n            default: begin\n                f <= 0;\n                g <= 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State Declaration\n    typedef enum reg[2:0] {\n        STATE_A,\n        STATE_F_HIGH,\n        STATE_X1,\n        STATE_X0,\n        STATE_X1_AGAIN,\n        STATE_G_HIGH,\n        STATE_Y_CHECK,\n        STATE_Y_WAIT,\n        STATE_G_PERMANENT\n    } state_type;\n\n    // State Register\n    state_type state, next_state;\n\n    // Sequential Logic for State Transition\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    // Combinational Logic for Next State Logic and Output Logic\n    always @(*) begin\n        // Defaults\n        f = 0;\n        g = 0;\n        next_state = state;\n\n        case (state)\n            STATE_A: begin\n                next_state = STATE_F_HIGH;\n            end\n            STATE_F_HIGH: begin\n                f = 1;\n                next_state = STATE_X1;\n            end\n            STATE_X1: begin\n                if (x == 1)\n                    next_state = STATE_X0;\n            end\n            STATE_X0: begin\n                if (x == 0)\n                    next_state = STATE_X1_AGAIN;\n            end\n            STATE_X1_AGAIN: begin\n                if (x == 1)\n                    next_state = STATE_G_HIGH;\n            end\n            STATE_G_HIGH: begin\n                g = 1;\n                next_state = STATE_Y_CHECK;\n            end\n            STATE_Y_CHECK: begin\n                g = 1;\n                if (y == 1)\n                    next_state = STATE_G_PERMANENT;\n                else\n                    next_state = STATE_Y_WAIT;\n            end\n            STATE_Y_WAIT: begin\n                g = 1;\n                if (y == 1)\n                    next_state = STATE_G_PERMANENT;\n                else\n                    next_state = STATE_G_LOW;\n            end\n            STATE_G_PERMANENT: begin\n                g = 1;\n            end\n            STATE_G_LOW: begin\n                g = 0;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State Declaration\n    typedef enum {STATE_A, STATE_F, MONITOR_X1, MONITOR_X2, MONITOR_X3, MONITOR_Y1, MONITOR_Y2, G_PERMANENT} state_t;\n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = STATE_F;\n            STATE_F: begin\n                f = 1;\n                next_state = MONITOR_X1;\n            end\n            MONITOR_X1: next_state = (x == 1) ? MONITOR_X2 : MONITOR_X1;\n            MONITOR_X2: next_state = (x == 0) ? MONITOR_X3 : MONITOR_X1;\n            MONITOR_X3: next_state = (x == 1) ? MONITOR_Y1 : MONITOR_X1;\n            MONITOR_Y1: begin\n                g = 1;\n                next_state = (y == 1) ? G_PERMANENT : MONITOR_Y2;\n            end\n            MONITOR_Y2: next_state = (y == 1) ? G_PERMANENT : STATE_A;\n            G_PERMANENT: begin\n                g = 1;\n                next_state = G_PERMANENT;\n            end\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output Logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end\n        else begin\n            case (current_state)\n                STATE_F: f <= 1;\n                MONITOR_X1: f <= 0;\n                MONITOR_X2: f <= 0;\n                MONITOR_X3: f <= 0;\n                MONITOR_Y1: f <= 0;\n                MONITOR_Y2: f <= 0;\n                G_PERMANENT: f <= 0;\n                default: begin\n                    f <= 0;\n                    g <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum int {\n        STATE_A,    // Initial state\n        STATE_F,    // State where f is set to 1\n        X_FIRST,    // Waiting for the first 1 in x sequence\n        X_SECOND,   // Waiting for 0 in x sequence\n        X_THIRD,    // Waiting for the second 1 in x sequence\n        Y_WAIT1,    // First cycle of waiting for y to be 1\n        Y_WAIT2,    // Second cycle of waiting for y to be 1\n        G_ON,       // g is permanently 1\n        G_OFF       // g is permanently 0\n    } state_t;\n\n    // State registers\n    state_t state_reg = STATE_A, state_next;\n\n    // Sequential logic for state transition\n    always @(posedge clk) begin\n        if (!resetn)\n            state_reg <= STATE_A;\n        else\n            state_reg <= state_next;\n    end\n\n    // Combinatorial logic for next state\n    always @(*) begin\n        state_next = state_reg; // Default state: stay in the current state\n        case (state_reg)\n            STATE_A: begin\n                state_next = STATE_F;\n            end\n            STATE_F: begin\n                state_next = X_FIRST;\n            end\n            X_FIRST: begin\n                if (x == 1)\n                    state_next = X_SECOND;\n            end\n            X_SECOND: begin\n                if (x == 0)\n                    state_next = X_THIRD;\n            end\n            X_THIRD: begin\n                if (x == 1)\n                    state_next = Y_WAIT1;\n            end\n            Y_WAIT1: begin\n                if (y == 1)\n                    state_next = G_ON;\n                else\n                    state_next = Y_WAIT2;\n            end\n            Y_WAIT2: begin\n                if (y == 1)\n                    state_next = G_ON;\n                else\n                    state_next = G_OFF;\n            end\n            G_ON: begin\n                state_next = G_ON; // Maintain this state\n            end\n            G_OFF: begin\n                state_next = G_OFF; // Maintain this state\n            end\n            default: begin\n                state_next = STATE_A;\n            end\n        endcase\n    end\n\n    // Combinatorial logic for outputs\n    always @(*) begin\n        f = 0;\n        g = 0;\n        case (state_reg)\n            STATE_F: begin\n                f = 1;\n            end\n            G_ON: begin\n                g = 1;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // Define states\n    typedef enum {\n        STATE_A, STATE_B, STATE_X0, STATE_X1, STATE_X0_X1, STATE_G1, STATE_G1_Y1, STATE_G1_Y0\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_B;\n            end\n            STATE_B: begin\n                next_state = (x == 1) ? STATE_X0 : STATE_B;\n            end\n            STATE_X0: begin\n                next_state = (x == 0) ? STATE_X1 : STATE_B;\n            end\n            STATE_X1: begin\n                next_state = (x == 1) ? STATE_X0_X1 : STATE_B;\n            end\n            STATE_X0_X1: begin\n                next_state = STATE_G1;\n            end\n            STATE_G1: begin\n                if (y == 1)\n                    next_state = STATE_G1_Y1;\n                else\n                    next_state = STATE_G1_Y0;\n            end\n            STATE_G1_Y1: begin\n                next_state = STATE_G1_Y1;\n            end\n            STATE_G1_Y0: begin\n                next_state = (y == 1) ? STATE_G1_Y1 : STATE_G1_Y0;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (!resetn) begin\n            f <= 0;\n            g <= 0;\n        end else begin\n            case (current_state)\n                STATE_A: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_B: begin\n                    f <= 1;\n                    g <= 0;\n                end\n                STATE_X0: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_X1: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_X0_X1: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                STATE_G1: begin\n                    f <= 0;\n                    g <= 1;\n                end\n                STATE_G1_Y1: begin\n                    f <= 0;\n                    g <= 1;\n                end\n                STATE_G1_Y0: begin\n                    f <= 0;\n                    g <= 0;\n                end\n                default: begin\n                    f <= 0;\n                    g <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State definition\n    typedef enum logic [2:0] {\n        STATE_A,        // Initial state\n        STATE_F,        // State where f is set to 1\n        STATE_X0,       // 1st state in x sequence (expecting x to be 1)\n        STATE_X1,       // 2nd state in x sequence (expecting x to be 0)\n        STATE_X2,       // 3rd state in x sequence (expecting x to be 1)\n        STATE_G,        // State where g is set to 1\n        STATE_Y0,       // 1st state in y sequence (checking y)\n        STATE_Y1,       // 2nd state in y sequence (checking y)\n        STATE_GPERM     // Permanent state where g remains 1\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // State transitions and output logic\n    always_ff @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        // Default outputs\n        f = 0;\n        g = 0;\n\n        // Default next state\n        next_state = current_state;\n\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_F;\n            end\n            STATE_F: begin\n                f = 1;  // Output f set for one cycle\n                next_state = STATE_X0;\n            end\n            STATE_X0: begin\n                if (x == 1)\n                    next_state = STATE_X1;\n            end\n            STATE_X1: begin\n                if (x == 0)\n                    next_state = STATE_X2;\n            end\n            STATE_X2: begin\n                if (x == 1)\n                    next_state = STATE_G;\n            end\n            STATE_G: begin\n                g = 1;  // Output g set\n                next_state = STATE_Y0;\n            end\n            STATE_Y0: begin\n                g = 1;  // Maintain g\n                if (y == 1)\n                    next_state = STATE_GPERM;\n                else\n                    next_state = STATE_Y1;\n            end\n            STATE_Y1: begin\n                g = 1;  // Maintain g\n                if (y == 1)\n                    next_state = STATE_GPERM;\n                else\n                    next_state = STATE_G;\n            end\n            STATE_GPERM: begin\n                g = 1;  // g is permanently set\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // State encoding\n    typedef enum {\n        STATE_A,         // Initial state\n        STATE_B,         // Output f = 1 for one cycle after reset de-asserted\n        STATE_WAIT_X_0,  // Waiting for x to be 1,0,1 sequence\n        STATE_WAIT_X_1,\n        STATE_WAIT_X_2,\n        STATE_G_SET,     // g set to 1, wait for y value\n        STATE_Y_CHECK,   // Check y value\n        STATE_FINAL      // Final state where g is either maintained at 1 or set to 0\n    } state_t;\n\n    // State registers\n    reg [2:0] current_state, next_state;\n\n    // FSM Sequential block\n    always @(posedge clk) begin\n        if (!resetn)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // FSM Next State Logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                next_state = STATE_B;\n            end\n            STATE_B: begin\n                next_state = STATE_WAIT_X_0;\n            end\n            STATE_WAIT_X_0: begin\n                next_state = (x == 1) ? STATE_WAIT_X_1 : STATE_WAIT_X_0;\n            end\n            STATE_WAIT_X_1: begin\n                next_state = (x == 0) ? STATE_WAIT_X_2 : STATE_WAIT_X_0;\n            end\n            STATE_WAIT_X_2: begin\n                next_state = (x == 1) ? STATE_G_SET : STATE_WAIT_X_0;\n            end\n            STATE_G_SET: begin\n                next_state = STATE_Y_CHECK;\n            end\n            STATE_Y_CHECK: begin\n                next_state = (y == 1) ? STATE_FINAL : STATE_Y_CHECK;\n            end\n            STATE_FINAL: begin\n                next_state = STATE_FINAL;\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // FSM Output Logic\n    always @(*) begin\n        // Default output values\n        f = 0;\n        g = 0;\n\n        case (current_state)\n            STATE_B: begin\n                f = 1;\n            end\n            STATE_G_SET: begin\n                g = 1;\n            end\n            STATE_Y_CHECK: begin\n                g = 1;  // g remains 1 until a decision is made in STATE_FINAL\n            end\n            STATE_FINAL: begin\n                g = 1;  // g is maintained at 1\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input x,\n    input y,\n    output reg f,\n    output reg g\n);\n\n    // Define states\n    typedef enum {STATE_A, STATE_F, MONITOR_X0, MONITOR_X1, MONITOR_X2, MONITOR_Y0, MONITOR_Y1, MONITOR_Y2, G_SET, G_RESET} state_t;\n\n    // State variable\n    reg [3:0] state, next_state;\n\n    // Sequential logic for state transitioning\n    always @(posedge clk) begin\n        if (!resetn)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    // Combinational logic for next state logic and outputs\n    always @(*) begin\n        // Default outputs\n        f = 0;\n        g = 0;\n        next_state = state;\n        \n        case (state)\n            STATE_A: begin\n                next_state = STATE_F;\n            end\n\n            STATE_F: begin\n                f = 1;  // Output f is set to 1 for one clock cycle\n                next_state = MONITOR_X0;\n            end\n\n            MONITOR_X0: begin\n                if (x == 1)\n                    next_state = MONITOR_X1;\n            end\n\n            MONITOR_X1: begin\n                if (x == 0)\n                    next_state = MONITOR_X2;\n            end\n\n            MONITOR_X2: begin\n                if (x == 1)\n                    next_state = MONITOR_Y0;\n            end\n\n            MONITOR_Y0: begin\n                g = 1;\n                if (y == 1)\n                    next_state = G_SET;\n                else\n                    next_state = MONITOR_Y1;\n            end\n\n            MONITOR_Y1: begin\n                g = 1;\n                if (y == 1)\n                    next_state = G_SET;\n                else\n                    next_state = MONITOR_Y2;\n            end\n\n            MONITOR_Y2: begin\n                g = 1;\n                if (y == 1)\n                    next_state = G_SET;\n                else\n                    next_state = G_RESET;\n            end\n\n            G_SET: begin\n                g = 1;  // Maintain g = 1 permanently\n            end\n\n            G_RESET: begin\n                g = 0;  // Set g = 0 permanently\n            end\n\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "dff8p", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34; // Reset q to 0x34 on reset active high\n    else\n        q <= d; // Transfer input d to output q on falling edge of clk\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\n    always @(negedge clk) begin\n        if (reset)\n            q <= 8'h34;  // Reset value of 0x34\n        else\n            q <= d;      // Load input data into flip-flops\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34; // Set q to hexadecimal 34 on reset\n    else\n        q <= d; // Transfer input d to output q on negative clock edge\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;  // Reset value of 0x34\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset) begin\n        q <= 8'h34;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34; // Set q to hexadecimal 34 when reset is active high\n    else\n        q <= d; // Load d into q on negative clock edge when reset is not active\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset) \n        q <= 8'h34;  // Reset q to hex 34\n    else\n        q <= d;      // Load input d into q\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input reset,\n    output reg [7:0] q\n);\n\nalways @(negedge clk) begin\n    if (reset)\n        q <= 8'h34; // Reset value is 0x34\n    else\n        q <= d; // Load new data into the flip-flops on clock edge\nend\n\nendmodule\n"]}
{"task_id": "reduction", "gptgen_RTL": ["module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n    assign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n// Compute even parity by XORing all bits of the input byte\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n// XOR all bits to get the even parity bit\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output parity\n);\n\n// Even parity bit calculation using XOR\nassign parity = in[0] ^ in[1] ^ in[2] ^ in[3] ^ in[4] ^ in[5] ^ in[6] ^ in[7];\n\nendmodule\n"]}
{"task_id": "fsm3comb", "gptgen_RTL": ["module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Define state encoding\n    localparam [1:0] A = 2'b00,\n                     B = 2'b01,\n                     C = 2'b10,\n                     D = 2'b11;\n\n    // Output logic\n    assign out = (state == D);\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 2'bxx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                if (in == 0) next_state = 2'b00; // Stay in A\n                else next_state = 2'b01; // Go to B\n                out = 0;\n            end\n            2'b01: begin // State B\n                if (in == 0) next_state = 2'b10; // Go to C\n                else next_state = 2'b01; // Stay in B\n                out = 0;\n            end\n            2'b10: begin // State C\n                if (in == 0) next_state = 2'b00; // Go to A\n                else next_state = 2'b11; // Go to D\n                out = 0;\n            end\n            2'b11: begin // State D\n                if (in == 0) next_state = 2'b10; // Go to C\n                else next_state = 2'b01; // Go to B\n                out = 1;\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        case(state)\n            2'b00: begin // State A\n                next_state = in ? 2'b01 : 2'b00; // Next state transitions for A\n                out = 1'b0; // Output for state A\n            end\n            2'b01: begin // State B\n                next_state = in ? 2'b01 : 2'b10; // Next state transitions for B\n                out = 1'b0; // Output for state B\n            end\n            2'b10: begin // State C\n                next_state = in ? 2'b11 : 2'b00; // Next state transitions for C\n                out = 1'b0; // Output for state C\n            end\n            2'b11: begin // State D\n                next_state = in ? 2'b01 : 2'b10; // Next state transitions for D\n                out = 1'b1; // Output for state D\n            end\n            default: begin // Default case for safety\n                next_state = 2'b00;\n                out = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        case(state)\n            2'b00: begin // State A\n                if (in == 0) next_state = 2'b00; // Stay in A\n                else next_state = 2'b01; // Move to B\n                out = 0;\n            end\n            2'b01: begin // State B\n                if (in == 0) next_state = 2'b10; // Move to C\n                else next_state = 2'b01; // Stay in B\n                out = 0;\n            end\n            2'b10: begin // State C\n                if (in == 0) next_state = 2'b00; // Move to A\n                else next_state = 2'b11; // Move to D\n                out = 0;\n            end\n            2'b11: begin // State D\n                if (in == 0) next_state = 2'b10; // Move to C\n                else next_state = 2'b01; // Move to B\n                out = 1;\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A if state is undefined\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n    \n    // Assigning output based on current state\n    assign out = (state == 2'b11); // Output is 1 only when state is D (2'b11)\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            2'b00: // State A\n                next_state = in ? 2'b01 : 2'b00; // If in is 1, go to B, else stay in A\n            2'b01: // State B\n                next_state = in ? 2'b01 : 2'b10; // If in is 1, stay in B, else go to C\n            2'b10: // State C\n                next_state = in ? 2'b11 : 2'b00; // If in is 1, go to D, else go to A\n            2'b11: // State D\n                next_state = in ? 2'b01 : 2'b10; // If in is 1, go to B, else go to C\n            default: \n                next_state = 2'b00; // Default case to handle unknown state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: begin // State A\n                next_state = in ? 2'b01 : 2'b00; // If in = 1, go to B, else stay in A\n                out = 0;\n            end\n            2'b01: begin // State B\n                next_state = in ? 2'b01 : 2'b10; // If in = 1, stay in B, else go to C\n                out = 0;\n            end\n            2'b10: begin // State C\n                next_state = in ? 2'b11 : 2'b00; // If in = 1, go to D, else go to A\n                out = 0;\n            end\n            2'b11: begin // State D\n                next_state = in ? 2'b01 : 2'b10; // If in = 1, go to B, else go to C\n                out = 1;\n            end\n            default: begin\n                next_state = 2'b00; // Default to state A\n                out = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Define the states as parameters for better readability\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // Combinational logic to determine next state and output\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = B;\n            end\n            B: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n            end\n            C: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = D;\n            end\n            D: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n            end\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Combinational logic for output based on current state\n    assign out = (state == D); // Output is 1 only when state is D\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Output logic for Moore Machine\n    assign out = (state == 2'b11) ? 1'b1 : 1'b0;\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            2'b00: next_state = (in == 1'b0) ? 2'b00 : 2'b01; // State A transitions\n            2'b01: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State B transitions\n            2'b10: next_state = (in == 1'b0) ? 2'b00 : 2'b11; // State C transitions\n            2'b11: next_state = (in == 1'b0) ? 2'b10 : 2'b01; // State D transitions\n            default: next_state = 2'b00; // Default case to handle any undefined states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Define output based on current state\n    assign out = (state == 2'b11); // Output is 1 only when state is D (2'b11)\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (state)\n            2'b00: next_state = in ? 2'b01 : 2'b00; // State A transitions to B if in=1, otherwise stays in A\n            2'b01: next_state = in ? 2'b01 : 2'b10; // State B transitions to B if in=1, otherwise C\n            2'b10: next_state = in ? 2'b11 : 2'b00; // State C transitions to D if in=1, otherwise A\n            2'b11: next_state = in ? 2'b01 : 2'b10; // State D transitions to B if in=1, otherwise C\n            default: next_state = 2'b00; // Default case to handle undefined states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [1:0] state,\n    output reg [1:0] next_state,\n    output out\n);\n\n    // Define state codes\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    // Output logic based on current state\n    assign out = (state == D) ? 1'b1 : 1'b0;\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case(state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = 2'bxx; // Undefined state\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "mt2015_q4b", "gptgen_RTL": ["module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n    always @(*) begin\n        if (x & y) begin\n            z = 1;\n        end else if (x) begin\n            z = 0;\n        end else if (y) begin\n            z = 0;\n        end else begin\n            z = 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if ((x == 0) && (y == 0))\n        z = 1;\n    else if ((x == 1) && (y == 0))\n        z = 0;\n    else if ((x == 0) && (y == 1))\n        z = 0;\n    else if ((x == 1) && (y == 1))\n        z = 1;\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if (x && y) begin\n        z = 1; // z is 1 when both x and y are 1.\n    end else if (!x && y) begin\n        z = 0; // z is 0 when x is 0 and y is 1.\n    end else if (x && !y) begin\n        z = 0; // z is 0 when x is 1 and y is 0.\n    end else begin\n        z = 1; // z is 1 when both x and y are 0.\n    end\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if (x && y)\n        z = 1;\n    else if (!x && !y)\n        z = 1;\n    else\n        z = 0;\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if ((x == 0 && y == 0) || (x == 1 && y == 1))\n        z = 1;\n    else\n        z = 0;\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n    // Define the behavior of z based on the values of x and y\n    always @(*) begin\n        if (x && y) begin\n            z = 1;  // When both x and y are 1, z should be 1\n        end else if (!x && !y) begin\n            z = 1;  // When both x and y are 0, z should also be 1\n        end else begin\n            z = 0;  // In all other cases, z should be 0\n        end\n    end\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\nalways @(*) begin\n    if ((x == 0 && y == 0) || (x == 1 && y == 1))\n        z = 1;\n    else\n        z = 0;\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n    always @(x or y) begin\n        if (x && y) begin\n            z = 1;\n        end\n        else if (!x && !y) begin\n            z = 1;\n        end\n        else begin\n            z = 0;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n// Logic for output z based on truth table derived from the simulation waveform\nalways @(x, y) begin\n    if (x == 0 && y == 0) begin\n        z <= 1;  // z is 1 when both x and y are 0\n    end\n    else if (x == 1 && y == 0) begin\n        z <= 0;  // z is 0 when x is 1 and y is 0\n    end\n    else if (x == 0 && y == 1) begin\n        z <= 0;  // z is 0 when x is 0 and y is 1\n    end\n    else if (x == 1 && y == 1) begin\n        z <= 1;  // z is 1 when both x and y are 1\n    end\nend\n\nendmodule\n", "module top_module(\n    input x,\n    input y,\n    output reg z\n);\n\n// According to the waveform, z should be 1 when x=0, y=0 or x=y=1, otherwise z should be 0.\nalways @(*) begin\n    if ((x == 0 && y == 0) || (x == 1 && y == 1)) begin\n        z = 1;\n    end else begin\n        z = 0;\n    end\nend\n\nendmodule\n"]}
{"task_id": "2012_q2fsm", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State declaration using parameters\n    parameter A = 3'b000, \n              B = 3'b001, \n              C = 3'b010, \n              D = 3'b011,\n              E = 3'b100, \n              F = 3'b101;\n\n    // Current state and next state variables\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A; // Default case to handle undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State declaration using parameters\n    parameter A = 3'b000,\n              B = 3'b001,\n              C = 3'b010,\n              D = 3'b011,\n              E = 3'b100,\n              F = 3'b101;\n\n    // State variable\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= A; // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State declaration using parameters\n    parameter A = 3'b000, B = 3'b001, C = 3'b010, D = 3'b011, E = 3'b100, F = 3'b101;\n    reg [2:0] state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) \n            state <= A;  // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;  // Default case to catch any undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            E: z = 1;  // E produces an output of 1\n            F: z = 1;  // F produces an output of 1\n            default: z = 0;  // All other states produce an output of 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State Declaration\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_E = 3'b100,\n        STATE_F = 3'b101\n    } state_t;\n\n    // Current and Next state variable\n    reg [2:0] current_state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = w ? STATE_B : STATE_A;\n            STATE_B: next_state = w ? STATE_C : STATE_D;\n            STATE_C: next_state = w ? STATE_E : STATE_D;\n            STATE_D: next_state = w ? STATE_F : STATE_A;\n            STATE_E: next_state = w ? STATE_E : STATE_D;\n            STATE_F: next_state = w ? STATE_C : STATE_D;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            STATE_E: z = 1;\n            STATE_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State Encoding\n    parameter A = 3'b000,\n              B = 3'b001,\n              C = 3'b010,\n              D = 3'b011,\n              E = 3'b100,\n              F = 3'b101;\n\n    // State variable and next state variable\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input w\n    always @(*) begin\n        case(current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case(current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State declaration\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B = 3'b001,\n        STATE_C = 3'b010,\n        STATE_D = 3'b011,\n        STATE_E = 3'b100,\n        STATE_F = 3'b101\n    } state_t;\n\n    // Current and next state signal declarations\n    reg [2:0] current_state, next_state;\n\n    // State register process with synchronous reset\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= STATE_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: next_state = w ? STATE_B : STATE_A;\n            STATE_B: next_state = w ? STATE_C : STATE_D;\n            STATE_C: next_state = w ? STATE_E : STATE_D;\n            STATE_D: next_state = w ? STATE_F : STATE_A;\n            STATE_E: next_state = w ? STATE_E : STATE_D;\n            STATE_F: next_state = w ? STATE_C : STATE_D;\n            default: next_state = STATE_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: z = 0;\n            STATE_B: z = 0;\n            STATE_C: z = 0;\n            STATE_D: z = 0;\n            STATE_E: z = 1;\n            STATE_F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // Current and next state declaration\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A;  // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input w\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;  // Default case to handle any illegal states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;  // State E has output 1\n            F: z = 1;  // State F has output 1\n            default: z = 0;  // All other states have output 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    typedef enum reg [2:0] {\n        S_A = 3'b000,\n        S_B = 3'b001,\n        S_C = 3'b010,\n        S_D = 3'b011,\n        S_E = 3'b100,\n        S_F = 3'b101\n    } state_t;\n\n    // Current and next state declaration\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= S_A;\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            S_A: next_state = (w) ? S_B : S_A;\n            S_B: next_state = (w) ? S_C : S_D;\n            S_C: next_state = (w) ? S_E : S_D;\n            S_D: next_state = (w) ? S_F : S_A;\n            S_E: next_state = (w) ? S_E : S_D;\n            S_F: next_state = (w) ? S_C : S_D;\n            default: next_state = S_A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            S_E: z = 1'b1;\n            S_F: z = 1'b1;\n            default: z = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // Define state encoding\n    typedef enum reg [2:0] {\n        S_A = 3'b000,\n        S_B = 3'b001,\n        S_C = 3'b010,\n        S_D = 3'b011,\n        S_E = 3'b100,\n        S_F = 3'b101\n    } state_t;\n\n    // State and next state variables\n    reg [2:0] state, next_state;\n\n    // Synchronous state transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S_A;  // Reset to state A\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on the current state and input w\n    always @(*) begin\n        case (state)\n            S_A: next_state = w ? S_B : S_A;\n            S_B: next_state = w ? S_C : S_D;\n            S_C: next_state = w ? S_E : S_D;\n            S_D: next_state = w ? S_F : S_A;\n            S_E: next_state = w ? S_E : S_D;\n            S_F: next_state = w ? S_C : S_D;\n            default: next_state = S_A;  // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        // z is 1 in states E and F, 0 otherwise\n        z = (state == S_E || state == S_F) ? 1'b1 : 1'b0;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input w,\n    output reg z\n);\n\n    // State Declaration\n    typedef enum reg [2:0] {\n        A = 3'b000,\n        B = 3'b001,\n        C = 3'b010,\n        D = 3'b011,\n        E = 3'b100,\n        F = 3'b101\n    } state_t;\n\n    // Register to hold the current state and next state\n    reg [2:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            current_state <= A;  // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input w\n    always @(*) begin\n        case (current_state)\n            A: next_state = w ? B : A;\n            B: next_state = w ? C : D;\n            C: next_state = w ? E : D;\n            D: next_state = w ? F : A;\n            E: next_state = w ? E : D;\n            F: next_state = w ? C : D;\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            E: z = 1;\n            F: z = 1;\n            default: z = 0;\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "dff16e", "gptgen_RTL": ["module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'h0; // Synchronous reset to 0\n    end else begin\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8]; // Load upper byte\n        end\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];  // Load lower byte\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            q <= 16'b0;\n        end else begin\n            if (byteena[0]) begin\n                q[7:0] <= d[7:0];\n            end\n            if (byteena[1]) begin\n                q[15:8] <= d[15:8];\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'd0;\n    end\n    else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input resetn,\n    input [1:0] byteena,\n    input [15:0] d,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        q <= 16'b0;\n    end else begin\n        if (byteena[0]) begin\n            q[7:0] <= d[7:0];\n        end\n        if (byteena[1]) begin\n            q[15:8] <= d[15:8];\n        end\n    end\nend\n\nendmodule\n"]}
{"task_id": "edgedetect", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // Intermediate register to hold the previous state\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Update the pedge output based on the previous and current input\n        pedge <= (in & ~prev_in);  // Detecting rising edge\n        prev_in <= in;             // Storing current input for next cycle comparison\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    // Register to hold the previous state of the input\n    reg [7:0] prev_in;\n\n    // On every positive edge of the clock\n    always @(posedge clk) begin\n        // Loop through each bit to detect 0-to-1 transitions\n        integer i;\n        for(i = 0; i < 8; i = i + 1) begin\n            // Check if previous state was 0 and current state is 1\n            if (prev_in[i] == 0 && in[i] == 1)\n                pedge[i] <= 1;\n            else\n                pedge[i] <= 0;\n        end\n\n        // Update the previous input state\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // Previous state of the input to detect edges\n    reg [7:0] prev_in;\n\n    // Detect positive edge for each bit\n    always @(posedge clk) begin\n        // Loop through each bit\n        for (int i = 0; i < 8; i++) begin\n            // Check if previous state was 0 and current state is 1\n            if (prev_in[i] == 0 && in[i] == 1)\n                pedge[i] <= 1'b1;\n            else\n                pedge[i] <= 1'b0;\n        end\n\n        // Update the previous input state\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] previous_in;\n\n    always @(posedge clk) begin\n        pedge <= (previous_in == 8'b0) & in;\n        previous_in <= in;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n// Previous state of `in` to detect edges\nreg [7:0] prev_in;\n\nalways @(posedge clk) begin\n    // Loop through each bit to detect 0 to 1 transitions\n    integer i;\n    for (i = 0; i < 8; i++) begin\n        // Check if previous state was 0 and current state is 1\n        if (prev_in[i] == 0 && in[i] == 1)\n            pedge[i] <= 1;\n        else\n            pedge[i] <= 0;\n    end\n    // Update previous state\n    prev_in <= in;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    // Previous state register to hold the previous cycle input values\n    reg [7:0] prev_in;\n\n    // Initialize the previous input register\n    initial begin\n        prev_in = 8'b0;\n    end\n\n    // Always block triggered on the rising edge of the clock\n    always @(posedge clk) begin\n        // Iterate over each bit in the 8-bit vector\n        integer i;\n        for (i = 0; i < 8; i = i + 1) begin\n            // Check for a positive edge transition: 0 -> 1\n            if (prev_in[i] == 0 && in[i] == 1) begin\n                pedge[i] <= 1'b1;  // Set the output bit on finding a positive edge\n            end else begin\n                pedge[i] <= 1'b0;  // Reset the output bit otherwise\n            end\n        end\n        // Update the previous input values for the next cycle\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n    reg [7:0] prev_in;\n\n    always @(posedge clk) begin\n        // Detecting positive edge for each bit\n        pedge <= (in & ~prev_in);\n        // Update previous input at each clock edge\n        prev_in <= in;\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // Previous state of the input to detect edges\n    reg [7:0] prev_in;\n\n    // Edge detection logic\n    always @(posedge clk) begin\n        // Iterate over each bit to detect 0 to 1 transitions\n        pedge <= (in & ~prev_in);\n        // Update previous state\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n    // Previous state register to hold the last state of input\n    reg [7:0] prev_in;\n\n    // Initialize the previous input on reset\n    initial begin\n        prev_in = 8'b0;\n    end\n\n    always @(posedge clk) begin\n        // Loop through each bit to detect 0 to 1 transition\n        integer i;\n        for (i = 0; i < 8; i = i + 1) begin\n            // Check if previous state was 0 and current state is 1\n            if (prev_in[i] == 0 && in[i] == 1)\n                pedge[i] <= 1'b1;  // Set output bit on positive edge\n            else\n                pedge[i] <= 1'b0;  // Reset output bit otherwise\n        end\n        \n        // Update previous input to current input\n        prev_in <= in;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] in,\n    output reg [7:0] pedge\n);\n\n    reg [7:0] previous_in;\n\n    always @(posedge clk) begin\n        // Compare each bit with the corresponding bit from the previous cycle\n        pedge <= (in & ~previous_in);\n        // Update previous_in to the current in for the next clock cycle\n        previous_in <= in;\n    end\n\nendmodule\n"]}
{"task_id": "circuit8", "gptgen_RTL": ["module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\nalways @(posedge clock) begin\n    p <= a;\n    q <= p;\nend\n\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            q <= q;\n        end else begin\n            p <= 0;\n            q <= p;\n        end\n    end\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    reg delay_a; // Register to hold the delayed value of input a\n\n    always @(posedge clock) begin\n        delay_a <= a; // Capture the value of a at every clock edge\n        if (delay_a && !a) begin\n            p <= 1; // Set p to 1 on the falling edge of a\n        end else if (!delay_a && a) begin\n            p <= 1; // Set p to 1 on the rising edge of a\n        end else begin\n            p <= 0; // Otherwise, set p to 0\n        end\n\n        if (p) begin\n            q <= !q; // Toggle q whenever p is 1\n        end\n    end\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        p <= a;\n        q <= p;\n    end\n\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    reg prev_a;\n\n    always @(posedge clock) begin\n        if (prev_a && !a) begin\n            p <= 1;\n            q <= q;\n        end else if (!prev_a && a) begin\n            p <= 1;\n            q <= q;\n        end else begin\n            p <= 0;\n            q <= p;\n        end\n        prev_a <= a;\n    end\nendmodule\n", "module top_module (\n    input clock,\n    input a,\n    output reg p,\n    output reg q\n);\n    reg temp_a;  // Temporary register to hold previous state of 'a'\n\n    always @(posedge clock) begin\n        if (a && !temp_a) begin\n            p <= 1;  // Set 'p' when 'a' rises from 0 to 1\n        end else begin\n            p <= 0;  // Reset 'p' otherwise\n        end\n\n        if (p == 1) begin\n            q <= ~q;  // Toggle 'q' when 'p' is 1\n        end\n    end\n\n    always @(negedge clock) begin\n        temp_a <= a;  // Update 'temp_a' on the negative edge to capture rising edge in next cycle\n    end\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n    \n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            q <= q; // retain the previous value of q\n        end else begin\n            p <= 0;\n            q <= p; // transfer the value of p to q\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clock,\n    input a,\n    output reg p,\n    output reg q\n);\n\n    reg q_next, p_next;\n\n    always @(posedge clock) begin\n        q <= q_next;\n        p <= p_next;\n    end\n\n    always @(*) begin\n        // Default values\n        p_next = p;\n        q_next = q;\n\n        // Logic based on transition table derived from problem description\n        if (a && !p) begin\n            p_next = 1;\n            q_next = q;\n        end else if (!a && p) begin\n            p_next = 0;\n            q_next = 1;\n        end else if (!a && q) begin\n            p_next = 0;\n            q_next = 1;\n        end else if (a && q) begin\n            p_next = 1;\n            q_next = 1;\n        end else if (!a) begin\n            p_next = 0;\n            q_next = 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\n    always @(posedge clock) begin\n        if (a) begin\n            p <= 1;\n            q <= q;\n        end else begin\n            p <= 0;\n            q <= p;\n        end\n    end\n\n    always @(negedge clock) begin\n        if (a) begin\n            q <= q;\n        end else begin\n            q <= p;\n        end\n    end\n    \nendmodule\n", "module top_module (\n    input clock,\n    input a, \n    output reg p,\n    output reg q\n);\n\nalways @(posedge clock) begin\n    p <= a;  // On each positive clock edge, pass input 'a' to output 'p'\nend\n\nalways @(posedge clock) begin\n    if (p)      // On each positive clock edge, if 'p' is high,\n        q <= 1; // then set 'q' high\n    else        // otherwise,\n        q <= 0; // set 'q' low.\nend\n\nendmodule\n"]}
{"task_id": "rule90", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to hold the next state\n    reg [511:0] next_state;\n\n    // Compute the next state based on Rule 90\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the state from the data input\n            q <= data;\n        end else begin\n            // Calculate each cell's next state using Rule 90\n            next_state[0] = q[1] ^ 1'b0; // Assuming q[-1] is 0\n            next_state[511] = 1'b0 ^ q[510]; // Assuming q[512] is 0\n\n            // Compute next state for the rest of the cells\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : compute_next_state\n                    always @(*) begin\n                        next_state[i] = q[i-1] ^ q[i+1];\n                    end\n                end\n            endgenerate\n            \n            // Update the state\n            q <= next_state;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to store the next state\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into the register if load is high\n            q <= data;\n        end else begin\n            // Compute the next state for each cell\n            next_q[0] = q[1] ^ 0; // Assuming the left of q[0] is 0\n            next_q[511] = 0 ^ q[510]; // Assuming the right of q[511] is 0\n\n            // Compute for the rest of the cells\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : compute_next_state\n                    always @(*) begin\n                        next_q[i] = q[i-1] ^ q[i+1];\n                    end\n                end\n            endgenerate\n\n            // Update the state\n            q <= next_q;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to hold the next state of the system\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when load signal is asserted\n            q <= data;\n        end else begin\n            // Calculate the next state of each cell based on Rule 90\n            next_q[0] = q[1] ^ 1'b0;  // Since q[-1] is assumed to be 0\n            next_q[511] = 1'b0 ^ q[510];  // Since q[512] is assumed to be 0\n\n            // Iterate through each cell from 1 to 510\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : gen_rule90\n                    always @(*) begin\n                        next_q[i] = q[i-1] ^ q[i+1];\n                    end\n                end\n            endgenerate\n\n            // Update the state of q to the next state\n            q <= next_q;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to calculate next state\n    reg [511:0] next_state;\n\n    // Compute the next state of each cell\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load data into q if load signal is high\n        end \n        else begin\n            next_state[0] = q[1] ^ 1'b0;  // Boundary condition, q[-1] is assumed to be zero\n            next_state[511] = q[510] ^ 1'b0;  // Boundary condition, q[512] is assumed to be zero\n            \n            // Iterate over each cell from 1 to 510\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : gen_next_state\n                    always @(q[i-1], q[i+1])\n                        next_state[i] = q[i-1] ^ q[i+1];\n                end\n            endgenerate\n            \n            q <= next_state;  // Update state of all cells\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    reg [513:0] extended_q;  // Extended to handle boundary conditions\n\n    // Define initial and always blocks\n    initial begin\n        q = 512'b0;  // Initialize q to zero\n    end\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;  // Load data into q when load is high\n        end else begin\n            // Update q based on Rule 90, considering extended boundaries\n            extended_q = {1'b0, q, 1'b0};  // Append 0s to both sides\n\n            // Compute next state for each cell\n            integer i;\n            for (i = 0; i < 512; i = i + 1) begin\n                q[i] <= extended_q[i] ^ extended_q[i+2];  // XOR of left and right neighbors\n            end\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to calculate next state\n    reg [511:0] next_state;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data directly into q when load signal is asserted\n            q <= data;\n        end else begin\n            // Calculate the next state for each cell\n            next_state[0] <= q[1] ^ 1'b0; // q[-1] is 0\n            next_state[511] <= q[510] ^ 1'b0; // q[512] is 0\n            \n            // Compute next state for the rest of the cells\n            genvar i;\n            generate\n                for (i = 1; i < 511; i = i + 1) begin : gen_rule90\n                    always @(posedge clk) begin\n                        next_state[i] <= q[i-1] ^ q[i+1];\n                    end\n                end\n            endgenerate\n            \n            // Update the state of q\n            q <= next_state;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Intermediate register to store the next state\n    reg [511:0] next_q;\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when load is high\n            q <= data;\n        end else begin\n            // Calculate the next state for each cell\n            for (i = 0; i < 512; i++) begin\n                if (i == 0) begin\n                    // Handle boundary condition for the first cell\n                    next_q[i] = 0 ^ q[i + 1];  // q[-1] is assumed to be 0\n                end else if (i == 511) begin\n                    // Handle boundary condition for the last cell\n                    next_q[i] = q[i - 1] ^ 0;  // q[512] is assumed to be 0\n                end else begin\n                    // General case for cells not at the boundaries\n                    next_q[i] = q[i - 1] ^ q[i + 1];\n                end\n            end\n            // Update q with the next state\n            q <= next_q;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    // Temporary register to hold next state\n    reg [511:0] next_state;\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when load signal is asserted\n            q <= data;\n        end else begin\n            // Compute next state based on Rule 90\n            for (i = 0; i < 512; i++) begin\n                if (i == 0) begin\n                    // For the first cell, assume cell at index -1 is 0\n                    next_state[i] = q[i+1] ^ 1'b0;\n                end else if (i == 511) begin\n                    // For the last cell, assume cell at index 512 is 0\n                    next_state[i] = 1'b0 ^ q[i-1];\n                end else begin\n                    // For all other cells, calculate based on neighbors\n                    next_state[i] = q[i+1] ^ q[i-1];\n                end\n            end\n            // Load the computed next state back to q\n            q <= next_state;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n\n    // Temporary register to hold the next state of the array\n    reg [511:0] next_q;\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into q when load is asserted\n            q <= data;\n        end else begin\n            // Calculate the next state of each cell\n            for (i = 0; i < 512; i++) begin\n                if (i == 0) begin\n                    // Handle boundary condition at the left end\n                    next_q[i] <= 0 ^ q[i + 1];\n                end else if (i == 511) begin\n                    // Handle boundary condition at the right end\n                    next_q[i] <= q[i - 1] ^ 0;\n                end else begin\n                    // Calculate next state for middle cells\n                    next_q[i] <= q[i - 1] ^ q[i + 1];\n                end\n            end\n            // Update q to the next state\n            q <= next_q;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [511:0] data,\n    output reg [511:0] q\n);\n    reg [511:0] next_q;\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\n    always @(*) begin\n        integer i;\n        for (i = 0; i < 512; i++) begin\n            if (i == 0)\n                next_q[i] = q[1] ^ 0;  // q[-1] is treated as 0\n            else if (i == 511)\n                next_q[i] = 0 ^ q[510];  // q[512] is treated as 0\n            else\n                next_q[i] = q[i+1] ^ q[i-1];\n        end\n    end\nendmodule\n"]}
{"task_id": "mt2015_eq2", "gptgen_RTL": ["module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B);\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B);\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B);\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z);\n\n    // Compare A and B and assign the result to z\n    assign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\nassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input [1:0] A,\n    input [1:0] B,\n    output z\n);\n\n// Compare A and B, set z to 1 if they are equal, otherwise set to 0\nassign z = (A == B) ? 1'b1 : 1'b0;\n\nendmodule\n"]}
{"task_id": "gatesv100", "gptgen_RTL": ["module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // Generating out_both\n    // out_both[i] = in[i] & in[i+1], for i from 0 to 98\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin: out_both_loop\n            assign out_both[i] = in[i] & in[i + 1];\n        end\n    endgenerate\n\n    // Generating out_any\n    // out_any[i] = in[i] | in[i-1], for i from 1 to 99\n    generate\n        for (i = 1; i < 100; i = i + 1) begin: out_any_loop\n            assign out_any[i] = in[i] | in[i - 1];\n        end\n    endgenerate\n\n    // Generating out_different\n    // out_different[i] = in[i] ^ in[i+1], for i from 0 to 98\n    // out_different[99] = in[99] ^ in[0] (wrap around)\n    generate\n        for (i = 0; i < 99; i = i + 1) begin: out_different_normal_loop\n            assign out_different[i] = in[i] ^ in[i + 1];\n        end\n        assign out_different[99] = in[99] ^ in[0];\n    endgenerate\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // Generate out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin\n            assign out_both[i] = in[i] & in[i + 1];\n        end\n    endgenerate\n\n    // As out_both[99] is not needed, it's not defined here.\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin\n            assign out_any[i] = in[i] | in[i - 1];\n        end\n    endgenerate\n\n    // As out_any[0] is not needed, it's not defined here.\n\n    // Generate out_different\n    assign out_different[0] = in[0] ^ in[99]; // Wrap around for the first element\n    generate\n        for (i = 1; i < 100; i = i + 1) begin\n            assign out_different[i] = in[i] ^ in[i - 1];\n        end\n    endgenerate\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    genvar i;\n\n    // Generate out_both\n    // Each bit of out_both should be 1 if both the corresponding bit in 'in' and its left neighbour are 1.\n    assign out_both[98:0] = in[98:0] & in[99:1];\n\n    // Generate out_any\n    // Each bit of out_any should be 1 if either the corresponding bit in 'in' or its right neighbour is 1.\n    assign out_any[99:1] = in[99:1] | in[98:0];\n\n    // Generate out_different\n    // Each bit of out_different should be 1 if the corresponding bit in 'in' differs from its left neighbour.\n    assign out_different[98:0] = in[98:0] ^ in[99:1];\n    assign out_different[99] = in[99] ^ in[0];\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n\n    // out_both calculation\n    assign out_both[98:0] = in[98:0] & in[99:1];\n\n    // out_any calculation\n    assign out_any[99:1] = in[99:1] | in[98:0];\n\n    // out_different calculation\n    assign out_different[99] = in[99] ^ in[0];  // Wrapping around for the 99th element\n    assign out_different[98:0] = in[98:0] ^ in[99:1];\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // Generate out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    assign out_any[99] = in[99] | in[0]; // Wrap around case for the highest index\n    generate\n        for (i = 1; i < 99; i = i + 1) begin\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[0] = in[0] ^ in[99]; // Wrap around case for the lowest index\n    generate\n        for (i = 1; i <= 99; i = i + 1) begin\n            assign out_different[i] = in[i] ^ in[i-1];\n        end\n    endgenerate\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    genvar i;\n\n    // Generate both outputs\n    generate\n        for (i = 0; i < 99; i++) begin\n            // Output for out_both: true if both the current bit and its left neighbor are 1\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n    \n    // Generate any outputs\n    generate\n        for (i = 1; i < 100; i++) begin\n            // Output for out_any: true if either the current bit or its right neighbor is 1\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n    \n    // Generate different outputs\n    generate\n        for (i = 0; i < 99; i++) begin\n            // Output for out_different: true if the current bit is different from its left neighbor\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n        // wrap around for the last element\n        assign out_different[99] = in[99] ^ in[0];\n    endgenerate\n\nendmodule\n", "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n    // Generate out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i + 1] & in[i];\n        end\n    endgenerate\n\n    // Generate out_any\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i] | in[i - 1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[99] = in[99] ^ in[0]; // Special case for the wrap-around\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_different\n            assign out_different[i] = in[i] ^ in[i + 1];\n        end\n    endgenerate\n    \nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    genvar i;\n\n    // Generating out_both\n    // Note: out_both[99] is not needed\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_both\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generating out_any\n    // Note: out_any[0] is not needed\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : gen_out_any\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generating out_different\n    // Note: Treats the array as wrapping around\n    assign out_different[99] = in[99] ^ in[0];  // Special case for the wrap-around\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : gen_out_different\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // Generate out_both\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate out_any\n    assign out_any[99] = in[99] | in[98]; // Special case for highest bit\n    generate\n        for (i = 1; i < 99; i = i + 1) begin\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate out_different\n    assign out_different[99] = in[99] ^ in[0]; // Wrapping around\n    generate\n        for (i = 0; i < 99; i = i + 1) begin\n            assign out_different[i] = in[i] ^ in[i+1];\n        end\n    endgenerate\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output [98:0] out_both,\n    output [99:1] out_any,\n    output [99:0] out_different\n);\n    // Generate output for out_both\n    // out_both[98:0] checks if both the current bit and its left neighbour are '1'\n    genvar i;\n    generate\n        for (i = 0; i < 99; i = i + 1) begin : both_loop\n            assign out_both[i] = in[i] & in[i+1];\n        end\n    endgenerate\n\n    // Generate output for out_any\n    // out_any[99:1] checks if any of the current bit or its right neighbour are '1'\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : any_loop\n            assign out_any[i] = in[i] | in[i-1];\n        end\n    endgenerate\n\n    // Generate output for out_different\n    // out_different[99:0] checks if the current bit is different from its left neighbour\n    // Note: in[99] wraps around to compare with in[0]\n    assign out_different[0] = in[0] ^ in[99];  // Wrap around case\n    generate\n        for (i = 1; i < 100; i = i + 1) begin : diff_loop\n            assign out_different[i] = in[i] ^ in[i-1];\n        end\n    endgenerate\n\nendmodule\n"]}
{"task_id": "m2014_q4a", "gptgen_RTL": ["module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(ena, d) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(ena, d)\n    if (ena) q <= d;\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @ (ena or d)\nbegin\n    if (ena)\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(d or ena) begin\n    if (ena) begin\n        q = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(ena or d) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(d, ena) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\nalways @(d, ena)\nbegin\n\tif (ena)\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(ena or d) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(d or ena) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input d,\n    input ena,\n    output logic q\n);\n\nalways @(d or ena) begin\n    if (ena) begin\n        q <= d;\n    end\nend\n\nendmodule\n"]}
{"task_id": "mux256to1v", "gptgen_RTL": ["module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[(sel*4)+3 -: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\nassign out = in[sel*4+3 -: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    wire [11:0] selected_addr; // Address calculation\n    assign selected_addr = sel * 4;\n\n    assign out = in[selected_addr + 3 : selected_addr]; // Extract the 4-bit data\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    // Calculate the bit position based on the select input\n    wire [9:0] bit_position = sel * 4;\n\n    // Connect the output to the appropriate bits in the input vector\n    assign out = in[bit_position +: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel*4 +: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    assign out = in[sel * 4 +: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    // Calculate the index range for the selected bits using sel\n    // Each 4-bit section is indexed by sel, multiplying sel by 4 gives the starting index.\n    wire [9:0] base_index = sel * 4;\n    \n    // Assign the corresponding 4-bit section from the input vector to the output\n    assign out = in[base_index +: 4];\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n\n    // Calculate the starting index of the selected 4-bit segment\n    wire [9:0] start_index = sel * 4;  // Each section is 4 bits, so multiply by 4 to get the start index\n\n    // Assign the selected 4 bits to the output\n    assign out = in[start_index +: 4];  // Using part-select with the +: operator\n\nendmodule\n", "module top_module (\n    input [1023:0] in,\n    input [7:0] sel,\n    output [3:0] out\n);\n    assign out = in[sel * 4 +: 4];\nendmodule\n"]}
{"task_id": "mux9to1v", "gptgen_RTL": ["module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'hFFFF; // For sel=9 to 15, set all output bits to '1'\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // set all output bits to '1' for sel=9 to 15\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // For unused cases (sel=9 to 15), set all output bits to '1'.\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;  // sets all output bits to '1' for sel=9 to 15\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'hFFFF; // All other cases set out to all 1's\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Sets all bits to 1 for sel=9 to 15\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF; // Sets all output bits to '1' for unused cases\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'b0000: out = a;\n            4'b0001: out = b;\n            4'b0010: out = c;\n            4'b0011: out = d;\n            4'b0100: out = e;\n            4'b0101: out = f;\n            4'b0110: out = g;\n            4'b0111: out = h;\n            4'b1000: out = i;\n            default: out = 16'hFFFF; // For sel = 9 to 15, output all '1's\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\nalways @(*) begin\n    case (sel)\n        4'b0000: out = a;\n        4'b0001: out = b;\n        4'b0010: out = c;\n        4'b0011: out = d;\n        4'b0100: out = e;\n        4'b0101: out = f;\n        4'b0110: out = g;\n        4'b0111: out = h;\n        4'b1000: out = i;\n        default: out = 16'hFFFF; // All ones for unused cases\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] a,\n    input [15:0] b,\n    input [15:0] c,\n    input [15:0] d,\n    input [15:0] e,\n    input [15:0] f,\n    input [15:0] g,\n    input [15:0] h,\n    input [15:0] i,\n    input [3:0] sel,\n    output logic [15:0] out\n);\n\n    always @(*) begin\n        case(sel)\n            4'd0: out = a;\n            4'd1: out = b;\n            4'd2: out = c;\n            4'd3: out = d;\n            4'd4: out = e;\n            4'd5: out = f;\n            4'd6: out = g;\n            4'd7: out = h;\n            4'd8: out = i;\n            default: out = 16'hFFFF;  // '1' for all bits for sel=9 to 15\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "vectorgates", "gptgen_RTL": ["module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR of a and b\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of vector b and store in upper half of out_not (bits [5:3])\n    assign out_not[5:3] = ~b;\n\n    // Compute NOT of vector a and store in lower half of out_not (bits [2:0])\n    assign out_not[2:0] = ~a;\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR of a and b\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of both vectors\n    // Place NOT of b in the upper half (bits [5:3]) and NOT of a in the lower half (bits [2:0])\n    assign out_not = {~b, ~a};\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of each vector and assign to outputs accordingly\n    assign out_not = {~b, ~a};\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = |(a | b); // Reduce OR after bitwise OR\n\n    // Compute NOT inverses\n    // Inverse of b assigned to upper half of out_not ([5:3])\n    // Inverse of a assigned to lower half of out_not ([2:0])\n    assign out_not = {~b, ~a};\n\nendmodule\n", "module top_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute the bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute the logical OR\n    assign out_or_logical = |(a | b);  // OR reduction of the bitwise OR\n\n    // Compute the NOT of both vectors\n    assign out_not[2:0] = ~a;         // Inverse of a in lower half\n    assign out_not[5:3] = ~b;         // Inverse of b in upper half\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of both inputs\n    // Place NOT of b in upper half and NOT of a in lower half\n    assign out_not = {~b, ~a};\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR of vectors a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR of vectors a and b\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of vector b and store in upper half of out_not\n    assign out_not[5:3] = ~b;\n\n    // Compute NOT of vector a and store in lower half of out_not\n    assign out_not[2:0] = ~a;\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n    // Compute bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR of a and b\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of b and place it in upper half of out_not (bits [5:3])\n    assign out_not[5:3] = ~b;\n\n    // Compute NOT of a and place it in lower half of out_not (bits [2:0])\n    assign out_not[2:0] = ~a;\n\nendmodule\n", "module top_module(\n    input [2:0] a, \n    input [2:0] b, \n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Compute bitwise OR of a and b\n    assign out_or_bitwise = a | b;\n\n    // Compute logical OR of a and b\n    assign out_or_logical = |(a | b);\n\n    // Compute NOT of a and b and assign to out_not\n    assign out_not[2:0] = ~a;\n    assign out_not[5:3] = ~b;\n\nendmodule\n", "module top_module(\n    input [2:0] a,\n    input [2:0] b,\n    output [2:0] out_or_bitwise,\n    output out_or_logical,\n    output [5:0] out_not\n);\n\n    // Bitwise OR operation\n    assign out_or_bitwise = a | b;\n\n    // Logical OR operation\n    assign out_or_logical = |(a | b);\n\n    // NOT operation on a and b, with b in the upper half and a in the lower half\n    assign out_not = {~b, ~a};\n\nendmodule\n"]}
{"task_id": "fsm3onehot", "gptgen_RTL": ["module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // Define state encoding\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n\n    // Output logic\n    assign out = (state == D);  // Output is 1 only when in state D\n\n    // Next state logic based on current state and input\n    always @ (*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 4'b0000;  // Default case to handle undefined states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output reg out\n);\n\n    // Define state encoding\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n    \n    // State transition and output logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = B;\n                out = 0;\n            end\n            B: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 0;\n            end\n            C: begin\n                if (in == 0)\n                    next_state = A;\n                else\n                    next_state = D;\n                out = 0;\n            end\n            D: begin\n                if (in == 0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 1;\n            end\n            default: begin\n                next_state = 4'bxxxx; // Undefined state\n                out = 1'bx;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output reg out\n);\n\n    always @(*) begin\n        // Default assignments\n        next_state = 4'b0000;\n        out = 1'b0;\n\n        // State transition logic and output logic\n        case (state)\n            4'b0001: begin // State A\n                if (in == 0) next_state = 4'b0001; // Stay in A\n                else next_state = 4'b0010; // Transition to B\n                out = 1'b0;\n            end\n            4'b0010: begin // State B\n                if (in == 0) next_state = 4'b0100; // Transition to C\n                else next_state = 4'b0010; // Stay in B\n                out = 1'b0;\n            end\n            4'b0100: begin // State C\n                if (in == 0) next_state = 4'b0001; // Transition to A\n                else next_state = 4'b1000; // Transition to D\n                out = 1'b0;\n            end\n            4'b1000: begin // State D\n                if (in == 0) next_state = 4'b0100; // Transition to C\n                else next_state = 4'b0010; // Transition to B\n                out = 1'b1;\n            end\n            default: begin\n                next_state = 4'b0001; // Default to state A if unknown state\n                out = 1'b0;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // Define states using one-hot encoding\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n\n    // Output logic\n    assign out = (state == D);\n\n    // State transition logic\n    always @(*) begin\n        case (state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 4'b0001; // Default to state A if undefined state\n        endcase\n    end\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // Define state encoding\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n\n    // Output logic\n    assign out = (state == D);  // Output is 1 only in state D, else it is 0\n\n    // State transition logic\n    always @(*) begin\n        case(state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 4'b0001; // Default to A if state is unknown\n        endcase\n    end\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output reg out\n);\n\n    // State definitions\n    localparam [3:0] A = 4'b0001;\n    localparam [3:0] B = 4'b0010;\n    localparam [3:0] C = 4'b0100;\n    localparam [3:0] D = 4'b1000;\n\n    // State transition logic and output logic\n    always @(*) begin\n        // Default assignments\n        next_state = 4'b0000; // Safe state assignment\n        out = 1'b0;           // Default output\n\n        case (state)\n            A: begin\n                if (in == 1'b0)\n                    next_state = A;\n                else\n                    next_state = B;\n                out = 1'b0;\n            end\n            B: begin\n                if (in == 1'b0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 1'b0;\n            end\n            C: begin\n                if (in == 1'b0)\n                    next_state = A;\n                else\n                    next_state = D;\n                out = 1'b0;\n            end\n            D: begin\n                if (in == 1'b0)\n                    next_state = C;\n                else\n                    next_state = B;\n                out = 1'b1;\n            end\n            default: begin\n                next_state = 4'b0001; // Default to state A if undefined state\n                out = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    // Define State Codes\n    localparam [3:0] A = 4'b0001,\n                     B = 4'b0010,\n                     C = 4'b0100,\n                     D = 4'b1000;\n\n    // Output Logic\n    assign out = (state == D);\n\n    // Next State Logic\n    always @(*) begin\n        case(state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = 4'bxxxx; // Undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    // Define the states as one-hot encoding\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D);\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n\n    // Define the state encoding using parameters for readability\n    parameter A = 4'b0001, B = 4'b0010, C = 4'b0100, D = 4'b1000;\n\n    // Determine the next state based on the current state and input\n    always @(*) begin\n        case (state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = 4'bxxxx;  // Undefined state\n        endcase\n    end\n\n    // Determine the output based only on the current state\n    // As it is a Moore machine, the output depends only on the state.\n    assign out = (state == D);\n\nendmodule\n", "module top_module (\n    input in,\n    input [3:0] state,\n    output reg [3:0] next_state,\n    output out\n);\n    // Define state codes\n    localparam A = 4'b0001;\n    localparam B = 4'b0010;\n    localparam C = 4'b0100;\n    localparam D = 4'b1000;\n\n    // State transition logic based on current state and input\n    always @(*) begin\n        case(state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = 4'b0001; // Default to state A\n        endcase\n    end\n\n    // Output logic\n    assign out = (state == D); // Output is 1 only when in state D\n\nendmodule\n"]}
{"task_id": "conditional", "gptgen_RTL": ["module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @* begin\n        // Initialize min with the value of 'a'\n        min = a;\n        \n        // Compare 'b' with the current minimum\n        if (b < min) min = b;\n\n        // Compare 'c' with the current minimum\n        if (c < min) min = c;\n\n        // Compare 'd' with the current minimum\n        if (d < min) min = d;\n    end\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        if (a <= b && a <= c && a <= d)\n            min = a;\n        else if (b <= a && b <= c && b <= d)\n            min = b;\n        else if (c <= a && c <= b && c <= d)\n            min = c;\n        else\n            min = d;\n    end\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d) begin\n        min = a;\n    end else if (b <= a && b <= c && b <= d) begin\n        min = b;\n    end else if (c <= a && c <= b && c <= d) begin\n        min = c;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d) begin\n        min = a;\n    end else if (b <= a && b <= c && b <= d) begin\n        min = b;\n    end else if (c <= a && c <= b && c <= d) begin\n        min = c;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d) begin\n        min = a;\n    end else if (b <= a && b <= c && b <= d) begin\n        min = b;\n    end else if (c <= a && c <= b && c <= d) begin\n        min = c;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n    always @(*) begin\n        if (a <= b && a <= c && a <= d) begin\n            min = a;\n        end else if (b <= a && b <= c && b <= d) begin\n            min = b;\n        end else if (c <= a && c <= b && c <= d) begin\n            min = c;\n        end else begin\n            min = d;\n        end\n    end\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d) begin\n        min = a;\n    end else if (b <= a && b <= c && b <= d) begin\n        min = b;\n    end else if (c <= a && c <= b && c <= d) begin\n        min = c;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d) begin\n        min = a;\n    end else if (b <= a && b <= c && b <= d) begin\n        min = b;\n    end else if (c <= a && c <= b && c <= d) begin\n        min = c;\n    end else begin\n        min = d;\n    end\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\nalways @(*) begin\n    if (a <= b && a <= c && a <= d)\n        min = a;\n    else if (b <= a && b <= c && b <= d)\n        min = b;\n    else if (c <= a && c <= b && c <= d)\n        min = c;\n    else\n        min = d;\nend\n\nendmodule\n", "module top_module (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    output reg [7:0] min\n);\n\n    always @(*) begin\n        if (a <= b && a <= c && a <= d) begin\n            min = a;\n        end else if (b <= a && b <= c && b <= d) begin\n            min = b;\n        end else if (c <= a && c <= b && c <= d) begin\n            min = c;\n        end else begin\n            min = d;\n        end\n    end\n\nendmodule\n"]}
{"task_id": "kmap2", "gptgen_RTL": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\nassign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | (~a & b & c & d) |\n             (a & ~b & ~c & d) | (a & ~b & c & ~d) | (a & b & ~c & d) | (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    // Implementing the Karnaugh map\n    // Simplified expression from K-map: out = a'c' + ac + bd + a'b'd'\n    assign out = (~a & ~c) | (a & c) | (b & d) | (~a & ~b & ~d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n// Logic derived from the Karnaugh map\nassign out = (a & ~b & ~c & ~d) | \n             (a & ~b & ~c & d)  | \n             (~a & b & ~c & ~d) | \n             (~a & ~b & c & ~d) | \n             (~a & b & c & ~d)  |\n             (a & b & ~c & d)   |\n             (a & ~b & c & ~d)  |\n             (~a & b & c & d)   |\n             (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (c & ~d & ~a) | \n                 (~c & d & b) | \n                 (~c & ~d & a) | \n                 (c & ~d & b) | \n                 (c & d & ~b) | \n                 (c & d & a);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    assign out = (a & ~b & c) | (~a & c & d) | (~a & ~c & ~d) | (a & ~c & d) |\n                 (~a & b & ~c) | (a & b & ~d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n// Simplification using the Karnaugh Map provided\n// Simplified Boolean Expression: out = c'd' + ab' + a'b + cd\n\nassign out = (~c & ~d) | (a & ~b) | (~a & b) | (c & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    // Implementing the logic function derived from the Karnaugh map\n    assign out = (a & ~b & c) | (~a & c) | (~a & d) | (b & c & d) | (a & ~c & d);\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\n\t// Implementing the logic from the Karnaugh map using a sum of products\n\tassign out = (~a & ~b & ~c & d) | (~a & ~b & c & ~d) | (~a & b & ~c & ~d) | \n\t             (~a & b & c & d) | (a & ~b & ~c & d) | (a & ~b & c & d) | \n\t             (a & b & c & ~d) | (a & b & c & d);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    // Boolean expression derived from the Karnaugh map\n    assign out = (~a & ~b & ~c) | \n                 (~a & ~b & d)  | \n                 (~a & b & ~c & d) | \n                 (a & ~b & ~c) | \n                 (a & ~b & d) | \n                 (a & b & c) | \n                 (a & b & d);\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output out\n);\n\n    // Simplifying the Karnaugh map expression\n    // Using the map, we can derive the simplified boolean expression:\n    //  out = a'c' + b'c + ad' + ac\n    assign out = (~a & ~c) | (~b & c) | (a & ~d) | (a & c);\n\nendmodule\n"]}
{"task_id": "2014_q3fsm", "gptgen_RTL": ["module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State Declaration\n    parameter A = 0, B = 1, C = 2, D = 3, E = 4;\n\n    // State Register\n    reg [2:0] state, next_state;\n\n    // Variables to count the number of times 'w' is '1'\n    reg [1:0] count;\n\n    // State transitions and output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n            if (state == B || state == C || state == D) begin\n                if (w) count <= count + 1;\n            end\n            if (state == D) begin\n                z <= (count == 2) ? 1 : 0;\n            end else begin\n                z <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                next_state = s ? B : A;\n            end\n            B: begin\n                next_state = C;\n            end\n            C: begin\n                next_state = D;\n            end\n            D: begin\n                next_state = E;\n            end\n            E: begin\n                next_state = B;  // Return to B to start checking again\n                count = 0;       // Reset count when moving back to B\n            end\n            default: begin\n                next_state = A;\n            end\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State Encoding\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,\n        STATE_B0 = 3'b001,\n        STATE_B1 = 3'b010,\n        STATE_B2 = 3'b011,\n        STATE_B3 = 3'b100\n    } state_type;\n\n    // State variable\n    reg [2:0] state, next_state;\n\n    // Count the number of w=1 occurrences\n    reg [1:0] count_ones;\n\n    // State Register\n    always @(posedge clk) begin\n        if (reset)\n            state <= STATE_A;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic and Output Logic\n    always @(*) begin\n        next_state = state; // Default keep current state\n        z = 1'b0; // Default output\n\n        case (state)\n            STATE_A: begin\n                if (s == 1'b1)\n                    next_state = STATE_B0;\n            end\n            STATE_B0: begin\n                // Start counting w=1 instances\n                count_ones = (w == 1'b1) ? 1 : 0;\n                next_state = STATE_B1;\n            end\n            STATE_B1: begin\n                count_ones = count_ones + ((w == 1'b1) ? 1 : 0);\n                next_state = STATE_B2;\n            end\n            STATE_B2: begin\n                count_ones = count_ones + ((w == 1'b1) ? 1 : 0);\n                next_state = STATE_B3;\n            end\n            STATE_B3: begin\n                // Decide output based on count in previous states\n                if (count_ones == 2)\n                    z = 1'b1;\n                count_ones = (w == 1'b1) ? 1 : 0; // Start new count for next cycle\n                next_state = STATE_B1; // Loop back to count again\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Reset the ones counter when transitioning to B0\n    always @(posedge clk) begin\n        if (reset || next_state == STATE_B0)\n            count_ones <= 0;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State Encoding\n    localparam A = 2'd0,\n               B = 2'd1,\n               C = 2'd2,\n               D = 2'd3;\n\n    // State and count variables\n    reg [1:0] state, next_state;\n    reg [2:0] count;  // Count the number of w = 1 observed\n    reg [1:0] one_count;  // Counter for how many times w has been 1 in states B, C, D\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            one_count <= 0;\n            count <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n            if (state == B || state == C || state == D) begin\n                count <= count + 1;\n                if (w) one_count <= one_count + 1;\n            end\n            if (count == 3) begin\n                z <= (one_count == 2);\n                one_count <= 0;\n                count <= 0;\n            end else begin\n                z <= 0;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: next_state = s ? B : A;  // Only transition on s == 1\n            B: next_state = C;  // Sequential progression through B, C, D\n            C: next_state = D;\n            D: next_state = B;  // Go back to B after D\n            default: next_state = A;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // Declare state identifiers\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n    reg [1:0] state, next_state;\n    reg [1:0] count_ones;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= A;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (s == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n                z = 0;  // Output z is always 0 in state A\n            end\n            B: begin\n                next_state = C;\n                count_ones = w;  // Start counting w's that are 1\n                z = 0;  // Output z is 0 when transitioning to state B\n            end\n            C: begin\n                next_state = D;\n                count_ones = count_ones + w;  // Continue counting 1's from w\n                z = 0;  // Output z remains 0 in state C\n            end\n            D: begin\n                next_state = B;\n                count_ones = count_ones + w;  // Finish counting for this cycle\n                // Determine if exactly two of the samples were 1\n                if (count_ones == 2'b10)\n                    z = 1;  // Set output z to 1 if exactly two 1's were counted\n                else\n                    z = 0;  // Otherwise, output z is 0\n            end\n            default: begin\n                next_state = A;\n                z = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    localparam A = 2'b00,\n               B = 2'b01,\n               C = 2'b10,\n               D = 2'b11;\n\n    // State register\n    reg [1:0] state, next_state;\n\n    // Counter for tracking number of '1's in 'w' in states B, C, D\n    reg [1:0] count;\n    reg [1:0] next_count;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 0;\n        end else begin\n            state <= next_state;\n            count <= next_count;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (state)\n            A: begin\n                if (s == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n                next_count = 0;\n            end\n\n            B: begin\n                next_count = count + w;\n                if (count == 2) // Already seen 2 ones, check this cycle's input\n                    next_state = (w == 1) ? D : C;\n                else\n                    next_state = B;\n            end\n\n            C: begin\n                next_count = count + w;\n                if (count == 1) // Need one more '1' to make it two\n                    next_state = (w == 1) ? D : C;\n                else\n                    next_state = C;\n            end\n            \n            D: begin\n                next_count = count + w;\n                next_state = (count == 2 && w == 0) ? B : \n                             ((count < 2 && w == 1) ? B : D);\n            end\n\n            default: begin\n                next_state = A;\n                next_count = 0;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            z <= 0;\n        else begin\n            if (state == D && next_state == B)\n                z <= 1;\n            else\n                z <= 0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State Declaration\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B0 = 2'b01,\n        STATE_B1 = 2'b10,\n        STATE_B2 = 2'b11\n    } state_type;\n\n    // Signal to hold the current state and next state\n    reg [1:0] current_state, next_state;\n\n    // Counter to track the number of 1's in three cycles\n    reg [1:0] count_ones;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_A;\n            count_ones <= 0;\n            z <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (s == 1)\n                    next_state = STATE_B0;  // Move to B0 if s is 1\n                else\n                    next_state = STATE_A;  // Stay in A if s is 0\n            end\n            STATE_B0: begin\n                next_state = STATE_B1;  // Move to B1\n            end\n            STATE_B1: begin\n                next_state = STATE_B2;  // Move to B2\n            end\n            STATE_B2: begin\n                next_state = STATE_B0;  // Move back to B0\n            end\n            default: begin\n                next_state = STATE_A;  // Safety net\n            end\n        endcase\n    end\n\n    // Output logic and count tracking based on input w\n    always @(posedge clk) begin\n        if (reset) begin\n            count_ones <= 0;\n            z <= 0;\n        end else if (current_state == STATE_A) begin\n            count_ones <= 0;  // Reset counter when in state A\n        end else begin\n            // Count the number of 1's in states B0, B1, B2\n            if (w == 1)\n                count_ones <= count_ones + 1;\n\n            // Set the output based on the count of 1's after passing through B2\n            if (current_state == STATE_B2) begin\n                if (count_ones == 2'b10)  // If exactly two 1's\n                    z <= 1;\n                else\n                    z <= 0;\n\n                // Reset count_ones after checking\n                count_ones <= 0;\n            end\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n\n    // State encoding\n    parameter A = 2'b00, B = 2'b01, COUNT_W = 2'b10;\n    reg [1:0] state, next_state;\n    reg [2:0] count; // To count the number of cycles and w=1 occurrences\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= A;\n            count <= 3'b000;\n        end else begin\n            state <= next_state;\n            if (state == COUNT_W) begin\n                count <= count + 1'b1;\n            end\n        end\n    end\n    \n    // Next state logic\n    always @(*) begin\n        case(state)\n            A: begin\n                if (s == 1)\n                    next_state = B;\n                else\n                    next_state = A;\n            end\n            B: begin\n                next_state = COUNT_W;\n            end\n            COUNT_W: begin\n                if (count == 3'b011) // After three cycles\n                    next_state = COUNT_W; // Loop back to continue counting\n                else\n                    next_state = COUNT_W;\n            end\n            default: next_state = A;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (state == COUNT_W && count == 3'b011) begin\n            if ((w == 1 && count[0] == 1 && count[1] == 0) ||\n                (w == 1 && count[0] == 0 && count[1] == 1) ||\n                (w == 0 && count[0] == 1 && count[1] == 1))\n                z <= 1'b1;\n            else\n                z <= 1'b0;\n            count <= 3'b000; // Reset the count after evaluating\n        end else if (state == B) begin\n            count <= {2'b00, w}; // Start counting w=1 instances\n        end else begin\n            z <= 1'b0;\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State declaration\n    typedef enum reg [1:0] {\n        STATE_A = 2'b00,\n        STATE_B0 = 2'b01,\n        STATE_B1 = 2'b10,\n        STATE_B2 = 2'b11\n    } state_t;\n\n    // State variables\n    reg [1:0] current_state, next_state;\n    reg [2:0] count_ones;\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= STATE_A;\n            count_ones <= 3'b000;\n        end else begin\n            current_state <= next_state;\n            if (current_state != STATE_A) begin\n                // Count the number of '1's in w input\n                count_ones <= count_ones + w;\n            end\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            STATE_A: begin\n                if (s == 1)\n                    next_state = STATE_B0;\n                else\n                    next_state = STATE_A;\n            end\n            STATE_B0: begin\n                next_state = STATE_B1;\n            end\n            STATE_B1: begin\n                next_state = STATE_B2;\n            end\n            STATE_B2: begin\n                next_state = STATE_B0; // Cycle back to B0 to continue checking w\n            end\n            default: begin\n                next_state = STATE_A;\n            end\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            z <= 0;\n        end else if (current_state == STATE_B2) begin\n            // Check if exactly two '1's have been detected\n            z <= (count_ones == 2);\n            count_ones <= 3'b000; // Reset count for the next cycle\n        end else begin\n            z <= 0;\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State definitions\n    localparam A = 2'b00, \n               B = 2'b01, \n               C = 2'b10, \n               D = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Counter for the number of 1's in w\n    reg [1:0] count_ones;\n\n    // State transition logic and counter logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= A;\n            count_ones <= 0;\n            z <= 0;\n        end else begin\n            current_state <= next_state;\n            case (current_state)\n                A: if (s) next_state <= B;\n                B: next_state <= C;\n                C: next_state <= D;\n                D: next_state <= B;  // Loop back to continue checking\n                default: next_state <= A;\n            endcase\n\n            // Count the number of ones in input w in states B, C, D\n            if (current_state == B || current_state == C || current_state == D) begin\n                if (w) count_ones <= count_ones + 1;\n            end\n\n            // Reset the count when moving back to B\n            if (current_state == D) begin\n                // Output logic based on count of ones\n                z <= (count_ones == 2) ? 1 : 0;\n                count_ones <= 0;  // Reset count for the next cycle\n            end\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input reset,\n    input s,\n    input w,\n    output reg z\n);\n    // State declaration\n    typedef enum reg [2:0] {\n        STATE_A = 3'b000,   // Initial reset state\n        STATE_B = 3'b001,   // Check w input\n        STATE_C = 3'b010,   // Check w input second time\n        STATE_D = 3'b011,   // Check w input third time\n        STATE_E = 3'b100    // Set output z based on previous inputs\n    } state_t;\n\n    // State variables\n    reg [2:0] state, next_state;\n    reg [2:0] count_ones; // Counter for how many times w is 1\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset) begin\n            state <= STATE_A;\n            count_ones <= 0;\n            z <= 0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic and output logic\n    always @(*) begin\n        case (state)\n            STATE_A: begin\n                if (s == 1)\n                    next_state = STATE_B;\n                else\n                    next_state = STATE_A;\n                z = 0;\n            end\n            STATE_B: begin\n                next_state = STATE_C;\n                count_ones = w;\n            end\n            STATE_C: begin\n                next_state = STATE_D;\n                count_ones = count_ones + w;\n            end\n            STATE_D: begin\n                next_state = STATE_E;\n                count_ones = count_ones + w;\n            end\n            STATE_E: begin\n                if (count_ones == 2)\n                    z = 1;\n                else\n                    z = 0;\n                next_state = STATE_B; // Loop back to continue checking w\n                count_ones = 0;       // Reset count for the next cycle\n            end\n            default: begin\n                next_state = STATE_A;\n                z = 0;\n                count_ones = 0;\n            end\n        endcase\n    end\nendmodule\n"]}
{"task_id": "vector4", "gptgen_RTL": ["module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[7]}}, in };\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\nassign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = { {24{in[7]}}, in };\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\nassign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\nassign out = { {24{in[7]}}, in };\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    // Sign-extend the 8-bit input to a 32-bit output by replicating the sign bit\n    assign out = {{24{in[7]}}, in};\n\nendmodule\n", "module top_module (\n    input [7:0] in,\n    output [31:0] out\n);\n\n    assign out = {{24{in[7]}}, in};\n\nendmodule\n"]}
{"task_id": "m2014_q4k", "gptgen_RTL": ["module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn)\n            shift_reg <= 4'b0;\n        else\n            shift_reg <= {shift_reg[2:0], in};\n    end\n\n    assign out = shift_reg[3];\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\nreg [3:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (!resetn) begin\n        // Synchronous reset when resetn is low\n        shift_reg <= 4'b0000;\n    end else begin\n        // Shift left and input new bit\n        shift_reg <= {shift_reg[2:0], in};\n    end\nend\n\n// Output the most significant bit\nassign out = shift_reg[3];\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) // active-low reset\n            shift_reg <= 4'b0000;\n        else\n            shift_reg <= {shift_reg[2:0], in}; // shift left and input 'in' on the right\n    end\n\n    assign out = shift_reg[3]; // output the left-most bit\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Synchronous reset on low resetn\n            shift_reg <= 4'b0000;\n        end else begin\n            // Shift left on each clock edge, input goes into LSB\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    // Output is taken from the MSB of the shift register\n    assign out = shift_reg[3];\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            shift_reg <= 4'b0000;\n        end else begin\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    assign out = shift_reg[3];\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    // Define the 4 D flip-flops\n    reg [3:0] shift_reg;\n\n    // Connect the output to the last flip-flop\n    assign out = shift_reg[3];\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Synchronous reset on negative logic (active low)\n            shift_reg <= 4'b0000;\n        end else begin\n            // Shift left on each clock edge, input goes into the first flip-flop\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input resetn,\n    input in,\n    output out\n);\n\n    // Declare shift register\n    reg [3:0] shift_reg;\n\n    always @(posedge clk) begin\n        if (!resetn) begin\n            // Active low synchronous reset\n            shift_reg <= 4'b0000;\n        end else begin\n            // Shift left and insert input on the right\n            shift_reg <= {shift_reg[2:0], in};\n        end\n    end\n\n    // Output the most significant bit\n    assign out = shift_reg[3];\n\nendmodule\n"]}
{"task_id": "fsm2", "gptgen_RTL": ["module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State Declaration\n    typedef enum {OFF, ON} state_type;\n    state_type current_state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            current_state <= OFF;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next State Logic based on current state and inputs\n    always @(*) begin\n        case(current_state)\n            OFF: begin\n                if (j == 1) \n                    next_state = ON;\n                else \n                    next_state = OFF;\n            end\n            ON: begin\n                if (k == 1)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF; // Default to OFF state\n        endcase\n    end\n\n    // Output Logic\n    always @(current_state) begin\n        case(current_state)\n            OFF: out = 0;\n            ON:  out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State Declaration\n    typedef enum {OFF, ON} state_t;\n    state_t current_state, next_state;\n\n    // State Transition Logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            current_state <= OFF; // Asynchronous reset to OFF state\n        else\n            current_state <= next_state;\n    end\n\n    // Next State Logic based on current state and inputs\n    always @(*) begin\n        case (current_state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n        default: next_state = OFF; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case (current_state)\n            OFF: out = 0;\n            ON: out = 1;\n        default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State Variable\n    reg state, next_state;\n\n    // State Register\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;\n        else\n            state <= next_state;\n    end\n\n    // Next State Logic\n    always @(*) begin\n        case(state)\n            OFF: next_state = j ? ON : OFF;\n            ON: next_state = k ? OFF : ON;\n        endcase\n    end\n\n    // Output Logic\n    always @(*) begin\n        case(state)\n            OFF: out = 1'b0;\n            ON: out = 1'b1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // Define state encoding\n    localparam OFF = 1'b0;\n    localparam ON  = 1'b1;\n\n    // Declare the state register\n    reg state, next_state;\n\n    // State register logic with asynchronous reset\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF; // Reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: begin\n                if (j)\n                    next_state = ON;\n                else\n                    next_state = OFF;\n            end\n            ON: begin\n                if (k)\n                    next_state = OFF;\n                else\n                    next_state = ON;\n            end\n            default: next_state = OFF;\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n            default: out = 1'b0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    parameter OFF = 0, ON = 1;\n    \n    // State register\n    reg state, next_state;\n    \n    // State transition logic\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= OFF;  // Asynchronous reset to OFF\n        else\n            state <= next_state;\n    end\n    \n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;\n            ON:  next_state = k ? OFF : ON;\n            default: next_state = OFF;\n        endcase\n    end\n    \n    // Output logic\n    always @(state) begin\n        case (state)\n            OFF: out = 0;\n            ON:  out = 1;\n        endcase\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // Define state encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic (Moore Machine)\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF; // Asynchronous reset to OFF\n        else\n            state <= next_state; // State transition\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case(state)\n            OFF: begin\n                if (j == 1'b1)\n                    next_state = ON; // Transition from OFF to ON\n                else\n                    next_state = OFF; // Remain in OFF\n            end\n            ON: begin\n                if (k == 1'b1)\n                    next_state = OFF; // Transition from ON to OFF\n                else\n                    next_state = ON; // Remain in ON\n            end\n            default: next_state = OFF; // Default case\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case(state)\n            OFF: out = 1'b0; // Output 0 in state OFF\n            ON: out = 1'b1; // Output 1 in state ON\n            default: out = 1'b0; // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n// State Encoding\nlocalparam OFF = 1'b0,\n           ON  = 1'b1;\n\n// State Variable\nreg state, next_state;\n\n// State Transition Logic\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        state <= OFF;\n    else\n        state <= next_state;\nend\n\n// Next State Logic\nalways @(*) begin\n    case (state)\n        OFF: next_state = j ? ON : OFF;\n        ON:  next_state = k ? OFF : ON;\n    endcase\nend\n\n// Output Logic\nalways @(*) begin\n    case (state)\n        OFF: out = 0;\n        ON:  out = 1;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n\n    // State encoding\n    localparam OFF = 1'b0;\n    localparam ON = 1'b1;\n\n    // State register\n    reg state;\n\n    // Next state logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;  // Asynchronous reset to OFF\n        end else begin\n            case (state)\n                OFF: state <= j ? ON : OFF;  // Transition from OFF to ON or stay OFF\n                ON: state <= k ? OFF : ON;   // Transition from ON to OFF or stay ON\n            endcase\n        end\n    end\n\n    // Output logic\n    always @(*) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // State Encoding\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            state <= OFF;\n            out <= 0;\n        end else begin\n            case (state)\n                OFF: begin\n                    if (j) begin\n                        state <= ON;\n                        out <= 1;\n                    end else begin\n                        state <= OFF;\n                        out <= 0;\n                    end\n                end\n                ON: begin\n                    if (k) begin\n                        state <= OFF;\n                        out <= 0;\n                    end else begin\n                        state <= ON;\n                        out <= 1;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n", "module top_module (\n    input clk,\n    input j,\n    input k,\n    input areset,\n    output reg out\n);\n    // Define state representation using parameters\n    parameter OFF = 1'b0, ON = 1'b1;\n\n    // State register\n    reg state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            state <= OFF;  // Asynchronous reset to OFF state\n        else\n            state <= next_state;\n    end\n\n    // Next state logic based on current state and inputs\n    always @(*) begin\n        case (state)\n            OFF: next_state = j ? ON : OFF;  // Transition from OFF to ON or stay in OFF\n            ON:  next_state = k ? OFF : ON;  // Transition from ON to OFF or stay in ON\n            default: next_state = OFF;       // Default case to handle unexpected states\n        endcase\n    end\n\n    // Output logic\n    always @(state) begin\n        case (state)\n            OFF: out = 1'b0;\n            ON:  out = 1'b1;\n        endcase\n    end\nendmodule\n"]}
{"task_id": "m2014_q4i", "gptgen_RTL": ["module top_module(\n    output out\n);\n\nassign out = 1'b0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 1'b0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 0;  // Constantly drive output to logic low\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 1'b0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\n// Assign 0 to the output\nassign out = 0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\nassign out = 0;\n\nendmodule\n", "module top_module(\n    output out\n);\n\n    assign out = 0;\n\nendmodule\n"]}
{"task_id": "step_one", "gptgen_RTL": ["module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;  // Constantly drive output 'one' to logic high\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n", "module top_module(\n    output one\n);\n\nassign one = 1'b1;\n\nendmodule\n"]}
{"task_id": "vector100r", "gptgen_RTL": ["module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\nalways @(*) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99-i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n    integer i;\n\n    always @(*) begin\n        for (i = 0; i < 100; i = i + 1) begin\n            out[i] = in[99 - i];\n        end\n    end\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\ninteger i;\n\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\nalways @(*) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99 - i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\nalways @(*) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\nalways @(*) begin\n    integer i;\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99 - i];\n    end\nend\n\nendmodule\n", "module top_module (\n    input [99:0] in,\n    output reg [99:0] out\n);\n\n// Reverse the bit ordering of the input vector\ninteger i;\nalways @(*) begin\n    for (i = 0; i < 100; i = i + 1) begin\n        out[i] = in[99-i];\n    end\nend\n\nendmodule\n"]}
{"task_id": "shift4", "gptgen_RTL": ["module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\n// On positive edge of clock or on assertion of asynchronous reset\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Asynchronous reset: set q to 0\n        q <= 4'b0000;\n    end\n    else if (load) begin\n        // Load data into the shift register\n        q <= data;\n    end\n    else if (ena) begin\n        // Enable shift right: shift register contents to the right\n        q <= {1'b0, q[3:1]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000; // Reset the shift register to zero\n    end \n    else if (load) begin\n        q <= data; // Load data into the shift register\n    end \n    else if (ena) begin\n        q <= {1'b0, q[3:1]}; // Shift right: q[3] becomes 0, q[2:0] shift right\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\n// Asynchronous reset or synchronous load/shift operations\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        // Asynchronous reset sets register to zero\n        q <= 4'b0000;\n    end else begin\n        if (load) begin\n            // Load data into register if load signal is high\n            q <= data;\n        end else if (ena) begin\n            // Enable signal allows for shifting the register to the right\n            q <= {1'b0, q[3:1]};\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end else if (load) begin\n            q <= data;\n        end else if (ena) begin\n            q <= {1'b0, q[3:1]};\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n    always @(posedge clk or posedge areset) begin\n        if (areset) begin\n            q <= 4'b0000;\n        end\n        else if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            q <= {1'b0, q[3:1]}; // Right shift operation\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end\n    else if (load) begin\n        q <= data;\n    end\n    else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input areset,\n    input load,\n    input ena,\n    input [3:0] data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 4'b0000;\n    end else if (load) begin\n        q <= data;\n    end else if (ena) begin\n        q <= {1'b0, q[3:1]};\n    end\nend\n\nendmodule\n"]}
{"task_id": "always_nolatches", "gptgen_RTL": ["module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\n    always @ (scancode) begin\n        // Initialize outputs to 0\n        left = 0;\n        down = 0;\n        right = 0;\n        up = 0;\n        \n        // Check the scancode and assert the corresponding output\n        case (scancode)\n            16'he06b: left = 1;\n            16'he072: down = 1;\n            16'he074: right = 1;\n            16'he075: up = 1;\n            default: begin\n                left = 0;\n                down = 0;\n                right = 0;\n                up = 0;\n            end\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @ (scancode) begin\n\t\t// Initialize outputs to 0\n\t\tleft = 0;\n\t\tdown = 0;\n\t\tright = 0;\n\t\tup = 0;\n\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\t\tdefault: begin\n\t\t\t\tleft = 0;\n\t\t\t\tdown = 0;\n\t\t\t\tright = 0;\n\t\t\t\tup = 0;\n\t\t\tend\n\t\tendcase\n\tend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode and update outputs\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'he06b: left = 1;  // Left arrow key\n        16'he072: down = 1;  // Down arrow key\n        16'he074: right = 1; // Right arrow key\n        16'he075: up = 1;    // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @ (scancode) begin\n    // Initialize outputs to 0 to ensure they are only high for the correct condition\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    case(scancode)\n        16'he06b: left = 1;    // Left arrow key\n        16'he072: down = 1;    // Down arrow key\n        16'he074: right = 1;   // Right arrow key\n        16'he075: up = 1;      // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize all outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check the scancode and set the corresponding output\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0 for the default case (no arrow keys pressed)\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    // Check the scancode and set the corresponding output\n    case (scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Initialize outputs to 0 (none of the arrows are pressed)\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n\n    // Check the scancode and assert the corresponding output\n    case(scancode)\n        16'he06b: left = 1;  // Left arrow key\n        16'he072: down = 1;  // Down arrow key\n        16'he074: right = 1; // Right arrow key\n        16'he075: up = 1;    // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\nalways @ (scancode) begin\n    // Initially, set all outputs to 0\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case (scancode)\n        16'he06b: left = 1;   // Left arrow key\n        16'he072: down = 1;   // Down arrow key\n        16'he074: right = 1;  // Right arrow key\n        16'he075: up = 1;     // Up arrow key\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [15:0] scancode,\n    output reg left,\n    output reg down,\n    output reg right,\n    output reg up\n);\n\nalways @(scancode) begin\n    // Default values\n    left = 0;\n    down = 0;\n    right = 0;\n    up = 0;\n    \n    case(scancode)\n        16'he06b: left = 1;\n        16'he072: down = 1;\n        16'he074: right = 1;\n        16'he075: up = 1;\n        default: begin\n            left = 0;\n            down = 0;\n            right = 0;\n            up = 0;\n        end\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "fadd", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n    // Intermediate signals for internal carry\n    wire sum_ab, carry_ab, carry_acin, carry_bcin;\n\n    // Adding first two bits\n    half_adder add_ab(.a(a), .b(b), .sum(sum_ab), .carry(carry_ab));\n    // Adding result with cin\n    half_adder add_acin(.a(sum_ab), .b(cin), .sum(sum), .carry(carry_acin));\n    \n    // Calculating final carry out\n    or(cout, carry_ab, carry_acin);\n\nendmodule\n\n// Half adder module used in the full adder\nmodule half_adder(\n    input a, \n    input b, \n    output sum, \n    output carry\n);\n    xor(sum, a, b);  // Sum without carry\n    and(carry, a, b); // Carry if both bits are 1\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals to store the sum and carry of a and b, and then the final sum with cin.\nwire sum_ab, carry_ab, carry_abc;\n\n// Adding a and b\nassign {carry_ab, sum_ab} = a + b;\n\n// Adding sum_ab with cin to get the final sum and the final carry out\nassign {carry_abc, sum} = sum_ab + cin;\n\n// The carry out is the OR of carry_ab and carry_abc\nassign cout = carry_ab | carry_abc;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin; // XOR for sum\nassign cout = (a & b) | (b & cin) | (cin & a); // Carry out\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate wires for the two half adders\nwire s1, c1, c2;\n\n// First half adder (adding a and b)\nassign s1 = a ^ b; // Sum of a and b\nassign c1 = a & b; // Carry of a and b\n\n// Second half adder (adding sum of first half adder and cin)\nassign sum = s1 ^ cin; // Final sum\nassign c2 = s1 & cin; // Carry of s1 and cin\n\n// Carry out is the OR of the two carries from the half adders\nassign cout = c1 | c2;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals for the two half-adder stages\nwire sum_half, carry_half1, carry_half2;\n\n// First half adder - adds a and b\nassign sum_half = a ^ b; // XOR for sum\nassign carry_half1 = a & b; // AND for carry\n\n// Second half adder - adds sum_half and cin (carry-in)\nassign sum = sum_half ^ cin; // Final sum\nassign carry_half2 = sum_half & cin; // Intermediate carry\n\n// OR gate to determine the final carry out\nassign cout = carry_half1 | carry_half2;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\n// Intermediate signals for the gates\nwire ab, a_xor_b, a_and_cin, b_and_cin;\n\n// XOR gate for input a and b\nassign a_xor_b = a ^ b;\n\n// AND gate for input a and b\nassign ab = a & b;\n\n// XOR gate for a_xor_b and cin - This is the sum output\nassign sum = a_xor_b ^ cin;\n\n// AND gates for intermediate carry operations\nassign a_and_cin = a_xor_b & cin;\nassign b_and_cin = ab;\n\n// OR gate for the final carry out\nassign cout = a_and_cin | b_and_cin;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    input cin,\n    output cout,\n    output sum\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n"]}
{"task_id": "always_case2", "gptgen_RTL": ["module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(in) begin\n        casez(in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0;\n            4'b0110: pos = 2'd1;\n            4'b1100: pos = 2'd2;\n            4'b0111: pos = 2'd0;\n            4'b1110: pos = 2'd1;\n            4'b1111: pos = 2'd0;\n            default: pos = 2'd0; // When all bits are 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    casez (in)\n        4'b0001: pos = 2'd0;\n        4'b0010: pos = 2'd1;\n        4'b01??: pos = 2'd2;\n        4'b1???: pos = 2'd3;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    casez(in)\n        4'b1???: pos = 2'd3;\n        4'b01??: pos = 2'd2;\n        4'b001?: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0; // Output 0 if all inputs are 0\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @ (in) begin\n    case (1'b1) // Priority encoding starting from the highest bit\n        in[3]: pos = 2'd3;\n        in[2]: pos = 2'd2;\n        in[1]: pos = 2'd1;\n        in[0]: pos = 2'd0;\n        default: pos = 2'd0; // When all bits are 0, output is 0\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        casez(in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0;\n            4'b0110: pos = 2'd1;\n            4'b1100: pos = 2'd2;\n            4'b0111: pos = 2'd0;\n            4'b1110: pos = 2'd1;\n            4'b1111: pos = 2'd0;\n            default: pos = 2'd0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b0001: pos = 2'd0;\n        4'b0010: pos = 2'd1;\n        4'b0100: pos = 2'd2;\n        4'b1000: pos = 2'd3;\n        4'b0011: pos = 2'd0; // In case of multiple 1's, priority is given to the rightmost 1.\n        4'b0110: pos = 2'd1; // Similarly, priority to the right.\n        4'b1100: pos = 2'd2; // And so on.\n        4'b0111: pos = 2'd0; // Priority to the rightmost 1.\n        4'b1110: pos = 2'd1; // Priority handling.\n        4'b1111: pos = 2'd0; // All ones, priority to the rightmost.\n        default: pos = 2'd0; // If none of the inputs are high.\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b1000: pos = 2'd3;\n        4'b0100: pos = 2'd2;\n        4'b0010: pos = 2'd1;\n        4'b0001: pos = 2'd0;\n        default: pos = 2'd0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        case (in)\n            4'b0001: pos = 2'd0;\n            4'b0010: pos = 2'd1;\n            4'b0100: pos = 2'd2;\n            4'b1000: pos = 2'd3;\n            4'b0011: pos = 2'd0; // Priority given to the rightmost '1'\n            4'b0110: pos = 2'd1; // Priority given to the rightmost '1'\n            4'b1100: pos = 2'd2; // Priority given to the rightmost '1'\n            4'b0111: pos = 2'd0; // Priority given to the rightmost '1'\n            4'b1110: pos = 2'd1; // Priority given to the rightmost '1'\n            4'b1111: pos = 2'd0; // Priority given to the rightmost '1'\n            default: pos = 2'd0; // If no bits are set, output is 0\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\nalways @(*) begin\n    case (in)\n        4'b0001: pos = 2'b00;\n        4'b0010: pos = 2'b01;\n        4'b0100: pos = 2'b10;\n        4'b1000: pos = 2'b11;\n        4'b0011: pos = 2'b00;\n        4'b0110: pos = 2'b01;\n        4'b1100: pos = 2'b10;\n        4'b0111: pos = 2'b00;\n        4'b1110: pos = 2'b01;\n        4'b1111: pos = 2'b00;\n        default: pos = 2'b00; // When in is 0 or any case not covered above\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input [3:0] in,\n    output reg [1:0] pos\n);\n\n    always @(*) begin\n        casez (in)\n            4'b1???: pos = 2'd3;\n            4'b01??: pos = 2'd2;\n            4'b001?: pos = 2'd1;\n            4'b0001: pos = 2'd0;\n            default: pos = 2'd0; // When all bits are 0, output is 0\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q4j", "gptgen_RTL": ["module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n// Intermediate carry bits\nwire [2:0] carry;\n\n// Full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(sum[4]) // This is the overflow bit\n);\n\nendmodule\n\n// Define the full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Sum calculation (XOR operation)\n    assign sum = a ^ b ^ cin;\n    // Carry out calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\nwire [3:0] carry; // Intermediate carry bits\n\n// First full adder (least significant bit)\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),    // No carry input for the first adder\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Second full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Third full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Fourth full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Carry output is the overflow bit\nassign sum[4] = carry[3];\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\nwire sum_intermediate, carry_intermediate_a, carry_intermediate_b;\n\n// Sum calculation\nxor xor1(sum_intermediate, a, b);\nxor xor2(sum, sum_intermediate, cin);\n\n// Carry calculation\nand and1(carry_intermediate_a, a, b);\nand and2(carry_intermediate_b, sum_intermediate, cin);\nor or1(cout, carry_intermediate_a, carry_intermediate_b);\n\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry;\n\n// full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry; // Internal wire to hold carry bits\n\n// Full adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry-in for the first bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// The carry out of the last full adder is the overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Definition of the full adder module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin; // XOR for sum\n    assign cout = (a & b) | (b & cin) | (a & cin); // Majority function for carry out\nendmodule\n", "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\nwire [3:0] carry; // Intermediate carry bits\n\n// First full adder\nfull_adder fa0 (\n\t.a(x[0]),\n\t.b(y[0]),\n\t.cin(1'b0),\n\t.sum(sum[0]),\n\t.cout(carry[0])\n);\n\n// Second full adder\nfull_adder fa1 (\n\t.a(x[1]),\n\t.b(y[1]),\n\t.cin(carry[0]),\n\t.sum(sum[1]),\n\t.cout(carry[1])\n);\n\n// Third full adder\nfull_adder fa2 (\n\t.a(x[2]),\n\t.b(y[2]),\n\t.cin(carry[1]),\n\t.sum(sum[2]),\n\t.cout(carry[2])\n);\n\n// Fourth full adder\nfull_adder fa3 (\n\t.a(x[3]),\n\t.b(y[3]),\n\t.cin(carry[2]),\n\t.sum(sum[3]),\n\t.cout(carry[3])\n);\n\n// Overflow bit is the carry out of the last full adder\nassign sum[4] = carry[3];\n\nendmodule\n\n// Definition of the full adder module used above\nmodule full_adder(\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput sum,\n\toutput cout\n);\n\tassign sum = a ^ b ^ cin; // Sum bit\n\tassign cout = (a & b) | (b & cin) | (cin & a); // Carry out\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire c0, c1, c2;\n\n// First full adder\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c0)\n);\n\n// Second full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c0),\n    .sum(sum[1]),\n    .cout(c1)\n);\n\n// Third full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c1),\n    .sum(sum[2]),\n    .cout(c2)\n);\n\n// Fourth full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c2),\n    .sum(sum[3]),\n    .cout(sum[4])\n);\n\nendmodule\n\n// Full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (cin & a);\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\n// Intermediate carries between full adders\nwire c0, c1, c2, c3;\n\n// Least significant bit full adder, no input carry (c0 is implicitly 0 here)\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0),\n    .sum(sum[0]),\n    .cout(c0)\n);\n\n// Second bit full adder\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(c0),\n    .sum(sum[1]),\n    .cout(c1)\n);\n\n// Third bit full adder\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(c1),\n    .sum(sum[2]),\n    .cout(c2)\n);\n\n// Most significant bit full adder\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(c2),\n    .sum(sum[3]),\n    .cout(c3)\n);\n\n// The overflow bit is the carry out of the most significant bit full adder\nassign sum[4] = c3;\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin; // Sum is the XOR of the inputs\n    assign cout = (a & b) | (b & cin) | (cin & a); // Carry out is generated if any two or more inputs are 1\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry; // Internal wires to hold the carry out of each full adder\n\n// Instantiate the full adder for the least significant bit\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry-in for the least significant bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Instantiate the full adder for the second bit\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Instantiate the full adder for the third bit\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Instantiate the full adder for the fourth bit\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// The fifth bit of the sum (sum[4]) should be the overflow bit, which is the carry out of the most significant full adder\nassign sum[4] = carry[3];\n\n// Full adder module definition\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Full adder logic\n    assign sum = a ^ b ^ cin; // Sum is the XOR of input bits and carry-in\n    assign cout = (a & b) | (b & cin) | (a & cin); // Carry out is generated if two or more inputs are high\nendmodule\n\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire [3:0] carry;\n\n// Full Adder for bit 0\nfull_adder fa0 (\n    .a(x[0]),\n    .b(y[0]),\n    .cin(1'b0), // No carry input for the least significant bit\n    .sum(sum[0]),\n    .cout(carry[0])\n);\n\n// Full Adder for bit 1\nfull_adder fa1 (\n    .a(x[1]),\n    .b(y[1]),\n    .cin(carry[0]),\n    .sum(sum[1]),\n    .cout(carry[1])\n);\n\n// Full Adder for bit 2\nfull_adder fa2 (\n    .a(x[2]),\n    .b(y[2]),\n    .cin(carry[1]),\n    .sum(sum[2]),\n    .cout(carry[2])\n);\n\n// Full Adder for bit 3\nfull_adder fa3 (\n    .a(x[3]),\n    .b(y[3]),\n    .cin(carry[2]),\n    .sum(sum[3]),\n    .cout(carry[3])\n);\n\n// Handling the overflow bit\nassign sum[4] = carry[3];\n\nendmodule\n\n// Full Adder Module\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    // Sum calculation\n    assign sum = a ^ b ^ cin;\n    // Carry out calculation\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n", "module top_module (\n    input [3:0] x,\n    input [3:0] y,\n    output [4:0] sum\n);\n\nwire c0, c1, c2, c3; // Carry outputs for each full adder\n\n// Instantiate full adders for each bit\nfull_adder fa0 (.a(x[0]), .b(y[0]), .cin(1'b0), .sum(sum[0]), .cout(c0));\nfull_adder fa1 (.a(x[1]), .b(y[1]), .cin(c0), .sum(sum[1]), .cout(c1));\nfull_adder fa2 (.a(x[2]), .b(y[2]), .cin(c1), .sum(sum[2]), .cout(c2));\nfull_adder fa3 (.a(x[3]), .b(y[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n\nassign sum[4] = c3; // The overflow bit\n\n// Definition of the full adder module\nmodule full_adder (\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\nwire s1, c1, c2;\n\n// Sum and carry out computation\nxor(s1, a, b);\nxor(sum, s1, cin);\nand(c1, a, b);\nand(c2, s1, cin);\nor(cout, c1, c2);\n\nendmodule\n\nendmodule\n"]}
{"task_id": "vector0", "gptgen_RTL": ["module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assign the input vector directly to the output vector\nassign outv = vec;\n\n// Split the input vector to individual bits\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Direct connection of input vector to output vector\nassign outv = vec;\n\n// Assigning individual bits of the input vector to separate outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec,\n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\nassign outv = vec;\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assigning the input vector to output vector directly\nassign outv = vec;\n\n// Splitting the input vector into three separate 1-bit outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n", "module top_module(\n    input [2:0] vec, \n    output [2:0] outv,\n    output o2,\n    output o1,\n    output o0\n);\n\n// Assign the entire vector to outv directly\nassign outv = vec;\n\n// Assign individual bits of the input vector to the separate outputs\nassign o2 = vec[2];\nassign o1 = vec[1];\nassign o0 = vec[0];\n\nendmodule\n"]}
{"task_id": "2012_q2b", "gptgen_RTL": ["module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1] and D by y[3]\n// Deriving Y1 (next state for state B, y[1]) based on current state and input w\nassign Y1 = (y[0] & w) | (y[2] & ~w);\n\n// Deriving Y3 (next state for state D, y[3]) based on current state and input w\nassign Y3 = (y[2] & w) | (y[5] & ~w) | (y[1] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// For Y1 (state B's input)\n// Transitions to B from A with w = 1\nassign Y1 = (y[0] & w);\n\n// For Y3 (state D's input)\n// Transitions to D from B with w = 0, from C with w = 0, and from E with w = 0\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// State A = 000001, B = 000010, C = 000100, D = 001000, E = 010000, F = 100000\n// Transition from A to B on w=1, hence Y1 should be high when in state A and w=1.\n// Transition from B to D on w=0, hence Y3 should be high when in state B and w=0.\n\n// Y1 corresponds to the input for state B's flip-flop\n// Y3 corresponds to the input for state D's flip-flop\n\nassign Y1 = (y[0] & w); // In state A (000001) and w=1, go to state B (000010)\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w); // In state B (000010) and w=0 or C (000100) and w=0 or E (010000) and w=0 or F (100000) and w=0, go to state D (001000)\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// One-hot state encoding\n// y[5:0] = 000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\n// Y1 corresponds to state B (000010)\n// Y1 should be 1 when:\n// - Current state is A (y[0] == 1) and w == 1 (A --1--> B)\n// - Current state is D (y[3] == 1) and w == 0 (D --0--> A --> B on next cycle, hence this transition will not directly influence Y1 for B)\n// No other transitions will set B (Y1) based on the given state diagram\n\nassign Y1 = (y[0] & w);\n\n// Y3 corresponds to state D (001000)\n// Y3 should be 1 when:\n// - Current state is B (y[1] == 1) and w == 0 (B --0--> D)\n// - Current state is C (y[2] == 1) and w == 0 (C --0--> D)\n// - Current state is E (y[4] == 1) and w == 0 (E --0--> D)\n// - Current state is F (y[5] == 1) and w == 0 (F --0--> D)\n\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1], and State D is represented by y[3].\n\n// For Y1 (input to flip-flop for state B), the transitions are:\n// A to B when w = 1, represented by y[0] & w.\n// D to B when w = 1, represented by y[3] & w.\n// Therefore, Y1 should be high for these transitions.\nassign Y1 = (y[0] & w) | (y[3] & w);\n\n// For Y3 (input to flip-flop for state D), the transitions are:\n// B to D when w = 0, represented by y[1] & ~w.\n// C to D when w = 0, represented by y[2] & ~w.\n// E to D when w = 0, represented by y[4] & ~w.\n// F to D when w = 0, represented by y[5] & ~w.\n// Therefore, Y3 should be high for these transitions.\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[4] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// For Y1 (input to state flip-flop y[1], which corresponds to state B)\n// From the state diagram:\n// A (0) --1--> B, thus when in state A (000001) and w is 1, Y1 should be 1.\n// B (0) --0--> D, does not directly relate to Y1 as the next state is D.\n// Therefore, only condition for Y1 to be 1 is when current state is A and w is 1.\n\nassign Y1 = y[0] & w;\n\n\n// For Y3 (input to state flip-flop y[3], which corresponds to state D)\n// From the state diagram:\n// B (0) --0--> D, thus when in state B (000010) and w is 0, Y3 should be 1.\n// C (0) --0--> D, thus when in state C (000100) and w is 0, Y3 should be 1.\n// E (1) --0--> D, thus when in state E (010000) and w is 0, Y3 should be 1.\n// F (1) --0--> D, thus when in state F (100000) and w is 0, Y3 should be 1.\n// Therefore, the condition for Y3 to be 1 is when current state is B, C, E, or F and w is 0.\n\nassign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule\n", "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\n// State B is represented by y[1] and State D by y[3]\n// From the state diagram, State B transitions to State D on a 0 input, which corresponds to Y3\n// Similarly, State D transitions to State A (y[0]) on a 0 input and to State F (y[5]) on a 1 input, neither directly influence Y1 as it represents State B\n// Thus, Y1's only change comes from State A (y[0]) transition to State B on a 1 input\n\n// Y1 becomes 1 if we're in State A and w is 1\nassign Y1 = y[0] & w;\n\n// Y3 becomes 1 in two cases:\n// 1. Transition from State B to State D on a 0 input => y[1] & ~w\n// 2. Transition from State C to State D on a 0 input => y[2] & ~w\n// Combining these two conditions for Y3\nassign Y3 = (y[1] | y[2]) & ~w;\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// State A to B (Y1) when w=1, B to E (Y3) when w=0\nassign Y1 = (y[0] & w) | (y[3] & ~w);\n// State B to D (Y3) when w=0, C to D (Y3) when w=0, F to D (Y3) when w=0\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (y[5] & ~w);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n// Calculating Y1 based on the state transition from A to B\nassign Y1 = (y[0] & w) | (y[2] & ~w);\n\n// Calculating Y3 based on the state transitions to D\nassign Y3 = (y[1] & ~w) | (y[2] & ~w) | (~w & y[4]) | (w & y[5]);\n\nendmodule\n", "module top_module (\n    input [5:0] y,\n    input w,\n    output Y1,\n    output Y3\n);\n\n    // For Y1, the transitions to state B (y[1]) are from:\n    // A to B (when w=1)\n    // So, Y1 should be high when we are in state A (y[0]) and w is 1.\n    assign Y1 = y[0] & w;\n\n    // For Y3, the transitions to state D (y[3]) are from:\n    // B to D (when w=0)\n    // C to D (when w=0)\n    // E to D (when w=0)\n    // F to D (when w=0)\n    // Thus, Y3 should be high when we are in state B, C, E, or F and w is 0, which corresponds to y[1], y[2], y[4], or y[5] respectively.\n    assign Y3 = (y[1] | y[2] | y[4] | y[5]) & ~w;\n\nendmodule\n"]}
{"task_id": "kmap4", "gptgen_RTL": ["module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100, // abcd = 0001, 0110, 1011, 1100 corresponds to 1\n        4'b0100, 4'b0011, 4'b1110, 4'b1001: // abcd = 0100, 0011, 1110, 1001 corresponds to 1\n            out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n\tcase({a, b, c, d})\n\t\t4'b0000, 4'b0011, 4'b1100, 4'b1111: out = 1'b0;\n\t\t4'b0001, 4'b0010, 4'b1101, 4'b1110: out = 1'b1;\n\t\t4'b0100, 4'b0111, 4'b1000, 4'b1011: out = 1'b1;\n\t\t4'b0101, 4'b0110, 4'b1001, 4'b1010: out = 1'b0;\n\t\tdefault: out = 1'bx; // Undefined case\n\tendcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @ (a or b or c or d) begin\n        case ({a, b, c, d})\n            4'b0001, 4'b0010, 4'b0111, 4'b0100, \n            4'b1011, 4'b1000, 4'b1101, 4'b1110: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b0101, 4'b1010, 4'b1001, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\n    always @(*) begin\n        case({a, b, c, d})\n            4'b0001, 4'b0110, 4'b1010, 4'b1101: out = 1;\n            4'b0010, 4'b0101, 4'b1001, 4'b1110: out = 1;\n            default: out = 0;\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @ (a or b or c or d) begin\n    case ({a, b, c, d})\n        4'b0001, 4'b0110, 4'b1010, 4'b1101: out = 1;\n        4'b0010, 4'b0101, 4'b1001, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @ (a or b or c or d) begin\n    case({a, b, c, d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100: out = 1;\n        4'b0100, 4'b1010, 4'b1111, 4'b1000: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b0101, 4'b1010, 4'b1000, 4'b1111: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input a, \n    input b,\n    input c,\n    input d,\n    output reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0110, 4'b1011, 4'b1100, // Cases where out = 1 based on the Karnaugh map\n        4'b0100, 4'b0011, 4'b1110, 4'b1001: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\nalways @(*) begin\n    case({a,b,c,d})\n        4'b0001, 4'b0010, 4'b0110, 4'b1001, 4'b1010, 4'b1110: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "m2014_q3", "gptgen_RTL": ["module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // Don't cares for 00 row\n            4'b0100: f = 0; // 01 00\n            4'b0101, 4'b0110, 4'b0111: f = 1'bx; // Don't cares for 01 row\n            4'b0110: f = 1; // 01 11\n            4'b0101: f = 0; // 01 10\n            4'b1100, 4'b1101: f = 1; // 11 00 and 11 01\n            4'b1110, 4'b1111: f = 1'bx; // Don't cares for 11 row\n            4'b1000, 4'b1001: f = 1; // 10 00 and 10 01\n            4'b1010: f = 0; // 10 10\n            4'b1011: f = 1'bx; // Don't care for 10 11\n            default: f = 1'bx; // Default case as a safe practice\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the K-map\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // Don't care conditions for 00 row\n            4'b0100: f = 0; // 01 row, 00 column\n            4'b0101: f = 1'bx; // Don't care condition\n            4'b0110: f = 1; // 01 row, 11 column\n            4'b0111: f = 0; // 01 row, 10 column\n            4'b1000, 4'b1001: f = 1; // 10 row, 00 and 01 columns\n            4'b1010: f = 0; // 10 row, 11 column\n            4'b1011: f = 1'bx; // Don't care condition\n            4'b1100, 4'b1101: f = 1; // 11 row, 00 and 01 columns\n            4'b1110, 4'b1111: f = 1'bx; // Don't care conditions for 11 row\n            default: f = 0; // Default case\n        endcase\n    end\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the function based on the Karnaugh map provided\n    assign f = (x[4:3] == 2'b11 & x[2:1] != 2'b10) | \n               (x[4:3] == 2'b10) |\n               (x[4:3] == 2'b01 & x[2:1] == 2'b11);\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implement the function based on the Karnaugh map given\n    always @(*) begin\n        case(x)\n            4'b0100: f = 0; // x[1]x[2]=00, x[3]x[4]=01\n            4'b0110: f = 1; // x[1]x[2]=10, x[3]x[4]=01\n            4'b0101: f = 0; // x[1]x[2]=01, x[3]x[4]=01\n            4'b1100: f = 1; // x[1]x[2]=00, x[3]x[4]=11\n            4'b1101: f = 1; // x[1]x[2]=01, x[3]x[4]=11\n            4'b1110: f = 0; // x[1]x[2]=10, x[3]x[4]=11\n            4'b1000: f = 1; // x[1]x[2]=00, x[3]x[4]=10\n            4'b1001: f = 1; // x[1]x[2]=01, x[3]x[4]=10\n            default: f = 0; // For all other cases including don't-care\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0101: f = 1; // x[4:1] = 0101\n            4'b0110: f = 0; // x[4:1] = 0110\n            4'b1100: f = 1; // x[4:1] = 1100\n            4'b1101: f = 1; // x[4:1] = 1101\n            4'b1010: f = 1; // x[4:1] = 1010\n            4'b1011: f = 1; // x[4:1] = 1011\n            default: f = 0; // Default to 0 for all other combinations and don't care conditions\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case(x)\n            4'b0100, 4'b0110, 4'b1110: f = 0;\n            4'b1100, 4'b1101, 4'b1111, 4'b0111: f = 1;\n            default: f = 0; // Assuming don't-cares as 0 for simplicity\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    // Implementing the function based on the Karnaugh map\n    assign f = (x[4:3] == 2'b11) | \n               (x[4:3] == 2'b01 & x[2] & ~x[1]) | \n               (x[4:3] == 2'b10);\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(x) begin\n        case (x)\n            4'b0100, 4'b0110, 4'b1100, 4'b1101, 4'b1000, 4'b1001: f = 1;\n            4'b0101, 4'b0111, 4'b1010, 4'b1011: f = 0;\n            default: f = 1'bx; // for don't care conditions\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n    always @(*) begin\n        case (x)\n            4'b0000, 4'b0001, 4'b0010, 4'b0011: f = 1'bx; // don't care for 00xx\n            4'b0100: f = 0; // 0100\n            4'b0101: f = 1'bx; // don't care for 0101\n            4'b0110: f = 1; // 0110\n            4'b0111: f = 0; // 0111\n            4'b1000, 4'b1001: f = 1; // 10xx\n            4'b1010: f = 1; // 1010\n            4'b1011: f = 1'bx; // don't care for 1011\n            4'b1100, 4'b1101, 4'b1110, 4'b1111: f = 1'bx; // don't care for 11xx\n            default: f = 0; // Default case\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input [4:1] x,\n    output logic f\n);\n\n// Simplifying the Karnaugh map, we derive the minimized boolean expression for f\n// After analyzing the Karnaugh map, the minimized expression for the function can be given as:\n// f = x[1]x[3] + x[2]x[3] + x[1]x[4]'\n\n    assign f = (x[1] & x[3]) | (x[2] & x[3]) | (x[1] & ~x[4]);\n\nendmodule\n"]}
{"task_id": "notgate", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n\tinput in,\n\toutput out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = ~in;\n\nendmodule\n"]}
{"task_id": "mux2to1v", "gptgen_RTL": ["module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n", "module top_module (\n    input [99:0] a,\n    input [99:0] b,\n    input sel,\n    output [99:0] out\n);\n\nassign out = sel ? b : a;\n\nendmodule\n"]}
{"task_id": "gates", "gptgen_RTL": ["module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n// (1) out_and: a and b\nassign out_and = a & b;\n\n// (2) out_or: a or b\nassign out_or = a | b;\n\n// (3) out_xor: a xor b\nassign out_xor = a ^ b;\n\n// (4) out_nand: a nand b\nassign out_nand = ~(a & b);\n\n// (5) out_nor: a nor b\nassign out_nor = ~(a | b);\n\n// (6) out_xnor: a xnor b\nassign out_xnor = ~(a ^ b);\n\n// (7) out_anotb: a and-not b\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\nassign out_and = a & b;\nassign out_or = a | b;\nassign out_xor = a ^ b;\nassign out_nand = ~(a & b);\nassign out_nor = ~(a | b);\nassign out_xnor = ~(a ^ b);\nassign out_anotb = a & ~b;\n\nendmodule\n", "module top_module (\n    input a,\n    input b,\n    output out_and,\n    output out_or,\n    output out_xor,\n    output out_nand,\n    output out_nor,\n    output out_xnor,\n    output out_anotb\n);\n\n    assign out_and = a & b;\n    assign out_or = a | b;\n    assign out_xor = a ^ b;\n    assign out_nand = ~(a & b);\n    assign out_nor = ~(a | b);\n    assign out_xnor = ~(a ^ b);\n    assign out_anotb = a & ~b;\n\nendmodule\n"]}
{"task_id": "7458", "gptgen_RTL": ["module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// For p1y: AND gates for three inputs\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\n// OR gate for the above AND gates\nassign p1y = and1_out | and2_out;\n\n// For p2y: AND gates for two inputs\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\n// OR gate for the above AND gates\nassign p2y = and3_out | and4_out;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// AND gates for p1y\nassign and1_out = p1a & p1b & p1c;\nassign and2_out = p1d & p1e & p1f;\n\n// OR gate for p1y\nassign p1y = and1_out | and2_out;\n\n// AND gates for p2y\nassign and3_out = p2a & p2b;\nassign and4_out = p2c & p2d;\n\n// OR gate for p2y\nassign p2y = and3_out | and4_out;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c; // 3-input AND gate\nassign and2 = p1d & p1e & p1f; // 3-input AND gate\n// OR gate for p1y\nassign p1y = and1 | and2;\n\n// AND gates for p2y\nassign and3 = p2a & p2b; // 2-input AND gate\nassign and4 = p2c & p2d; // 2-input AND gate\n// OR gate for p2y\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\n\n// AND gates for p2y\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\n// OR gates for outputs\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// First three-input AND gates for p1y\nassign and1 = p1a & p1b & p1c;\nassign and2 = p1d & p1e & p1f;\n\n// OR gate for p1y\nassign p1y = and1 | and2;\n\n// Two-input AND gates for p2y\nassign and3 = p2a & p2b;\nassign and4 = p2c & p2d;\n\n// OR gate for p2y\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\nassign and1 = p1a & p1b & p1c; // First 3-input AND gate for p1y\nassign and2 = p1d & p1e & p1f; // Second 3-input AND gate for p1y\nassign p1y = and1 | and2; // OR gate combining the two 3-input AND gates\n\nassign and3 = p2a & p2b; // First 2-input AND gate for p2y\nassign and4 = p2c & p2d; // Second 2-input AND gate for p2y\nassign p2y = and3 | and4; // OR gate combining the two 2-input AND gates\n\nendmodule\n", "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\nwire and1, and2, and3, and4;\n\n// Four AND gates for the intermediate signals\nassign and1 = p1a & p1b & p1c; // AND gate for p1a, p1b, and p1c\nassign and2 = p1d & p1e & p1f; // AND gate for p1d, p1e, and p1f\nassign and3 = p2a & p2b;       // AND gate for p2a and p2b\nassign and4 = p2c & p2d;       // AND gate for p2c and p2d\n\n// Two OR gates for the output signals\nassign p1y = and1 | and2;      // OR gate combining and1 and and2\nassign p2y = and3 | and4;      // OR gate combining and3 and and4\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// First 3-input AND gates for p1y\nassign and1 = p1a & p1b & p1c;\n// Second 3-input AND gate for p1y\nassign and2 = p1d & p1e & p1f;\n// First 2-input AND gate for p2y\nassign and3 = p2a & p2b;\n// Second 2-input AND gate for p2y\nassign and4 = p2c & p2d;\n\n// OR gates to produce final outputs\nassign p1y = and1 | and2;\nassign p2y = and3 | and4;\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1_out, and2_out, and3_out, and4_out;\n\n// For p1y output\nassign and1_out = p1a & p1b & p1c; // AND gate for p1a, p1b, and p1c\nassign and2_out = p1d & p1e & p1f; // AND gate for p1d, p1e, and p1f\nassign p1y = and1_out | and2_out;  // OR gate for the outputs of the two AND gates above\n\n// For p2y output\nassign and3_out = p2a & p2b; // AND gate for p2a and p2b\nassign and4_out = p2c & p2d; // AND gate for p2c and p2d\nassign p2y = and3_out | and4_out; // OR gate for the outputs of the two AND gates above\n\nendmodule\n", "module top_module(\n    input p1a, \n    input p1b, \n    input p1c, \n    input p1d,\n    input p1e,\n    input p1f,\n    output p1y, \n    input p2a, \n    input p2b, \n    input p2c, \n    input p2d, \n    output p2y\n);\n\nwire and1, and2, and3, and4;\n\n// AND gates for p1y\nassign and1 = p1a & p1b & p1c; // 3-input AND gate\nassign and2 = p1d & p1e & p1f; // 3-input AND gate\n// OR gate for p1y\nassign p1y = and1 | and2; // OR gate combining the outputs of the two 3-input AND gates\n\n// AND gates for p2y\nassign and3 = p2a & p2b; // 2-input AND gate\nassign and4 = p2c & p2d; // 2-input AND gate\n// OR gate for p2y\nassign p2y = and3 | and4; // OR gate combining the outputs of the two 2-input AND gates\n\nendmodule\n"]}
{"task_id": "wire", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n"]}
{"task_id": "m2014_q4e", "gptgen_RTL": ["module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n    input in1,\n    input in2,\n    output logic out\n);\n\n    assign out = ~(in1 | in2);\n\nendmodule\n", "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\nassign out = ~(in1 | in2);\n\nendmodule\n"]}
{"task_id": "m2014_q4h", "gptgen_RTL": ["module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n", "module top_module(\n    input in,\n    output out\n);\n\nassign out = in;\n\nendmodule\n"]}
{"task_id": "ece241_2013_q12", "gptgen_RTL": ["module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    // Shift register declaration\n    reg [7:0] shift_reg;\n\n    // Shifting operation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {S, shift_reg[7:1]};\n        end\n    end\n\n    // Multiplexer for selecting the output bit based on A, B, C\n    always @(*) begin\n        case ({A,B,C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // Should never occur\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shifting logic with enable\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Multiplexer logic for selecting the output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shift operation\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {shift_reg[6:0], S};\n    end\nend\n\n// Multiplexer for selecting output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'b0; // Default case\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] shift_reg; // 8-bit shift register\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            // Shift left operation, MSB is shifted in first\n            shift_reg <= {shift_reg[6:0], S};\n        end\n    end\n    \n    // Implementing the multiplexer logic for selecting the appropriate bit based on A, B, C\n    always @(*) begin\n        case({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // undefined behavior\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n// Shift register\nreg [7:0] Q;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        Q <= {S, Q[7:1]};\n    end\nend\n\n// Multiplexer\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = Q[0];\n        3'b001: Z = Q[1];\n        3'b010: Z = Q[2];\n        3'b011: Z = Q[3];\n        3'b100: Z = Q[4];\n        3'b101: Z = Q[5];\n        3'b110: Z = Q[6];\n        3'b111: Z = Q[7];\n        default: Z = 1'bx; // Undefined behavior\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    // Declare the shift register\n    reg [7:0] shift_reg;\n\n    // Shift register operation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {shift_reg[6:0], S};\n        end\n    end\n\n    // Determine the output Z based on the inputs A, B, and C\n    always @(*) begin\n        case({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bx; // undefined state\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register\nreg [7:0] shift_reg;\n\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Multiplexer logic for selecting output based on A, B, C\nalways @(*) begin\n    case({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'bx; // Undefined state\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n// 8-bit shift register declaration\nreg [7:0] shift_reg;\n\n// Shift register operation\nalways @(posedge clk) begin\n    if (enable) begin\n        shift_reg <= {S, shift_reg[7:1]};\n    end\nend\n\n// Mux for selecting the output based on A, B, C\nalways @(*) begin\n    case ({A, B, C})\n        3'b000: Z = shift_reg[0];\n        3'b001: Z = shift_reg[1];\n        3'b010: Z = shift_reg[2];\n        3'b011: Z = shift_reg[3];\n        3'b100: Z = shift_reg[4];\n        3'b101: Z = shift_reg[5];\n        3'b110: Z = shift_reg[6];\n        3'b111: Z = shift_reg[7];\n        default: Z = 1'bx; // Undefined state\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n\n    reg [7:0] shift_register;\n\n    // Shift register implementation\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_register <= {shift_register[6:0], S};\n        end\n    end\n\n    // Implementing the multiplexer for selecting the output based on A, B, C\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_register[0];\n            3'b001: Z = shift_register[1];\n            3'b010: Z = shift_register[2];\n            3'b011: Z = shift_register[3];\n            3'b100: Z = shift_register[4];\n            3'b101: Z = shift_register[5];\n            3'b110: Z = shift_register[6];\n            3'b111: Z = shift_register[7];\n            default: Z = 1'b0; // Default case to avoid latches\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input enable,\n    input S,\n    input A,\n    input B,\n    input C,\n    output reg Z\n);\n    reg [7:0] shift_reg; // 8-bit shift register\n\n    always @(posedge clk) begin\n        if (enable) begin\n            shift_reg <= {shift_reg[6:0], S}; // Shift left operation\n        end\n    end\n\n    always @(*) begin\n        case ({A, B, C})\n            3'b000: Z = shift_reg[0];\n            3'b001: Z = shift_reg[1];\n            3'b010: Z = shift_reg[2];\n            3'b011: Z = shift_reg[3];\n            3'b100: Z = shift_reg[4];\n            3'b101: Z = shift_reg[5];\n            3'b110: Z = shift_reg[6];\n            3'b111: Z = shift_reg[7];\n            default: Z = 1'bz; // High impedance for non-defined states\n        endcase\n    end\nendmodule\n"]}
{"task_id": "count1to10", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 if q is 10\n        else\n            q <= q + 1; // Increment q\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset counter to 1\n    end else if (q == 4'b1010) begin // When counter reaches 10\n        q <= 4'b0001; // Reset counter to 1\n    end else begin\n        q <= q + 1; // Increment counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Loop back to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // If reset is high, reset the counter to 1\n        q <= 4'b0001;\n    end\n    else begin\n        if (q == 4'b1010) begin\n            // If counter reaches 10, reset it to 1\n            q <= 4'b0001;\n        end\n        else begin\n            // Otherwise, increment the counter\n            q <= q + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'd1; // Reset the counter to 1\n    end\n    else if (q == 4'd10) begin\n        q <= 4'd1; // Reset to 1 after reaching 10\n    end\n    else begin\n        q <= q + 4'd1; // Increment the counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'b0001; // Reset counter to 1\n    else if (q == 4'b1010)\n        q <= 4'b0001; // Reset to 1 if the count reaches 10\n    else\n        q <= q + 1; // Increment counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 4'b0001; // Reset to 1\n    end\n    else if (q == 4'b1010) begin\n        q <= 4'b0001; // Wrap from 10 to 1\n    end\n    else begin\n        q <= q + 1; // Increment counter\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        q <= 4'd1; // Reset to 1, since the counter starts at 1\n    else if (q == 4'd10)\n        q <= 4'd1; // Reset to 1 after reaching 10\n    else\n        q <= q + 4'd1; // Increment counter\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (reset)\n            q <= 4'b0001; // Reset the counter to 1\n        else if (q == 4'b1010)\n            q <= 4'b0001; // Reset to 1 after reaching 10\n        else\n            q <= q + 1; // Increment the counter\n    end\nendmodule\n"]}
{"task_id": "fsm3s", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // Define state encoding\n    parameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n    // State registers\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_state <= A; // Reset to state A\n        else\n            current_state <= next_state;\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure deterministic output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State encoding\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= A;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on the current state and the input\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A;\n    endcase\nend\n\n// Output logic\nalways @(current_state) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state variables\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset to state A\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case(current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown state\n        endcase\n    end\n\n    // Output logic based on current state\n    always @(*) begin\n        case(current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n    // State Encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state declaration\n    state_t current_state, next_state;\n\n    // State transition and output logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            // Reset to state A\n            current_state <= A;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        case (current_state)\n            A: next_state = (in == 0) ? A : B;\n            B: next_state = (in == 0) ? C : B;\n            C: next_state = (in == 0) ? A : D;\n            D: next_state = (in == 0) ? C : B;\n            default: next_state = A; // Default case to avoid latches\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default case to ensure defined output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg out\n);\n\n// State encoding\nlocalparam A = 2'b00,\n           B = 2'b01,\n           C = 2'b10,\n           D = 2'b11;\n\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= A; // Reset to state A\n    else\n        current_state <= next_state;\nend\n\n// Next state logic based on the current state and the input\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A; // Default case to handle any undefined states\n    endcase\nend\n\n// Output logic for the Moore machine\nalways @(current_state) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default output\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // Current and Next state variables\n    state_t current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) current_state <= A; // Reset to state A\n        else current_state <= next_state;\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        // Default output\n        out = 0;\n        case (current_state)\n            A: begin\n                next_state = in ? B : A;\n                out = 0;\n            end\n            B: begin\n                next_state = in ? B : C;\n                out = 0;\n            end\n            C: begin\n                next_state = in ? D : A;\n                out = 0;\n            end\n            D: begin\n                next_state = in ? B : C;\n                out = 1; // Only state D has an output of 1\n            end\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n    // State encoding\n    typedef enum reg [1:0] {\n        A = 2'b00,\n        B = 2'b01,\n        C = 2'b10,\n        D = 2'b11\n    } state_t;\n\n    // State variables\n    reg [1:0] current_state, next_state;\n\n    // State transition logic\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_state <= A; // Reset state\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic based on current state and input\n    always @(*) begin\n        case (current_state)\n            A: next_state = in ? B : A;\n            B: next_state = in ? B : C;\n            C: next_state = in ? D : A;\n            D: next_state = in ? B : C;\n            default: next_state = A; // Default case to handle unknown states\n        endcase\n    end\n\n    // Output logic\n    always @(*) begin\n        case (current_state)\n            A: out = 0;\n            B: out = 0;\n            C: out = 0;\n            D: out = 1;\n            default: out = 0; // Default output\n        endcase\n    end\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput reg out\n);\n\n// State encoding\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) current_state <= A; // Synchronous reset to state A\n    else current_state <= next_state;\nend\n\n// Next state logic based on current state and input\nalways @(*) begin\n    case (current_state)\n        A: next_state = (in == 0) ? A : B;\n        B: next_state = (in == 0) ? C : B;\n        C: next_state = (in == 0) ? A : D;\n        D: next_state = (in == 0) ? C : B;\n        default: next_state = A; // Default case to handle unknown states\n    endcase\nend\n\n// Output logic - only dependent on current state in a Moore machine\nalways @(*) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default case to ensure output is defined\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State declaration\ntypedef enum reg[1:0] {\n    A = 2'b00,\n    B = 2'b01,\n    C = 2'b10,\n    D = 2'b11\n} state_t;\n\n// State variables\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= A; // Reset to state A\n    else\n        current_state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        A: next_state = in ? B : A;\n        B: next_state = in ? B : C;\n        C: next_state = in ? D : A;\n        D: next_state = in ? B : C;\n        default: next_state = A; // Default case\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        A: out = 0;\n        B: out = 0;\n        C: out = 0;\n        D: out = 1;\n        default: out = 0; // Default case\n    endcase\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    input reset,\n    output reg out\n);\n\n// State encoding\ntypedef enum reg[1:0] {\n    STATE_A = 2'b00,\n    STATE_B = 2'b01,\n    STATE_C = 2'b10,\n    STATE_D = 2'b11\n} state_t;\n\n// State registers\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        current_state <= STATE_A;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        STATE_A: next_state = (in == 0) ? STATE_A : STATE_B;\n        STATE_B: next_state = (in == 0) ? STATE_C : STATE_B;\n        STATE_C: next_state = (in == 0) ? STATE_A : STATE_D;\n        STATE_D: next_state = (in == 0) ? STATE_C : STATE_B;\n        default: next_state = STATE_A;\n    endcase\nend\n\n// Output logic\nalways @(*) begin\n    case (current_state)\n        STATE_A: out = 0;\n        STATE_B: out = 0;\n        STATE_C: out = 0;\n        STATE_D: out = 1;\n        default: out = 0;\n    endcase\nend\n\nendmodule\n"]}
{"task_id": "review2015_fsmshift", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// Define state constants\nlocalparam S0 = 2'd0, // State where shift_ena is not asserted\n           S1 = 2'd1, // First cycle of shift_ena being high\n           S2 = 2'd2, // Second cycle of shift_ena being high\n           S3 = 2'd3; // Third cycle of shift_ena being high\n\n// State registers\nreg [1:0] current_state, next_state;\n\n// Sequential logic for state transitioning\nalways @(posedge clk) begin\n    if (reset) current_state <= S1; // If reset, go to S1\n    else current_state <= next_state; // Otherwise, transition to the next state\nend\n\n// Combinatorial logic for next state logic and output logic\nalways @(*) begin\n    // Default values\n    next_state = S0; \n    shift_ena = 1'b0;\n    \n    case (current_state)\n        S0: begin\n            // Wait here until reset is asserted\n            next_state = reset ? S1 : S0;\n        end\n        S1: begin\n            shift_ena = 1'b1; // Assert shift_ena\n            next_state = S2; // Move to next state\n        end\n        S2: begin\n            shift_ena = 1'b1; // Keep shift_ena asserted\n            next_state = S3; // Move to next state\n        end\n        S3: begin\n            shift_ena = 1'b1; // Keep shift_ena asserted for the 3rd cycle\n            next_state = S0; // Return to initial state\n        end\n        default: begin\n            next_state = S0; // Default case, should not occur\n        end\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // State variable to count the 4 cycles\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset the state and enable the shift register\n        state <= 3'b000;\n        shift_ena <= 1'b1;\n    end\n    else if (state < 3'b100) begin\n        // Increment the state if it's less than 4\n        state <= state + 1'b1;\n        shift_ena <= 1'b1;\n    end\n    else begin\n        // After 4 cycles, keep the shift register disabled\n        shift_ena <= 1'b0;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State definitions\nlocalparam S_IDLE = 2'b00,\n           S_COUNT = 2'b01,\n           S_DONE = 2'b10;\n\n// State and count declaration\nreg [1:0] state, next_state;\nreg [2:0] count;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        state <= S_IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (state)\n        S_IDLE: next_state = reset ? S_IDLE : S_COUNT;\n        S_COUNT: next_state = (count == 3) ? S_DONE : S_COUNT;\n        S_DONE: next_state = S_DONE;\n        default: next_state = S_IDLE;\n    endcase\nend\n\n// Count logic\nalways @(posedge clk) begin\n    if (state == S_COUNT) begin\n        if (count < 3) begin\n            count <= count + 1;\n        end else begin\n            count <= count;\n        end\n    end else begin\n        count <= 0;\n    end\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 0;\n    end else begin\n        shift_ena <= (state == S_COUNT);\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State encoding\nlocalparam S0 = 2'b00, // State where shift_ena is not active\n           S1 = 2'b01, // State where shift_ena will be active for 1st cycle\n           S2 = 2'b10, // State where shift_ena will be active for 2nd cycle\n           S3 = 2'b11; // State where shift_ena will be active for 3rd and 4th cycles\n\nreg [1:0] current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if(reset) begin\n        current_state <= S1; // Move to S1 state upon reset\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case(current_state)\n        S0: next_state = S0; // Stay in S0 unless reset\n        S1: next_state = S2; // Transition to S2 after 1 cycle\n        S2: next_state = S3; // Transition to S3 after 2 cycles\n        S3: next_state = S0; // Transition to S0 after 4 cycles\n        default: next_state = S0; // Default case to handle unknown states\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if(reset) begin\n        shift_ena <= 1'b1; // Enable shift_ena upon reset\n    end else begin\n        // Enable shift_ena for 4 cycles after reset\n        case(current_state)\n            S1, S2, S3: shift_ena <= 1'b1;\n            default: shift_ena <= 1'b0;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nlocalparam S_IDLE = 2'b00,\n           S_COUNT1 = 2'b01,\n           S_COUNT2 = 2'b10,\n           S_COUNT3 = 2'b11;\n\nreg [1:0] current_state, next_state;\n\n// State transition\nalways @(posedge clk) begin\n    if (reset)\n        current_state <= S_IDLE;\n    else\n        current_state <= next_state;\nend\n\n// Next state logic and output logic\nalways @(*) begin\n    case (current_state)\n        S_IDLE: begin\n            if (reset) begin\n                next_state = S_COUNT1;\n                shift_ena = 1;\n            end else begin\n                next_state = S_IDLE;\n                shift_ena = 0;\n            end\n        end\n        S_COUNT1: begin\n            next_state = S_COUNT2;\n            shift_ena = 1;\n        end\n        S_COUNT2: begin\n            next_state = S_COUNT3;\n            shift_ena = 1;\n        end\n        S_COUNT3: begin\n            next_state = S_IDLE;\n            shift_ena = 1;\n        end\n        default: begin\n            next_state = S_IDLE;\n            shift_ena = 0;\n        end\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State encoding\nlocalparam S_WAIT = 2'b00, // Wait for reset or counting\n           S_COUNT = 2'b01; // Count 4 clock cycles\n\n// State and counter declaration\nreg [1:0] state = S_WAIT;\nreg [2:0] counter = 3'd0; // 3-bit counter to count up to 4\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // When reset is high, move to S_COUNT state and reset counter\n        state <= S_COUNT;\n        counter <= 3'd0;\n        shift_ena <= 1'b1;\n    end else begin\n        case (state)\n            S_WAIT: begin\n                // In wait state, keep shift_ena low\n                shift_ena <= 1'b0;\n            end\n            S_COUNT: begin\n                if (counter < 3'd4) begin\n                    // Increment counter until it reaches 4\n                    counter <= counter + 3'd1;\n                    shift_ena <= 1'b1; // Enable shifting\n                end else begin\n                    // After 4 cycles, go back to wait state and disable shift\n                    state <= S_WAIT;\n                    shift_ena <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // State to keep track of the 4 cycles\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // Reset condition - initializing states\n        shift_ena <= 1'b1; // Enable shift register for 4 cycles\n        state <= 3'b100; // Set state to track 4 cycles\n    end\n    else begin\n        if (state != 3'b000) begin\n            // If state is not 000, we are in the 4 cycle window\n            shift_ena <= 1'b1;\n            state <= state - 3'b001; // Decrement state to eventually reach 000\n        end\n        else begin\n            // Once state is 000, shift_ena is 0 forever until reset\n            shift_ena <= 1'b0;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State Declaration\ntypedef enum int {IDLE, ENABLE1, ENABLE2, ENABLE3, ENABLE4} state_t;\nstate_t current_state, next_state;\n\n// State Transition Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= IDLE;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next State Logic\nalways @(*) begin\n    case (current_state)\n        IDLE: next_state = ENABLE1;\n        ENABLE1: next_state = ENABLE2;\n        ENABLE2: next_state = ENABLE3;\n        ENABLE3: next_state = ENABLE4;\n        ENABLE4: next_state = IDLE;\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        shift_ena <= 1'b0;\n    end else begin\n        case (current_state)\n            ENABLE1, ENABLE2, ENABLE3, ENABLE4: shift_ena <= 1'b1;\n            default: shift_ena <= 1'b0;\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\n// State definitions\nlocalparam S0 = 2'b00; // Initial state\nlocalparam S1 = 2'b01; // Count state\nlocalparam S2 = 2'b10; // Last state to keep shift_ena high before turning it off\n\n// Signal declaration\nreg [1:0] current_state, next_state;\nreg [2:0] counter; // 3-bit counter to count up to 4 cycles\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: begin\n            if (reset) next_state = S1;\n            else next_state = S0;\n        end\n        S1: begin\n            if (counter == 3'b100) next_state = S2; // move to S2 after 4 cycles\n            else next_state = S1;\n        end\n        S2: begin\n            next_state = S2; // Stay in S2 until reset\n        end\n        default: next_state = S0;\n    endcase\nend\n\n// Counter and shift_ena logic\nalways @(posedge clk) begin\n    if (current_state == S0) begin\n        shift_ena <= 1'b0;\n        counter <= 3'b000;\n    end else if (current_state == S1) begin\n        shift_ena <= 1'b1;\n        counter <= counter + 3'b001;\n    end else if (current_state == S2) begin\n        shift_ena <= 1'b0; // Ensure shift_ena is turned off in S2\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg shift_ena\n);\n\nreg [2:0] state; // Using a 3-bit vector to count up to 4 clock cycles\n\n// State encoding\nlocalparam S0 = 3'b000, // Initial state or when reset\n           S1 = 3'b001, // Count state 1\n           S2 = 3'b010, // Count state 2\n           S3 = 3'b011, // Count state 3\n           S4 = 3'b100; // Count state 4, last state where shift_ena is high\n\nalways @(posedge clk) begin\n    if (reset) begin\n        // If reset is high, go back to initial state\n        state <= S0;\n    end else begin\n        case (state)\n            S0: begin\n                state <= S1; // Move to count state 1\n                shift_ena <= 1'b1; // Enable shift register\n            end\n            S1: begin\n                state <= S2; // Move to count state 2\n                shift_ena <= 1'b1; // Keep shift register enabled\n            end\n            S2: begin\n                state <= S3; // Move to count state 3\n                shift_ena <= 1'b1; // Keep shift register enabled\n            end\n            S3: begin\n                state <= S4; // Move to count state 4\n                shift_ena <= 1'b1; // Keep shift register enabled for the last time\n            end\n            S4: begin\n                // Do not change state, remain in S4\n                shift_ena <= 1'b0; // Disable shift register\n            end\n            default: begin\n                state <= S0; // Go to initial state for any undefined state\n                shift_ena <= 1'b0; // Ensure shift register is disabled\n            end\n        endcase\n    end\nend\n\nendmodule\n"]}
{"task_id": "conwaylife", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [2:0] neighbours;\nwire [255:0] next_state;\n\nalways @(posedge clk) begin\n    if (load) q <= data;\n    else q <= next_state;\nend\n\n// Calculate next state based on the current state\ngenerate\n    genvar x, y;\n    for (x = 0; x < 16; x = x + 1) begin: row\n        for (y = 0; y < 16; y = y + 1) begin: col\n            assign next_state[x*16+y] = next_state_logic(x, y);\n        end\n    end\nendgenerate\n\n// Logic to calculate the next state of a cell\nfunction next_state_logic(input [3:0] x, input [3:0] y);\n    integer nx, ny;\n    begin\n        neighbours = 0;\n        // Count neighbours, considering wrap around (toroid)\n        for (i = -1; i <= 1; i = i + 1) begin\n            for (j = -1; j <= 1; j = j + 1) begin\n                if (!(i == 0 && j == 0)) begin\n                    nx = (x + i + 16) % 16; // Wrap X\n                    ny = (y + j + 16) % 16; // Wrap Y\n                    neighbours = neighbours + q[nx*16+ny];\n                end\n            end\n        end\n        // Game logic\n        case(neighbours)\n            3'd0, 3'd1: next_state_logic = 1'b0; // 0-1 neighbour\n            3'd2: next_state_logic = q[x*16+y]; // 2 neighbours, no change\n            3'd3: next_state_logic = 1'b1; // 3 neighbours\n            default: next_state_logic = 1'b0; // 4+ neighbours\n        endcase\n    end\nendfunction\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n    integer i, j;\n    reg [7:0] neighbour_count;\n    wire [255:0] next_state;\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (i = 0; i < 16; i = i + 1) begin\n                for (j = 0; j < 16; j = j + 1) begin\n                    neighbour_count = q[{(i-1)&4'hF, (j+1)&4'hF}] + q[{i, (j+1)&4'hF}] + q[{(i+1)&4'hF, (j+1)&4'hF}] +\n                                      q[{(i-1)&4'hF, j}] +                                              q[{(i+1)&4'hF, j}] +\n                                      q[{(i-1)&4'hF, (j-1)&4'hF}] + q[{i, (j-1)&4'hF}] + q[{(i+1)&4'hF, (j-1)&4'hF}];\n                                      \n                    next_state[i*16+j] = (neighbour_count == 2) ? q[i*16+j] : \n                                         (neighbour_count == 3) ? 1'b1 : 1'b0;\n                end\n            end\n            q <= next_state;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [2:0] row_above, row_below, row;\nwire [7:0] neighbors;\nreg [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                // Determine rows considering the toroidal wraparound\n                row_above = (i == 0) ? q[240 + j*16 +: 3] : q[(i-1)*16 + j*16 +: 3];\n                row_below = (i == 15) ? q[j*16 +: 3] : q[(i+1)*16 + j*16 +: 3];\n                row = q[i*16 + j*16 +: 3];\n                \n                // Calculating neighbors, including wraparound considerations\n                neighbors = {row_above[2], row_above[1], row_above[0], row[0], row[2], row_below[2], row_below[1], row_below[0]};\n                \n                // Game rules\n                case (neighbors)\n                    8'b00000000, 8'b00000001: next_q[i*16 + j] = 0;\n                    8'b00000110, 8'b00000100: next_q[i*16 + j] = q[i*16 + j];\n                    8'b00000111: next_q[i*16 + j] = 1;\n                    default: next_q[i*16 + j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [7:0] neighbour_count;\nwire [255:0] next_q;\n\n// Function to calculate the neighbor count\nfunction automatic [7:0] calculate_neighbors;\n    input [7:0] row;\n    input [7:0] col;\n    integer r, c;\n    begin\n        calculate_neighbors = 0;\n        for (r = -1; r <= 1; r = r + 1) begin\n            for (c = -1; c <= 1; c = c + 1) begin\n                if (!(r == 0 && c == 0)) begin\n                    calculate_neighbors = calculate_neighbors + \n                        q[(((row + r + 16) % 16) * 16) + ((col + c + 16) % 16)];\n                end\n            end\n        end\n    end\nendfunction\n\n// Generate the next state based on the current state and the rules\nassign next_q = q; // Initialize next_q\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbour_count = calculate_neighbors(i, j);\n                \n                // Apply the game rules\n                case (neighbour_count)\n                    0, 1: next_q[(i*16) + j] <= 0;\n                    3: next_q[(i*16) + j] <= 1;\n                    4, 5, 6, 7, 8: next_q[(i*16) + j] <= 0;\n                    default: next_q[(i*16) + j] <= q[(i*16) + j]; // 2 Neighbors, do not change\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    // Temporary register to hold next state\n    reg [255:0] next_state;\n\n    // Function to calculate number of alive neighbors\n    function [3:0] count_neighbors;\n        input [7:0] x, y;\n        reg [7:0] nx, ny;\n        integer i, j;\n        begin\n            count_neighbors = 0;\n            for (i = -1; i <= 1; i = i + 1) begin\n                for (j = -1; j <= 1; j = j + 1) begin\n                    if (!(i == 0 && j == 0)) begin\n                        // Handle wrapping\n                        nx = (x + i + 16) % 16;\n                        ny = (y + j + 16) % 16;\n                        count_neighbors = count_neighbors + q[nx*16+ny];\n                    end\n                end\n            end\n        end\n    endfunction\n\n    integer x, y;\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end else begin\n            for (x = 0; x < 16; x = x + 1) begin\n                for (y = 0; y < 16; y = y + 1) begin\n                    case (count_neighbors(x, y))\n                        0, 1: next_state[x*16 + y] = 0;\n                        3: next_state[x*16 + y] = 1;\n                        2: next_state[x*16 + y] = q[x*16 + y];\n                        default: next_state[x*16 + y] = 0;\n                    endcase\n                end\n            end\n            q <= next_state;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\ninteger i, j;\nreg [7:0] neighbours;\nreg [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[{(i-1)&15, (j-1)&15}] + q[{(i-1)&15, j}] + q[{(i-1)&15, (j+1)&15}] +\n                             q[{i, (j-1)&15}] +                                    q[{i, (j+1)&15}] +\n                             q[{(i+1)&15, (j-1)&15}] + q[{(i+1)&15, j}] + q[{(i+1)&15, (j+1)&15}];\n                \n                case (neighbours)\n                    0, 1: next_q[i*16+j] = 0;\n                    2: next_q[i*16+j] = q[i*16+j];\n                    3: next_q[i*16+j] = 1;\n                    default: next_q[i*16+j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    integer i, j;\n    wire [255:0] next_state;\n    reg [7:0] neighbors;\n\n    // Function to calculate the next state of a cell\n    function automatic [0:0] next_cell_state;\n        input [7:0] neighbors;\n        input [0:0] current_state;\n        begin\n            case (neighbors)\n                0, 1: next_cell_state = 0;\n                2: next_cell_state = current_state;\n                3: next_cell_state = 1;\n                default: next_cell_state = 0;\n            endcase\n        end\n    endfunction\n\n    // Generate the next state for each cell\n    generate\n        for (i = 0; i < 16; i = i + 1) begin : row\n            for (j = 0; j < 16; j = j + 1) begin : col\n                // Calculate the position of each neighbor, taking into account the toroid behavior\n                wire [3:0] north = (i == 0) ? 15 : i - 1;\n                wire [3:0] south = (i == 15) ? 0 : i + 1;\n                wire [3:0] west = (j == 0) ? 15 : j - 1;\n                wire [3:0] east = (j == 15) ? 0 : j + 1;\n\n                // Count the number of alive neighbors\n                always @(*) begin\n                    neighbors = q[north*16+west] + q[north*16+j] + q[north*16+east] +\n                                q[i*16+west] /*current cell*/ + q[i*16+east] +\n                                q[south*16+west] + q[south*16+j] + q[south*16+east];\n\n                    // Subtract the current cell value since it was included in the count\n                    neighbors = neighbors - q[i*16+j];\n                end\n\n                // Determine the next state for each cell\n                assign next_state[i*16+j] = next_cell_state(neighbors, q[i*16+j]);\n            end\n        end\n    endgenerate\n\n    // Load new state or update the game state at each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_state;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q);\n\n    integer i, j;\n    reg [2:0] neighbour_count;\n    wire [255:0] next_q;\n    \n    // Function to calculate the 1D index from a 2D coordinate, with wrapping\n    function integer index_wrap;\n        input integer x, y;\n        begin\n            // Wrap coordinates around the edges\n            x = (x + 16) % 16;\n            y = (y + 16) % 16;\n            index_wrap = y * 16 + x;\n        end\n    endfunction\n\n    // Calculate the next state of each cell\n    generate\n        genvar idx;\n        for (idx = 0; idx < 256; idx = idx + 1) begin : cell_update\n            always @(*) begin\n                integer x, y;\n                x = idx % 16; // Extract x-coordinate\n                y = idx / 16; // Extract y-coordinate\n\n                // Count neighbours\n                neighbour_count = q[index_wrap(x-1, y-1)] + q[index_wrap(x, y-1)] + q[index_wrap(x+1, y-1)] +\n                                  q[index_wrap(x-1, y  )] +                          q[index_wrap(x+1, y  )] +\n                                  q[index_wrap(x-1, y+1)] + q[index_wrap(x, y+1)] + q[index_wrap(x+1, y+1)];\n\n                // Apply game rules\n                case(neighbour_count)\n                    3'b000, 3'b001: next_q[idx] = 1'b0; // Rule 1\n                    3'b010: next_q[idx] = q[idx];       // Rule 2\n                    3'b011: next_q[idx] = 1'b1;         // Rule 3\n                    default: next_q[idx] = 1'b0;        // Rule 4\n                endcase\n            end\n        end\n    endgenerate\n\n    // Load initial state or update state on each clock cycle\n    always @(posedge clk) begin\n        if (load)\n            q <= data;\n        else\n            q <= next_q;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [7:0] neighbours;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[{(i-1)%16, (j+1)%16}] + q[{i%16, (j+1)%16}] + q[{(i+1)%16, (j+1)%16}]\n                            + q[{(i-1)%16, j%16}]                                     + q[{(i+1)%16, j%16}]\n                            + q[{(i-1)%16, (j-1)%16}] + q[{i%16, (j-1)%16}] + q[{(i+1)%16, (j-1)%16}];\n                \n                case (neighbours)\n                    0, 1: q[i*16 + j] <= 0;\n                    2: q[i*16 + j] <= q[i*16 + j];\n                    3: q[i*16 + j] <= 1;\n                    default: q[i*16 + j] <= 0;\n                endcase\n            end\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input [255:0] data,\n    output reg [255:0] q\n);\n\ninteger i, j;\nreg [3:0] neighbours;\nwire [255:0] next_q;\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end else begin\n        for (i = 0; i < 16; i = i + 1) begin\n            for (j = 0; j < 16; j = j + 1) begin\n                neighbours = q[((i+15)%16)*16 + ((j+15)%16)] + q[((i+15)%16)*16 + (j)] + q[((i+15)%16)*16 + ((j+1)%16)]\n                            + q[(i)*16 + ((j+15)%16)]                                   + q[(i)*16 + ((j+1)%16)]\n                            + q[((i+1)%16)*16 + ((j+15)%16)] + q[((i+1)%16)*16 + (j)] + q[((i+1)%16)*16 + ((j+1)%16)];\n\n                case (neighbours)\n                    0, 1: next_q[i*16 + j] = 0;\n                    2: next_q[i*16 + j] = q[i*16 + j];\n                    3: next_q[i*16 + j] = 1;\n                    default: next_q[i*16 + j] = 0;\n                endcase\n            end\n        end\n        q <= next_q;\n    end\nend\n\nendmodule\n"]}
{"task_id": "m2014_q4d", "gptgen_RTL": ["module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop without reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nlogic xor_result;\n\n// XOR operation\nassign xor_result = in ^ out;\n\n// D Flip-Flop\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nwire xor_result;\n\n// XOR operation before D flip-flop\nassign xor_result = in ^ out;\n\n// D flip-flop without reset, positive edge triggered\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for XOR output\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop, positive edge triggered, no reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nreg temp;\n\nalways @(posedge clk) begin\n    temp <= in ^ out;\nend\n\nassign out = temp;\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n    wire xor_out;\n\n    // XOR operation\n    assign xor_out = in ^ out;\n\n    // D flip-flop without reset, positive edge triggered\n    always @(posedge clk) begin\n        out <= xor_out;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\nreg temp_out;\n\nalways @(posedge clk) begin\n    temp_out <= in ^ out;\nend\n\nassign out = temp_out;\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for XOR output\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop (No reset)\nalways_ff @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate signal for the output of the XOR gate\nlogic xor_out;\n\n// XOR operation\nassign xor_out = in ^ out;\n\n// D flip-flop with positive edge trigger, no reset\nalways @(posedge clk) begin\n    out <= xor_out;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input in,\n    output logic out\n);\n\n// Intermediate wire to hold the result of the XOR operation\nwire xor_result;\n\n// XOR operation between 'in' and the flip-flop output 'out'\nassign xor_result = in ^ out;\n\n// D flip-flop, no reset, positive edge triggered by clk\nalways @(posedge clk) begin\n    out <= xor_result;\nend\n\nendmodule\n"]}
{"task_id": "shift18", "gptgen_RTL": ["module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1; // shift left by 1\n            2'b01: q <= q << 8; // shift left by 8\n            2'b10: q <= {q[63], q[63:1]}; // arithmetic shift right by 1\n            2'b11: q <= {{8{q[63]}}, q[63:8]}; // arithmetic shift right by 8\n        endcase\n    end\nend\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n    );\n    \n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= $signed(q) >>> 1; // Arithmetic right shift by 1\n                2'b11: q <= $signed(q) >>> 8; // Arithmetic right shift by 8\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n    always @(posedge clk) begin\n        if (load) begin\n            // Load the data into the shift register\n            q <= data;\n        end\n        else if (ena) begin\n            // Perform shifting based on the amount\n            case (amount)\n                2'b00: begin // Shift left by 1\n                    q <= q << 1;\n                end\n                2'b01: begin // Shift left by 8\n                    q <= q << 8;\n                end\n                2'b10: begin // Shift right by 1, arithmetic shift\n                    q <= $signed(q) >>> 1;\n                end\n                2'b11: begin // Shift right by 8, arithmetic shift\n                    q <= $signed(q) >>> 8;\n                end\n                default: begin\n                    // Do nothing for undefined operation\n                end\n            endcase\n        end\n        // If neither load nor ena is active, retain the current value\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into the shift register.\n        q <= data;\n    end else if (ena) begin\n        // Shift or rotate based on the value of amount.\n        case (amount)\n            2'b00: begin\n                // Shift left by 1 bit.\n                q <= q << 1;\n            end\n            2'b01: begin\n                // Shift left by 8 bits.\n                q <= q << 8;\n            end\n            2'b10: begin\n                // Arithmetic shift right by 1 bit.\n                // Replicate the MSB (most significant bit) to keep the sign.\n                q <= {q[63], q[63:1]};\n            end\n            2'b11: begin\n                // Arithmetic shift right by 8 bits.\n                // Replicate the MSB (most significant bit) 8 times to keep the sign.\n                q <= { {8{q[63]}}, q[63:8]};\n            end\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if(load) begin\n        // Load the data into the shift register\n        q <= data;\n    end\n    else if(ena) begin\n        // Shift based on the amount\n        case(amount)\n            2'b00: q <= q << 1;  // Shift left by 1\n            2'b01: q <= q << 8;  // Shift left by 8\n            2'b10: q <= $signed(q) >>> 1;  // Arithmetic shift right by 1\n            2'b11: q <= $signed(q) >>> 8;  // Arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\nalways @(posedge clk) begin\n\tif (load) begin\n\t\tq <= data;\n\tend else if (ena) begin\n\t\tcase (amount)\n\t\t\t2'b00: q <= q << 1; // Shift left by 1\n\t\t\t2'b01: q <= q << 8; // Shift left by 8\n\t\t\t2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n\t\tendcase\n\tend\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load)\n            q <= data; // Load data into shift register\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n            endcase\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        // Load the data into the shift register\n        q <= data;\n    end\n    else if (ena) begin\n        case (amount)\n            2'b00: q <= q << 1; // Shift left by 1\n            2'b01: q <= q << 8; // Shift left by 8\n            2'b10: q <= {{q[63]}, q[63:1]}; // Arithmetic shift right by 1\n            2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q);\n\n    always @(posedge clk) begin\n        if (load) begin\n            q <= data;\n        end\n        else if (ena) begin\n            case (amount)\n                2'b00: q <= q << 1; // Shift left by 1\n                2'b01: q <= q << 8; // Shift left by 8\n                2'b10: q <= {q[63], q[63:1]}; // Arithmetic shift right by 1\n                2'b11: q <= {{8{q[63]}}, q[63:8]}; // Arithmetic shift right by 8\n            endcase\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input load,\n    input ena,\n    input [1:0] amount,\n    input [63:0] data,\n    output reg [63:0] q\n);\n\nalways @(posedge clk) begin\n    if (load) begin\n        q <= data;\n    end\n    else if (ena) begin\n        case(amount)\n        2'b00: q <= q << 1; // shift left by 1\n        2'b01: q <= q << 8; // shift left by 8\n        2'b10: q <= $signed(q) >>> 1; // arithmetic shift right by 1\n        2'b11: q <= $signed(q) >>> 8; // arithmetic shift right by 8\n        endcase\n    end\nend\n\nendmodule\n"]}
{"task_id": "review2015_fsmseq", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum reg[2:0] {\n    S0 = 3'b000, // Looking for first '1'\n    S1 = 3'b001, // Found first '1', looking for second '1'\n    S2 = 3'b010, // Found two '1's, looking for '0'\n    S3 = 3'b011, // Found \"110\", looking for '1'\n    S4 = 3'b100  // Sequence 1101 found, start_shifting = 1\n} state_t;\n\n// State variables\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        current_state <= S0;\n    else\n        current_state <= next_state;\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0; // If we see a '1', move to S1, else stay in S0\n        S1: next_state = data ? S2 : S0; // If we see another '1', move to S2, else back to S0\n        S2: next_state = data ? S1 : S3; // If we see a '1', back to S1 as it could be start of new sequence, else move to S3\n        S3: next_state = data ? S4 : S0; // If we see a '1', sequence complete, else back to S0\n        S4: next_state = S4; // Remain in this state once sequence is found\n        default: next_state = S0; // Default case\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset)\n        start_shifting <= 1'b0;\n    else if (current_state == S4)\n        start_shifting <= 1'b1;\n    // Note: No need to handle else condition as we want to latch the output to 1 once in S4\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S2 : S3;\n        S3: next_state = data ? S1 : S0;\n        FOUND: next_state = FOUND;\n        default: next_state = S0;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 0;\n    end else if (current_state == S3 && data) begin\n        start_shifting <= 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State Definitions\nlocalparam [2:0] S0 = 3'd0, // Initial State\n                 S1 = 3'd1, // Detected 1\n                 S2 = 3'd2, // Detected 11\n                 S3 = 3'd3, // Detected 110\n                 S4 = 3'd4; // Detected 1101, Start shifting\n\n// State Register\nreg [2:0] current_state, next_state;\n\n// State Transition Logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 1'b0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next State Logic\nalways @(*) begin\n    case (current_state)\n        S0: begin\n            if (data == 1'b1) \n                next_state = S1;\n            else\n                next_state = S0;\n        end\n        S1: begin\n            if (data == 1'b1) \n                next_state = S2;\n            else\n                next_state = S0;\n        end\n        S2: begin\n            if (data == 1'b0) \n                next_state = S3;\n            else\n                next_state = S2; // Stay in S2 if another 1 is detected\n        end\n        S3: begin\n            if (data == 1'b1) begin\n                next_state = S4;\n                start_shifting = 1'b1; // Sequence detected, start shifting\n            end else\n                next_state = S0;\n        end\n        S4: begin\n            // Once in S4, stay here indefinitely until reset\n            next_state = S4;\n            start_shifting = 1'b1;\n        end\n        default: next_state = S0; // Default to S0 for any undefined states\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum {S0, S1, S10, S110, S1101} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on current_state and data input\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S10 : S0;\n        S10: next_state = data ? S110 : S0;\n        S110: next_state = data ? S10 : S1101;\n        S1101: next_state = S1101; // Stay in this state once 1101 is detected\n        default: next_state = S0;\n    endcase\nend\n\n// Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 1'b0;\n    end else if (current_state == S110 && data == 1'b1) begin\n        start_shifting <= 1'b1; // Sequence 1101 detected\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State declaration\ntypedef enum int {\n    S0, // Initial state, looking for '1'\n    S1, // Found '1', looking for another '1'\n    S2, // Found \"11\", looking for '0'\n    S3  // Found \"110\", looking for '1' to complete \"1101\"\n} state_t;\n\n// State register\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 1'b0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S1 : S3;\n        S3: if (data) begin\n                start_shifting = 1'b1;\n                next_state = S1;\n            end else begin\n                next_state = S0;\n            end\n        default: next_state = S0;\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting);\n\n    reg [2:0] state, next_state;\n\n    // State encoding\n    localparam  S0 = 3'b000, // Looking for '1'\n                S1 = 3'b001, // 1 found, looking for first '1' in \"11\"\n                S2 = 3'b010, // \"11\" found, looking for '0'\n                S3 = 3'b011, // \"110\" found, looking for '1'\n                FOUND = 3'b100; // \"1101\" sequence found\n\n    // State transition logic\n    always @(posedge clk) begin\n        if (reset)\n            state <= S0;\n        else\n            state <= next_state;\n    end\n\n    // Next state logic\n    always @(*) begin\n        case(state)\n            S0: next_state = data ? S1 : S0;\n            S1: next_state = data ? S2 : S0;\n            S2: next_state = data ? S1 : S3;\n            S3: next_state = data ? FOUND : S0;\n            FOUND: next_state = FOUND;\n            default: next_state = S0;\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset)\n            start_shifting <= 0;\n        else if (state == FOUND)\n            start_shifting <= 1;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// FSM Logic - State transition\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// FSM Logic - Next state logic\nalways @(*) begin\n    case (current_state)\n        S0: next_state = data ? S1 : S0;\n        S1: next_state = data ? S2 : S0;\n        S2: next_state = data ? S2 : S3;\n        S3: next_state = data ? S1 : S0;\n        FOUND: next_state = FOUND;\n        default: next_state = S0;\n    endcase\nend\n\n// FSM Logic - Output logic\nalways @(posedge clk) begin\n    if (reset) begin\n        start_shifting <= 0;\n    end else begin\n        if (current_state == S3 && data) begin\n            start_shifting <= 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    typedef enum int {S0, S1, S2, S3, FOUND} state_t;\n    state_t current_state, next_state;\n\n    // State Transition\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always @(*) begin\n        // Default assignment\n        next_state = current_state;\n        \n        case (current_state)\n            S0: begin\n                if (data) next_state = S1;\n            end\n            S1: begin\n                if (data) next_state = S2;\n                else next_state = S0;\n            end\n            S2: begin\n                if (!data) next_state = S3;\n                // Stay in S2 if data is 1\n            end\n            S3: begin\n                if (data) next_state = FOUND;\n                else next_state = S0;  // Reset to S0 if sequence is broken\n            end\n            FOUND: begin\n                // Stay in FOUND state indefinitely until reset\n                next_state = FOUND;\n            end\n            default: next_state = S0;  // Default to S0 for any undefined states\n        endcase\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (reset) begin\n            start_shifting <= 0;\n        end else if (current_state == FOUND) begin\n            start_shifting <= 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n// State encoding\ntypedef enum int {S0, S1, S2, S3, FOUND} state_t;\nstate_t current_state, next_state;\n\n// State transition logic\nalways @(posedge clk) begin\n    if (reset) begin\n        current_state <= S0;\n        start_shifting <= 0;\n    end else begin\n        current_state <= next_state;\n    end\nend\n\n// Next state logic based on current state and input data\nalways @(*) begin\n    case (current_state)\n        S0: next_state = (data == 1'b1) ? S1 : S0;\n        S1: next_state = (data == 1'b1) ? S2 : S0;\n        S2: next_state = (data == 1'b0) ? S3 : S2;\n        S3: next_state = (data == 1'b1) ? FOUND : S0;\n        FOUND: begin\n            next_state = FOUND;\n            start_shifting = 1;\n        end\n        default: next_state = S0;\n    endcase\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    input data,\n    output reg start_shifting\n);\n\n    // State encoding\n    localparam S0 = 2'b00;\n    localparam S1 = 2'b01;\n    localparam S2 = 2'b10;\n    localparam S3 = 2'b11;\n\n    // State register\n    reg [1:0] current_state, next_state;\n\n    // Next state logic\n    always @(posedge clk) begin\n        if (reset) begin\n            current_state <= S0;\n            start_shifting <= 0;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state and output logic\n    always @(*) begin\n        case (current_state)\n            S0: begin\n                if (data == 1'b1) \n                    next_state = S1;\n                else \n                    next_state = S0;\n                start_shifting = 0;\n            end\n            S1: begin\n                if (data == 1'b1) \n                    next_state = S2;\n                else \n                    next_state = S0;\n                start_shifting = 0;\n            end\n            S2: begin\n                if (data == 1'b0) \n                    next_state = S3;\n                else \n                    next_state = S2; // Stay in S2 if another '1' is received\n                start_shifting = 0;\n            end\n            S3: begin\n                if (data == 1'b1) begin\n                    next_state = S3; // Once 1101 is detected, remain in S3\n                    start_shifting = 1;\n                end else \n                    next_state = S0;\n            end\n            default: begin\n                next_state = S0; // Default state\n                start_shifting = 0;\n            end\n        endcase\n    end\n\nendmodule\n"]}
{"task_id": "m2014_q4b", "gptgen_RTL": ["module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\n    always @(posedge clk or posedge ar)\n    begin\n        if (ar)\n            q <= 1'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar)\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n\tif (ar)\n\t\tq <= 1'b0;\n\telse\n\t\tq <= d;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input d,\n    input ar,\n    output logic q\n);\n\nalways @(posedge clk or posedge ar) begin\n    if (ar)\n        q <= 1'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "review2015_shiftcount", "gptgen_RTL": ["module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift in the data most-significant-bit first\n        q <= {data, q[3:1]};\n    end\n    else if (count_ena) begin\n        // Decrement the number in the register\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\n// Sequential logic with sensitivity to positive clock edges\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift left operation: MSB is replaced by 'data', other bits are shifted left\n        q <= {data, q[3:1]};\n    end\n    else if (count_ena) begin\n        // Decrement operation: Subtract 1 from current value of q\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if(shift_ena) begin\n            // Shift in the data. MSB first.\n            q <= {data, q[3:1]};\n        end\n        else if(count_ena) begin\n            // Decrement the number in the shift register.\n            q <= q - 1;\n        end\n    end\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if (shift_ena) begin\n        // Shift data in, MSB first\n        q <= {q[2:0], data};\n    end\n    else if (count_ena) begin\n        // Decrement the number in the shift register\n        q <= q - 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]}; // Shift in the data from MSB side\n        end\n        else if (count_ena) begin\n            q <= q - 1; // Decrement the value in the shift register\n        end\n    end\n    \nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    // Temporary register to handle decrement\n    reg [3:0] temp;\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift data into q, MSB first\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement current value in q\n            temp = q - 1;\n            q <= temp;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q);\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            // Shift in the data starting from MSB\n            q <= {q[2:0], data};\n        end\n        else if (count_ena) begin\n            // Decrement the value in the shift register\n            q <= q - 1;\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n    \n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]};  // Shift in the data from MSB\n        end\n        else if (count_ena) begin\n            q <= q - 1;  // Decrement the value in the register\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n    );\n\n    always @(posedge clk) begin\n        if (shift_ena) begin\n            q <= {data, q[3:1]}; // Shift in the data at MSB\n        end\n        else if (count_ena) begin\n            q <= q - 1; // Decrement the value\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input shift_ena,\n    input count_ena,\n    input data,\n    output reg [3:0] q\n);\n\nalways @(posedge clk) begin\n    if(shift_ena) begin\n        // Shift in the data most-significant-bit first\n        q <= {q[2:0], data};\n    end\n    else if(count_ena) begin\n        // Decrement the number in the shift register\n        q <= q - 1;\n    end\nend\n\nendmodule\n"]}
{"task_id": "dff8ar", "gptgen_RTL": ["module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if(areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        q <= 8'b0;\n    end else begin\n        q <= d;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) q <= 8'b0;\n    else q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge areset) begin\n        if (areset)\n            q <= 8'b0;\n        else\n            q <= d;\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) \n        q <= 8'b0;\n    else \n        q <= d;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input [7:0] d,\n    input areset,\n    output reg [7:0] q\n);\n\nalways @(posedge clk or posedge areset) begin\n    if(areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\n\nendmodule\n"]}
{"task_id": "lfsr32", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q);\n\n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset q to 1 if reset is high\n        end else begin\n            // Perform the Galois LFSR operation\n            // XOR the taps: 32, 22, 2, and 1 (considering 1-based indexing)\n            q <= {q[30:0], (q[31] ^ q[21] ^ q[1] ^ q[0])};\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset q to 32'h1 on a high reset\n    end else begin\n        // Galois LFSR implementation\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset the output to 32'h1 on a high reset signal\n    end\n    else begin\n        // Perform the Galois LFSR operation\n        // XOR the tapped bits with the rightmost bit (bit 0) and shift the register\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset value\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift and XOR for Galois LFSR\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n    \n    wire feedback = q[31] ^ q[21] ^ q[1] ^ q[0]; // XOR taps at positions 32, 22, 2, and 1 (adjusting for 0-indexing)\n    \n    always @(posedge clk) begin\n        if (reset) begin\n            q <= 32'h1; // Reset q to 32'h1\n        end else begin\n            q <= {q[30:0], feedback}; // Shift left by 1, placing feedback in the LSB position\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // On reset, set q to 32'h1\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift left with taps at 32, 22, 2, and 1 XORed for the new bit\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset the LFSR to 32'h1 when reset is high.\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]}; // Shift left with feedback from the XOR of the tap positions.\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1;\n    end else begin\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output reg [31:0] q\n);\n\n// On reset, set q to 32'h1, else shift and calculate new value based on taps\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 32'h1; // Reset value\n    end \n    else begin\n        // Shift q and apply XOR for taps at positions 32, 22, 2, and 1\n        // Note: Verilog indexing starts at 0, so we adjust positions by 1\n        q <= {q[30:0], q[31] ^ q[21] ^ q[1] ^ q[0]};\n    end\nend\n\nendmodule\n"]}
{"task_id": "2014_q4a", "gptgen_RTL": ["module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the register with R when L is asserted.\n    end\n    else if (E) begin\n        Q <= w; // Shift the register with w when E is asserted and L is not asserted.\n    end\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n\tif (L) begin\n\t\tQ <= R;\n\tend else if (E) begin\n\t\tQ <= w;\n\tend\nend\n\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n\tif (L) Q <= R;\n\telse if (E) Q <= w;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L)  // Load the value R when L is asserted\n        Q <= R;\n    else if (E)  // Shift the value when E is asserted\n        Q <= w;\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) \n        Q <= R; // Load the value of R into Q when L is asserted\n    else if (E) \n        Q <= w; // Shift the value when E is asserted, taking the input from w\n    // If neither L nor E are asserted, the value of Q remains unchanged\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) Q <= R; // Load the value R when L is asserted\n    else if (E) Q <= w; // Shift the value when E is asserted\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the value into Q when L is asserted\n    end\n    else if (E) begin\n        Q <= w; // Shift the value when E is asserted\n    end\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) // Load the value R when L is asserted.\n        Q <= R;\n    else if (E) // Enable shift operation.\n        Q <= w;\n    // If neither loading nor shifting, Q retains its value due to being a reg type.\nend\n\nendmodule\n", "module top_module (\n    input clk,\n    input w,\n    input R,\n    input E,\n    input L,\n    output reg Q\n);\n    always @(posedge clk) begin\n        if (L) begin\n            Q <= R; // Load the value of R into Q when L is asserted\n        end\n        else if (E) begin\n            Q <= w; // Shift in the value of w when E is asserted and L is not\n        end\n    end\nendmodule\n", "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\nalways @(posedge clk) begin\n    if (L) begin\n        Q <= R; // Load the value of R into Q when L is asserted\n    end\n    else if (E) begin\n        Q <= w; // Otherwise, shift the value of w into Q when E is asserted\n    end\nend\n\nendmodule\n"]}
{"task_id": "alwaysblock2", "gptgen_RTL": ["module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for XOR gate\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR gate\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR gate with a flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement\nassign out_assign = a ^ b;\n\n// Combinational always block\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Clocked always block with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// XOR using an assign statement\nassign out_assign = a ^ b;\n\n// XOR using a combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// XOR using a clocked always block with flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for immediate XOR operation\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR operation\nalways @ (a or b)\nbegin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR operation with flip-flop\n// This introduces a one-clock cycle delay\nalways @ (posedge clk)\nbegin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// XOR using assign statement\nassign out_assign = a ^ b;\n\n// XOR using combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// XOR using clocked always block with flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using assign statement for XOR gate\nassign out_assign = a ^ b;\n\n// Using combinational always block for XOR gate\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using clocked always block for XOR gate with a flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement for XOR\nassign out_assign = a ^ b;\n\n// Using a combinational always block for XOR\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block for XOR with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement for direct XOR operation\nassign out_assign = a ^ b;\n\n// Using a combinational always block\nalways @ (a or b) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with a flip-flop\nalways @ (posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input a, \n    input b,\n    output out_assign,\n    output reg out_always_comb,\n    output reg out_always_ff\n);\n\n// Using an assign statement\nassign out_assign = a ^ b;\n\n// Using a combinational always block\nalways @(*) begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with flip-flop\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\n// Using an assign statement for immediate XOR operation\nassign out_assign = a ^ b;\n\n// Using a combinational always block for XOR operation\nalways @* begin\n    out_always_comb = a ^ b;\nend\n\n// Using a clocked always block with a flip-flop to produce a delayed XOR operation\nalways @(posedge clk) begin\n    out_always_ff <= a ^ b;\nend\n\nendmodule\n"]}
{"task_id": "countbcd", "gptgen_RTL": ["module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for each BCD digit beyond the first\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens when ones is 9\nassign ena[2] = ena[1] && (q[7:4] == 4'b1001); // Enable hundreds when tens is 9 and ena[1] is high\nassign ena[3] = ena[2] && (q[11:8] == 4'b1001); // Enable thousands when hundreds is 9 and ena[2] is high\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0; // Reset the counter to 0\n    end else begin\n        if (q[3:0] == 4'b1001) begin // Ones digit\n            q[3:0] <= 4'b0; // Reset ones to 0\n            if (q[7:4] == 4'b1001) begin // Tens digit\n                q[7:4] <= 4'b0; // Reset tens to 0\n                if (q[11:8] == 4'b1001) begin // Hundreds digit\n                    q[11:8] <= 4'b0; // Reset hundreds to 0\n                    if (q[15:12] == 4'b1001) begin // Thousands digit\n                        q[15:12] <= 4'b0; // Reset thousands to 0 if it is 9\n                    end else begin\n                        q[15:12] <= q[15:12] + 1'b1; // Increment thousands\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1'b1; // Increment hundreds\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1'b1; // Increment tens\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1'b1; // Increment ones\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q\n);\n\n// Assign enable signals for each of the upper three digits\nassign ena[1] = (q[3:0] == 9) ? 1'b1 : 1'b0; // Enable tens when ones digit reaches 9\nassign ena[2] = (q[7:4] == 9) && ena[1] ? 1'b1 : 1'b0; // Enable hundreds when tens digit is 9 and ena[1] is high\nassign ena[3] = (q[11:8] == 9) && ena[2] ? 1'b1 : 1'b0; // Enable thousands when hundreds digit is 9 and ena[2] is high\n\nalways @(posedge clk or posedge reset) begin\n\tif (reset) begin\n\t\t// Reset the counter\n\t\tq <= 16'd0;\n\tend else begin\n\t\t// Increment the ones digit\n\t\tif (q[3:0] < 9) begin\n\t\t\tq[3:0] <= q[3:0] + 1'b1;\n\t\tend else begin\n\t\t\tq[3:0] <= 4'd0; // Reset ones digit to 0 and check for tens digit\n\t\t\t// Increment the tens digit\n\t\t\tif (q[7:4] < 9) begin\n\t\t\t\tq[7:4] <= q[7:4] + 1'b1;\n\t\t\tend else begin\n\t\t\t\tq[7:4] <= 4'd0; // Reset tens digit to 0 and check for hundreds digit\n\t\t\t\t// Increment the hundreds digit\n\t\t\t\tif (q[11:8] < 9) begin\n\t\t\t\t\tq[11:8] <= q[11:8] + 1'b1;\n\t\t\t\tend else begin\n\t\t\t\t\tq[11:8] <= 4'd0; // Reset hundreds digit to 0 and check for thousands digit\n\t\t\t\t\t// Increment the thousands digit\n\t\t\t\t\tif (q[15:12] < 9) begin\n\t\t\t\t\t\tq[15:12] <= q[15:12] + 1'b1;\n\t\t\t\t\tend else begin\n\t\t\t\t\t\tq[15:12] <= 4'd0; // Reset thousands digit to 0, overflow case\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for each digit\nassign ena[1] = (q[3:0] == 9);  // Enable tens when ones are 9\nassign ena[2] = (q[7:4] == 9) && ena[1]; // Enable hundreds when tens are 9 and ones are 9\nassign ena[3] = (q[11:8] == 9) && ena[2]; // Enable thousands when hundreds are 9 and tens are 9\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0; // Reset the counter\n    end else begin\n        // Increment ones\n        if (q[3:0] == 9) q[3:0] <= 0;\n        else q[3:0] <= q[3:0] + 1;\n        \n        // Increment tens\n        if (ena[1]) begin\n            if (q[7:4] == 9) q[7:4] <= 0;\n            else q[7:4] <= q[7:4] + 1;\n        end\n        \n        // Increment hundreds\n        if (ena[2]) begin\n            if (q[11:8] == 9) q[11:8] <= 0;\n            else q[11:8] <= q[11:8] + 1;\n        end\n        \n        // Increment thousands\n        if (ena[3]) begin\n            if (q[15:12] == 9) q[15:12] <= 0;\n            else q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk) begin\n    if (reset) begin\n        q <= 16'd0;\n    end else begin\n        if (q[3:0] == 9) begin\n            q[3:0] <= 0;\n            if (q[7:4] == 9) begin\n                q[7:4] <= 0;\n                if (q[11:8] == 9) begin\n                    q[11:8] <= 0;\n                    if (q[15:12] == 9) begin\n                        q[15:12] <= 0;\n                    end else begin\n                        q[15:12] <= q[15:12] + 1;\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1;\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1;\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1;\n        end\n    end\nend\n\nassign ena[1] = (q[3:0] == 9) ? 1'b1 : 1'b0;\nassign ena[2] = (q[3:0] == 9 && q[7:4] == 9) ? 1'b1 : 1'b0;\nassign ena[3] = (q[3:0] == 9 && q[7:4] == 9 && q[11:8] == 9) ? 1'b1 : 1'b0;\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q);\n\n    // Enable signals for tens, hundreds, and thousands\n    assign ena[1] = (q[3:0] == 9);  // Enable tens when ones is 9\n    assign ena[2] = ena[1] && (q[7:4] == 9);  // Enable hundreds when tens is 9 and ones is 9\n    assign ena[3] = ena[2] && (q[11:8] == 9);  // Enable thousands when hundreds is 9, tens is 9 and ones is 9\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;  // Reset the counter to 0\n        end\n        else begin\n            if (q[3:0] == 9) begin\n                q[3:0] <= 0;  // Reset ones to 0 if it was 9\n                if (q[7:4] == 9) begin\n                    q[7:4] <= 0;  // Reset tens to 0 if it was 9\n                    if (q[11:8] == 9) begin\n                        q[11:8] <= 0;  // Reset hundreds to 0 if it was 9\n                        if (q[15:12] == 9) begin\n                            q[15:12] <= 0;  // Reset thousands to 0 if it was 9 (roll over scenario)\n                        end else begin\n                            q[15:12] <= q[15:12] + 1;  // Increment thousands\n                        end\n                    end else begin\n                        q[11:8] <= q[11:8] + 1;  // Increment hundreds\n                    end\n                end else begin\n                    q[7:4] <= q[7:4] + 1;  // Increment tens\n                end\n            end else begin\n                q[3:0] <= q[3:0] + 1;  // Increment ones\n            end\n        end\n    end\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable logic for the tens, hundreds, and thousands digits\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens when ones is 9\nassign ena[2] = (q[7:4] == 4'b1001) & ena[1]; // Enable hundreds when tens is 9 and ones rolls over\nassign ena[3] = (q[11:8] == 4'b1001) & ena[2]; // Enable thousands when hundreds is 9 and tens rolls over\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        // Reset all digits to 0\n        q <= 16'b0; \n    end else begin\n        // Increment ones digit\n        if (q[3:0] == 4'b1001) q[3:0] <= 4'b0; // Reset to 0 if 9\n        else q[3:0] <= q[3:0] + 1;\n        \n        // Increment tens digit\n        if (ena[1]) begin\n            if (q[7:4] == 4'b1001) q[7:4] <= 4'b0; // Reset to 0 if 9\n            else q[7:4] <= q[7:4] + 1;\n        end\n\n        // Increment hundreds digit\n        if (ena[2]) begin\n            if (q[11:8] == 4'b1001) q[11:8] <= 4'b0; // Reset to 0 if 9\n            else q[11:8] <= q[11:8] + 1;\n        end\n\n        // Increment thousands digit\n        if (ena[3]) begin\n            if (q[15:12] == 4'b1001) q[15:12] <= 4'b0; // Reset to 0 if 9\n            else q[15:12] <= q[15:12] + 1;\n        end\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for the tens, hundreds, and thousands digits\nassign ena[1] = (q[3:0] == 9); // Enable tens when ones is 9\nassign ena[2] = ena[1] && (q[7:4] == 9); // Enable hundreds when tens is 9 and ones is about to reset\nassign ena[3] = ena[2] && (q[11:8] == 9); // Enable thousands when hundreds is 9 and tens is about to reset\n\n// Ones counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[3:0] <= 0;\n    else if (q[3:0] == 9)\n        q[3:0] <= 0;\n    else\n        q[3:0] <= q[3:0] + 1;\nend\n\n// Tens counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[7:4] <= 0;\n    else if (ena[1]) begin\n        if (q[7:4] == 9)\n            q[7:4] <= 0;\n        else\n            q[7:4] <= q[7:4] + 1;\n    end\nend\n\n// Hundreds counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[11:8] <= 0;\n    else if (ena[2]) begin\n        if (q[11:8] == 9)\n            q[11:8] <= 0;\n        else\n            q[11:8] <= q[11:8] + 1;\n    end\nend\n\n// Thousands counter\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q[15:12] <= 0;\n    else if (ena[3]) begin\n        if (q[15:12] == 9)\n            q[15:12] <= 0;\n        else\n            q[15:12] <= q[15:12] + 1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Increment the ones digit and generate enable for the tens digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[3:0] <= 4'd0;\n    end else if (q[3:0] == 4'd9) begin\n        q[3:0] <= 4'd0;\n    end else begin\n        q[3:0] <= q[3:0] + 1'b1;\n    end\nend\n\nassign ena[1] = (q[3:0] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the tens digit and generate enable for the hundreds digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[7:4] <= 4'd0;\n    end else if (ena[1] && q[7:4] == 4'd9) begin\n        q[7:4] <= 4'd0;\n    end else if (ena[1]) begin\n        q[7:4] <= q[7:4] + 1'b1;\n    end\nend\n\nassign ena[2] = (ena[1] && q[7:4] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the hundreds digit and generate enable for the thousands digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[11:8] <= 4'd0;\n    end else if (ena[2] && q[11:8] == 4'd9) begin\n        q[11:8] <= 4'd0;\n    end else if (ena[2]) begin\n        q[11:8] <= q[11:8] + 1'b1;\n    end\nend\n\nassign ena[3] = (ena[2] && q[11:8] == 4'd9) ? 1'b1 : 1'b0;\n\n// Increment the thousands digit\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q[15:12] <= 4'd0;\n    end else if (ena[3] && q[15:12] == 4'd9) begin\n        q[15:12] <= 4'd0;\n    end else if (ena[3]) begin\n        q[15:12] <= q[15:12] + 1'b1;\n    end\nend\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 16'b0;\n    end else begin\n        // Increment the ones digit\n        if (q[3:0] == 4'b1001) begin // If ones digit is 9, reset it to 0 and enable tens increment\n            q[3:0] <= 4'b0000;\n            q[7:4] <= q[7:4] + 1'b1; // Increment tens\n        end else begin\n            q[3:0] <= q[3:0] + 1'b1; // Increment ones\n        end\n        \n        // Check for tens carry and increment hundreds\n        if (q[7:4] == 4'b1010) begin // If tens digit reaches 10, reset it to 0 and enable hundreds increment\n            q[7:4] <= 4'b0000;\n            q[11:8] <= q[11:8] + 1'b1; // Increment hundreds\n        end\n        \n        // Check for hundreds carry and increment thousands\n        if (q[11:8] == 4'b1010) begin // If hundreds digit reaches 10, reset it to 0 and enable thousands increment\n            q[11:8] <= 4'b0000;\n            q[15:12] <= q[15:12] + 1'b1; // Increment thousands\n        end\n        \n        // Check for thousands carry\n        if (q[15:12] == 4'b1010) begin // If thousands digit reaches 10, reset it to 0\n            q[15:12] <= 4'b0000;\n        end\n    end\nend\n\n// Enable signals logic\nassign ena[1] = (q[3:0] == 4'b1001); // Enable tens increment when ones is 9\nassign ena[2] = (q[7:4] == 4'b1001) && (q[3:0] == 4'b1001); // Enable hundreds increment when tens is 9 and ones is 9\nassign ena[3] = (q[11:8] == 4'b1001) && (q[7:4] == 4'b1001) && (q[3:0] == 4'b1001); // Enable thousands increment when hundreds is 9, tens is 9, and ones is 9\n\nendmodule\n", "module top_module(\n    input clk,\n    input reset,\n    output [3:1] ena,\n    output reg [15:0] q\n);\n\n// Enable signals for the tens, hundreds, and thousands digits\nassign ena = {q[11:8] == 9 && q[7:4] == 9 && q[3:0] == 9,  // Thousands enable\n              q[7:4] == 9 && q[3:0] == 9,                 // Hundreds enable\n              q[3:0] == 9};                                // Tens enable\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        q <= 0;\n    end else begin\n        if (q[3:0] == 9) begin\n            q[3:0] <= 0; // Reset ones\n            if (q[7:4] == 9) begin\n                q[7:4] <= 0; // Reset tens\n                if (q[11:8] == 9) begin\n                    q[11:8] <= 0; // Reset hundreds\n                    if (q[15:12] == 9) begin\n                        q[15:12] <= 0; // Reset thousands\n                    end else begin\n                        q[15:12] <= q[15:12] + 1; // Increment thousands\n                    end\n                end else begin\n                    q[11:8] <= q[11:8] + 1; // Increment hundreds\n                end\n            end else begin\n                q[7:4] <= q[7:4] + 1; // Increment tens\n            end\n        end else begin\n            q[3:0] <= q[3:0] + 1; // Increment ones\n        end\n    end\nend\n\nendmodule\n"]}
